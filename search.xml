<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS matplotlib freetype png</title>
    <url>/2017/02/06/CentOS-matplotlib-freetype-png/</url>
    <content><![CDATA[<p>服务器上用virtualenv部署安装matplotlib，始终无法安装，错误日志如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freetype: no  [The C/C++ header for freetype2 (ft2build.h)</span><br><span class="line"></span><br><span class="line">          could not be found.  You may need to install the</span><br><span class="line"></span><br><span class="line">          development package.]</span><br><span class="line"></span><br><span class="line">     png: no  [pkg-config information for &#x27;libpng&#x27; could not</span><br><span class="line"></span><br><span class="line">          be found.]</span><br><span class="line"></span><br><span class="line">   qhull: yes [pkg-config information for &#x27;qhull&#x27; could not be</span><br><span class="line"></span><br><span class="line">          found. Using local copy.]</span><br></pre></td></tr></table></figure>
<p>安装缺失依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install freetype</span><br></pre></td></tr></table></figure>
<p>之后重新安装还是不行,彻底解决方案为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum -y install freetype freetype-devel libpng-devel</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS pip 无法安装python包</title>
    <url>/2016/02/25/CentOS-pip-%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85python%E5%8C%85/</url>
    <content><![CDATA[<p>最初源于一个错误，在使用python包<code>sqlalchemy</code>执行sql统计的时候，报错：</p>
<blockquote>
<p>This result object is closed sqlalchemy</p>
</blockquote>
<p>网上查阅了一下，貌似是多个线程共同使用一个会话或者连接导致，由于之前在其他机器上使用的1.0.8版本同样的sql都没有报过错，我直接用yum安装的0.7.x版本，可能是这个版本比较老，于是我想重新使用pip安装最新版，由于之前升级python，pip是我编译安装的最新版，CentOS自带的是1.4.x版本，我安装的是7.1.2，所以才会有下面的各种问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install sqlalchemy</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<blockquote>
</blockquote>
<p>Requirement already satisfied (use –upgrade to upgrade): sqlalchemy in &#x2F;home&#x2F;q&#x2F;python27&#x2F;lib&#x2F;python2.7&#x2F;site-packages<br>You are using pip version 7.1.2, however version 8.0.2 is available.<br>You should consider upgrading via the ‘pip install –upgrade pip’ command.</p>
<p>于是加上建议重新安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install --upgrade sqlalchemy</span><br></pre></td></tr></table></figure>
<p>仍然报错：</p>
<blockquote>
</blockquote>
<p>The repository located at pypi.xxx.xxx.com is not a trusted or secure host and is being ignored. If this repository is available via HTTPS it is recommended to use HTTPS instead, otherwise you may silence this warning and allow it anyways with ‘–trusted-host pypi.abc.def.com’.</p>
<p>依然按照建议加上参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install --trusted-host pypi.abc.def.com --upgrade sqlalchemy</span><br></pre></td></tr></table></figure>
<p>然后就安装成功了。</p>
<p>有时候升级pip会报这个错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The pip==7.1.0&#x27; distribution was not found and is required by the application</span><br></pre></td></tr></table></figure>
<p>详细解决方案如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# easy_install pip</span><br><span class="line">Searching for pip</span><br><span class="line">Best match: pip 9.0.1</span><br><span class="line">Adding pip 9.0.1 to easy-install.pth file</span><br><span class="line">Installing pip script to /usr/local/python2.7/bin</span><br><span class="line">Installing pip3.5 script to /usr/local/python2.7/bin</span><br><span class="line">Installing pip3 script to /usr/local/python2.7/bin</span><br><span class="line"></span><br><span class="line">Using /usr/local/python2.7/lib/python2.7/site-packages</span><br><span class="line">Processing dependencies for pip</span><br><span class="line">Finished processing dependencies for pip</span><br></pre></td></tr></table></figure>
<p>然后看看系统的pip是哪个地方:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# which pip</span><br><span class="line">/usr/bin/pip</span><br></pre></td></tr></table></figure>
<p>然后我们需要编辑一下这个文件<code>vi /usr/bin/pip</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># EASY-INSTALL-ENTRY-SCRIPT: &#x27;pip==7.1.0&#x27;,&#x27;console_scripts&#x27;,&#x27;pip&#x27;</span><br><span class="line">__requires__ = &#x27;pip==9.0.1&#x27;</span><br><span class="line">import sys</span><br><span class="line">from pkg_resources import load_entry_point</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    sys.exit(</span><br><span class="line">        load_entry_point(&#x27;pip==9.0.1&#x27;, &#x27;console_scripts&#x27;, &#x27;pip&#x27;)()</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是把pip改成你系统安装的pip,然后就可以安装包了．</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.4 配置Python开发环境</title>
    <url>/2016/01/20/CentOS6-4-%E9%85%8D%E7%BD%AEPython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>最近写Python脚本,需要在服务器上运行,也没办法用PyCharm这种带界面的IDE来写Python,不过看了一篇博客,讲的十分不错,所以自己照着弄了一遍,中间有些不够详细的我也一并记录下来.</p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>OS:Linux&#x2F;Unix(服务器是CentOS6.4 64bit)<br>Vim: &gt;&#x3D;vim 7.3(终端直接输入vim –version 可以查看版本)<br>Python: 具体的没试过,我的是Python2.7.4</p>
<h3 id="Vim扩展"><a href="#Vim扩展" class="headerlink" title="Vim扩展"></a>Vim扩展</h3><p>Vim之所以好用,一方面是自身的快捷键很强大,记熟了确实很好用,但是纵观任何一个流行的编辑器,更为重要的一点是可扩展性极强,每个人都可以定制和扩展,最终打造一个最适合自己的编辑器,这个可以说是每个流行的编辑器,浏览器也是如此得以流行的不可或缺的原因.插件太多,一个一个来装太麻烦,并且多了管理起来也不方便,换个系统又得一个一个安装,太麻烦,所以我们需要的第一个东西是:好用的扩展管理器.<br>Vim的扩展通常我们叫bundle或者插件</p>
<h3 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h3><p>Vim的编辑器很多,我就随便选一个了,普通的用也没区别,强烈推荐<code>Vundle</code>.<br>先来安装Vundle:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/vundle</span><br></pre></td></tr></table></figure>
<p>上面的这个只是把Vundle插件管理器下载下来了,并且把插件放在了<code>~/.vim/bundle/</code>目录中,现在通过编辑<code>~/.vimrc</code>来配置Vim编辑器来安装Vundle,如果没有则自己创建一个:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.vimrc</span><br></pre></td></tr></table></figure>
<p>接下在把下面的代码放到<code>~/.vimrc</code>文件顶部:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">&quot; required</span></span><br><span class="line"><span class="string">filetype off                  &quot;</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/vundle</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">&#x27;gmarik/vundle&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Add all your plugins here (note older versions of Vundle used Bundle instead of Plugin)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> All of your Plugins must be added before the following line</span><br><span class="line">call vundle<span class="comment">#end()            &quot; required</span></span><br><span class="line">filetype plugin indent on    <span class="string">&quot; required</span></span><br></pre></td></tr></table></figure>
<p>这样就完成了Vundle的设置,然后就可以安装了,打开Vim编辑器,输入下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>
<p>这个命令非常好用,它告诉Vundle施展它的魔法——自动下载所有的插件，并为你进行安装和更新。</p>
<h3 id="开始打造IDE"><a href="#开始打造IDE" class="headerlink" title="开始打造IDE"></a>开始打造IDE</h3><p>如果你对Vim不熟,可以看看我的这篇文章:<a href="">Vim-常用命令总结</a>,常用的一些命令基本就在这了.好了,开始正式配置Vim了.</p>
<h4 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; Enable folding</span></span><br><span class="line"><span class="string">set foldmethod=indent</span></span><br><span class="line"><span class="string">set foldlevel=99</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 安装transmission 远程下载</title>
    <url>/2019/12/30/CentOS7-%E5%AE%89%E8%A3%85transmission-%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>买的VPS三年了，一不小心忘了续费过期了，数据环境全给清空了，又得重新配置环境。因为有ipv6地址，所以想把上学那会儿的PT站用起来，重新装下<code>transmission</code>,这个装好了可以直接从网页上添加任务挂种，比较方便，安装过程如下 </p>
<h3 id="安装Transmission"><a href="#安装Transmission" class="headerlink" title="安装Transmission"></a>安装Transmission</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装源</span><br><span class="line">yum install epel-release</span><br><span class="line"># 直接安装相关的包</span><br><span class="line">yum install transmission-*</span><br><span class="line"># 启动服务创建配置文件</span><br><span class="line">service transmission-daemon start</span><br><span class="line"># 停止文件修改配置文件</span><br><span class="line">service transmission-daemon stop</span><br></pre></td></tr></table></figure>
<p>修改配置文件<code>/var/lib/transmission/.config/transmission-daemon/settings.json</code>,需要改动的几个地方如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;download-dir&quot;: &quot;/root/pt&quot;,</span><br><span class="line">&quot;incomplete-dir&quot;: &quot;/root/pt&quot;,</span><br><span class="line">&quot;rpc-authentication-required&quot;: true,</span><br><span class="line">&quot;rpc-port&quot;: 12345,</span><br><span class="line">&quot;rpc-enabled&quot;: true,</span><br><span class="line">&quot;rpc-password&quot;: &quot;the fuck password&quot;,</span><br><span class="line">&quot;rpc-username&quot;: &quot;zhangsan&quot;,</span><br><span class="line">&quot;rpc-whitelist&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;rpc-whitelist-enabled&quot;: false,</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 下载的目录文件夹你得手动创建一下，我这里直接就在<code>pt</code>文件夹下面了,端口最好也改下，不要用默认的。</p>
<p>然后重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start transmission-daemon.service</span><br></pre></td></tr></table></figure>

<p>最后网页验证一下,访问<code>http://123.4.5.6:12345/transmission/web/</code>,如果可以访问那就说明可以了。</p>
<h3 id="百度云盘"><a href="#百度云盘" class="headerlink" title="百度云盘"></a>百度云盘</h3><p>其实用PT下载挺快的，一般可以达到30Mb&#x2F;s这种速度，但是怎么把文件搞回来是个问题，直接在服务器上起一个python的httpServer也可以，但是直连非常的慢，还不稳定，所以我采取了一种比较简单的方案：把下载下来的文件同步到百度云盘，然后再通过百度云下载。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装Anaconda2-4.0.0-Linux-x86_64.sh报错</title>
    <url>/2016/06/19/CentOS-%E5%AE%89%E8%A3%85Anaconda2-4-0-0-Linux-x86-64-sh%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>前阵子想给服务器都装上Python的全家桶，结果怎么也装不上,开始安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash Anaconda2-4.0.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>但是装不了，一直报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir: cannot create directory `/home/q/anaconda2&#x27;: Permission denied</span><br><span class="line">ERROR: Could not create directory: /home/q/anaconda2</span><br></pre></td></tr></table></figure>
<p>网上查了之后发现很多人都碰到这个问题,后来大家都建议这么安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo bash Anaconda2-4.0.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>结果报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, user xxx is not allowed to execute &#x27;/bin/bash Anaconda2-4.0.0-Linux-x86_64.sh&#x27; as root on xxxx.</span><br></pre></td></tr></table></figure>
<p>我去，简直无解了，没权限执行这个命令，普通的命令又装不了，结果折腾了好久也没办法，后来通过求助之后才发现，原来给这个包附个权限就可以执行了，原来如此,说干就干:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 Anaconda2-4.0.0-Linux-x86_64.sh</span><br><span class="line">sudo ./Anaconda2-4.0.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>后面一路畅通，搞定。</p>
<p>**Tips:**如果想用这个代替默认的环境变量，有些包这里又没有，假设你的安装目录为<code>/home/usr/anaconda2</code>,那么你可以这么装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /home/usr/anaconda2/bin/pip install &lt;module_name&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>D3 js 笔记02</title>
    <url>/2016/07/14/D3-js-%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<p>常用的操作:选择，插入，删除，前面已经讲了选择元素的相关操作，这里还是简单记一下。</p>
<h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p>假设有三个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;test1&lt;/p&gt;</span><br><span class="line">&lt;p&gt;test2&lt;/p&gt;</span><br><span class="line">&lt;p&gt;test3&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>下面的操作都是基于这三个的元素的操作</p>
<h4 id="选择第一个p元素"><a href="#选择第一个p元素" class="headerlink" title="选择第一个p元素"></a>选择第一个p元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p1 = body.sellect(&quot;p&quot;);</span><br><span class="line">p1.style(&quot;color&quot;, &quot;red&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="全选"><a href="#全选" class="headerlink" title="全选"></a>全选</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = body.sellectAll(&quot;p&quot;);</span><br><span class="line">p.style(&quot;color&quot;, &quot;red&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="选择指定元素"><a href="#选择指定元素" class="headerlink" title="选择指定元素"></a>选择指定元素</h4><ul>
<li>通过元素id属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt; id=&quot;id_2&quot;&gt;Test 2&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>然后使用下面的代码来改变第二个元素的颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p2 = body.select(&quot;#id_2&quot;);</span><br><span class="line">p2.style(&quot;color&quot;,&quot;red&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过元素class属性</li>
</ul>
<p>假设有如下内容，把这个内容改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;c1&quot; id=&quot;id_1&quot;&gt;Apple&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;c1&quot; id=&quot;id_2&quot;&gt;Pear&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;c2&quot; id=&quot;id_3&quot;&gt;Banana&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用下面的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = body.selectAll(&quot;.c1&quot;);</span><br><span class="line">p.style(&quot;color&quot;, &quot;blue&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>备注:<strong>关于<code>select()</code>和<code>selectAll()</code>的参数，其实是符合<code>CSS</code>选择器的条件的，即用<code>#</code>表示</strong>id</strong>，用<code>.</code>表示<strong>class</strong>.这样可以把前两个内容设置成蓝色。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>和Python很像，有<code>insert()</code>以及<code>append()</code>方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append():	# 在选择集末尾插入元素</span><br><span class="line">insert():	# 在选择集前面插入元素</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body.append(&quot;p&quot;).text(&quot;append p element&quot;);	# 在最后插入一个&lt;p&gt;元素，并且设置文本内容</span><br><span class="line">body.insert(&quot;p&quot;, &quot;#id_2&quot;).text(&quot;insert p element&quot;);	# 在id为id_2的元素前面插入一个元素</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple</span><br><span class="line">insert p element</span><br><span class="line">Pear</span><br><span class="line">Banana</span><br><span class="line">append p element</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>这个简单，直接使用<code>remove()</code>即可，对于上面的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = body.select(&quot;#id_1&quot;);</span><br><span class="line">p.remove();	# 删除id=id_1的元素</span><br></pre></td></tr></table></figure>

<h2 id="简单图表"><a href="#简单图表" class="headerlink" title="简单图表"></a>简单图表</h2><p>简单介绍一下图表，但是的先明白几个常见的术语:<br>要画图，必须要在一个用来画图的东西，通常我们用画布来画图，常见的画布又两种:<code>SVG</code>和<code>Canvas</code>。</p>
<ul>
<li>SVG</li>
</ul>
<p>SVG是指可缩放的矢量图形，主要用来描述二维矢量图形，定义图形也很简单，使用<code>xml</code>来定义图形。由于是用<code>xml</code>来定义图形，所以每个元素都可以添加JavaScript事件处理器。</p>
<ul>
<li>Canvas</li>
</ul>
<p>Canvas是通过JavaScript来绘制2D图形</p>
<p>**注意:**这里需要说明一下，D3提供的很多画图的函数都是SVG图形生成器，所以建议在学习D3.js的时候使用SVG画布,添加一个<code>SVG</code>也很简单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var width = 300;  //画布的宽度</span><br><span class="line">var height = 300;   //画布的高度</span><br><span class="line"> </span><br><span class="line">var svg = d3.select(&quot;body&quot;)     //选择文档中的body元素</span><br><span class="line">    .append(&quot;svg&quot;)          //添加一个svg元素</span><br><span class="line">    .attr(&quot;width&quot;, width)       //设定宽度</span><br><span class="line">    .attr(&quot;height&quot;, height);    //设定高度</span><br></pre></td></tr></table></figure>
<p>下面就可以在这个svg上画各种图了,先上源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;HelloWorld&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var width = 300;</span><br><span class="line">    var height = 300;</span><br><span class="line"></span><br><span class="line">    var svg = d3.select(&quot;body&quot;)</span><br><span class="line">            .append(&quot;svg&quot;)</span><br><span class="line">            .attr(&quot;width&quot;, width)</span><br><span class="line">            .attr(&quot;height&quot;, height);</span><br><span class="line"></span><br><span class="line">    var dataSet = [250, 210, 170, 130, 90];</span><br><span class="line">    var rectHeight = 25;</span><br><span class="line"></span><br><span class="line">    svg.selectAll(&quot;rect&quot;)</span><br><span class="line">            .data(dataSet)</span><br><span class="line">            .enter()</span><br><span class="line">            .append(&quot;rect&quot;)</span><br><span class="line">            .attr(&quot;x&quot;, 20)  // 设置举行左上角开始x位置</span><br><span class="line">            .attr(&quot;y&quot;, function(d, i) &#123;     // 设置举行左上角开始y位置</span><br><span class="line">                return i * rectHeight;</span><br><span class="line">            &#125;)</span><br><span class="line">            .attr(&quot;width&quot;, function(d) &#123;    // 设置每个举行的宽度(长度)</span><br><span class="line">                return d;</span><br><span class="line">            &#125;)</span><br><span class="line">            .attr(&quot;height&quot;, rectHeight - 2) // 行之间空出一条间隙</span><br><span class="line">            .attr(&quot;fill&quot;, &quot;steelblue&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>解释一下,<code>&lt;rect&gt;</code>为矩形，它有四个属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x：矩形左上角的 x 坐标</span><br><span class="line">y：矩形左上角的 y 坐标</span><br><span class="line">width：矩形的宽度</span><br><span class="line">height：矩形的高度</span><br></pre></td></tr></table></figure>
<p>其中x轴正方向为水平向右，y轴正方向为垂直向下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dataSet = [250, 210, 170, 130, 90];</span><br></pre></td></tr></table></figure>
<p>用来存储几个长方形的长度，即<code>width</code>属性值，添加和<code>dataSet</code>数量相等的矩形，所使用的代码是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svg.selectAll(&quot;rect&quot;)</span><br><span class="line">        .data(dataSet)</span><br><span class="line">        .enter()</span><br><span class="line">        .append(&quot;rect&quot;)</span><br></pre></td></tr></table></figure>
<p>这段代码先记住，可以添加足够多的元素，后面细讲机制，然后就是前面讲过的给元素附属性值了，依次给每个举行设置那四个属性的值，<code>dataSet</code>里面的元素设置成举行的<code>width</code>属性值，最后设置一下颜色，效果如下:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/D3%20js%20%E7%AC%94%E8%AE%B002%20001.jpg" alt="svg图表"></p>
<h2 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h2><p>上面的设置矩形的长度用的是一个数组，里面的值直接设置成了矩形的像素长度，但是这样比较死，有可能太大也有可能太小，所以使用比例尺是个不错的注意，只要设置一种放缩关系，只用设定上下限，中间的值会自动放缩会很方便。<br>简单来说就是一个函数<code>x-&gt;y</code>这样的一种映射关系,x为定义域，y为值域。</p>
<h3 id="线性比例尺"><a href="#线性比例尺" class="headerlink" title="线性比例尺"></a>线性比例尺</h3><p>这种比例尺比较常用，也比较简单，使用上只用设定上下限即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dataSet = [1.2, 2.3, 0.9, 1.5, 3.3];</span><br><span class="line">var min = d3.min(dataSet);</span><br><span class="line">var max = d3.max(dataSet);</span><br><span class="line"></span><br><span class="line">var linear = d3.scale.linear()</span><br><span class="line">	.domain([min, max])</span><br><span class="line">	.range([0, 300])</span><br><span class="line"></span><br><span class="line">linear(0.9)</span><br><span class="line">linear(2.3)</span><br><span class="line">linear(3.3)</span><br></pre></td></tr></table></figure>
<p><code>d3.scale.linear()</code>返回线性比例尺，也可以当函数使用。</p>
<h3 id="离散比例尺"><a href="#离散比例尺" class="headerlink" title="离散比例尺"></a>离散比例尺</h3><p>有时候需要的并不一定是线性连续的映射关系，可能是把某一批转化成另一类元素，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var index = [0, 1, 2, 3, 4];</span><br><span class="line">var color = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;black&quot;];</span><br></pre></td></tr></table></figure>
<p>需要把对应的序号映射到颜色上去，用序数比例尺就更合适:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ordinal = d3.scale.ordinal()</span><br><span class="line">        .domain(index)</span><br><span class="line">        .range(color);</span><br><span class="line"></span><br><span class="line">ordinal(0); //返回 red</span><br><span class="line">ordinal(2); //返回 green</span><br><span class="line">ordinal(4); //返回 black</span><br></pre></td></tr></table></figure>
<p>所以上面讲的柱形图，我们可以利用比例尺改写一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var rectHeight = 25;   //每个矩形所占的像素高度(包括空白)</span><br><span class="line"></span><br><span class="line">svg.selectAll(&quot;rect&quot;)</span><br><span class="line">    .data(dataset)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(&quot;rect&quot;)</span><br><span class="line">    .attr(&quot;x&quot;,20)</span><br><span class="line">    .attr(&quot;y&quot;,function(d,i)&#123;</span><br><span class="line">         return i * rectHeight;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(&quot;width&quot;,function(d)&#123;</span><br><span class="line">         return linear(d);   //在这里用比例尺</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(&quot;height&quot;,rectHeight-2)</span><br><span class="line">    .attr(&quot;fill&quot;,&quot;steelblue&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JScript</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 笔记01</title>
    <url>/2016/07/10/D3-js-%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<p>对于做数据的来说，调度器这个东西应该不是陌生概念，数据流就是靠着调度器调度的，然后进行汇总，整合。但是随着调度器上的任务越来越多,任务之间的依赖变得很复杂，而且有时候有一些任务需要用到重要的模型，报表或者邮件日报中，这就要求用到的这些数据任务流需要进行一些优化，但是没有一个任务依赖图做全局参考，优化有时候不是那么好做，所以近期打算使用<code>D3.js</code>这个库给现有的调度器做一个任务依赖图，可以更好的把控数流。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先需要下载<a href="https://d3js.org/">d3.js官网</a>,下载<code>d3.zip</code>文件，解压之后把里面的<code>d3.min.js</code>拷贝到项目里面,我的项目目录路径为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  script git:(web-d3.js) ✗ tree</span><br><span class="line">.</span><br><span class="line">├── hello_world.html</span><br><span class="line">├── js</span><br><span class="line">│   └── d3.min.js</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<p><code>d3.min.js</code>文件放在项目目录下的的<code>js</code>文件夹，先来一个Hello World<code>,新建一个</code>hello_world.html&#96;文件，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;HelloWorld&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;Hello World 1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;Hello World 2&lt;/p&gt;</span><br><span class="line">        &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        d3.select(&quot;body&quot;).selectAll(&quot;p&quot;).text(&quot;www.ourd3js.com&quot;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>打开浏览器就可以看到效果，所有的<code>&lt;p&gt;</code>标签里面的内容都被替换了。如果换成普通的js来实现也可以，不过得用一个循环，<code>D3</code>所做的事就是减轻你的工作量，以及使你的代码十分简单易懂。下面还有个简单的样例,也是类似余替代循环:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;HelloWorld&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;Hello World 1&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Hello World 2&lt;/p&gt;</span><br><span class="line">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //选择&lt;body&gt;中所有的&lt;p&gt;，其文本内容为 www.ourd3js.com，选择集保存在变量 p 中</span><br><span class="line">    var p = d3.select(&quot;body&quot;)</span><br><span class="line">            .selectAll(&quot;p&quot;)</span><br><span class="line">            .text(&quot;www.ourd3js.com&quot;);</span><br><span class="line"></span><br><span class="line">    //修改段落的颜色和字体大小</span><br><span class="line">    p.style(&quot;color&quot;, &quot;red&quot;)</span><br><span class="line">            .style(&quot;font-size&quot;, &quot;72px&quot;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码是先将选中的元素赋值给变量<code>p</code>，然后通过变量<code>p</code>来改变样式，这样可以使代码更整洁。</p>
<p>这里就展示除了<code>D3.js</code>的一个很重要的概念:<strong>选择集</strong>,像<code>de.select()</code>或<code>d3.sellectAll()</code>选择元素返回的对象都是选择集.<br>除了选择集，<code>d3.js</code>还可以链式不停的调用函数<code>d3.select().selectAll().text()</code>链式语法。</p>
<h3 id="选择-绑定数据"><a href="#选择-绑定数据" class="headerlink" title="选择 绑定数据"></a>选择 绑定数据</h3><p>既然是操作数据，当然少不了选择需要操作的元素以及绑定对应的数据到对应的元素上。</p>
<h4 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d3.select():	是选择所有指定元素的第一个</span><br><span class="line">d3.selectAll():	是选择指定元素的全部</span><br></pre></td></tr></table></figure>
<p>上面的函数返回的结果都是返回集,常见用法有:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var body = d3.select(&quot;body&quot;); //选择文档中的body元素</span><br><span class="line">var p1 = body.select(&quot;p&quot;);      //选择body中的第一个p元素</span><br><span class="line">var p = body.selectAll(&quot;p&quot;);    //选择body中的所有p元素</span><br><span class="line">var svg = body.select(&quot;svg&quot;);   //选择body中的svg元素</span><br><span class="line">var rects = svg.selectAll(&quot;rect&quot;);  //选择svg中所有的svg元素</span><br></pre></td></tr></table></figure>

<h4 id="绑定元素"><a href="#绑定元素" class="headerlink" title="绑定元素"></a>绑定元素</h4><p>选择元素最终也是为了操作元素，尤其是元素的值，即数据，绑定数据主要用下面两个方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datum():	绑定一个数据到选择集上</span><br><span class="line">data():		绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</span><br></pre></td></tr></table></figure>
<p>以具体的例子来看,<code>data()</code>和<code>datum()</code>如何绑定数据:<br>首先在html代码里面写上几个供测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Apple&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Pear&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Banana&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>datum()</li>
</ul>
<p>假设有我们有一个字符串，把这个字符串的内容绑定到这三个段落标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var str = &quot;China&quot;;</span><br><span class="line"></span><br><span class="line">    var body = d3.select(&quot;body&quot;);</span><br><span class="line">    var p = body.selectAll(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">    p.datum(str);</span><br><span class="line"></span><br><span class="line">    p.text(function (d, i) &#123;</span><br><span class="line">        return &quot;第 &quot; + i + &quot; 个元素绑定的数据是 &quot; + d;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>运行这段代码的结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第 0 个元素绑定的数据是 China</span><br><span class="line"></span><br><span class="line">第 1 个元素绑定的数据是 China</span><br><span class="line"></span><br><span class="line">第 2 个元素绑定的数据是 China</span><br></pre></td></tr></table></figure>
<p>**备注:**匿名函数<code>function(d,i)</code>的应用场景一般是选择集需要使用绑定的数据，两个参数的意思分别是:</p>
<ul>
<li><p>d:代表数据，也就是绑定的数据</p>
</li>
<li><p>i:代表索引，代表数据的索引号,从0开始</p>
</li>
<li><p>data()</p>
</li>
</ul>
<p>现在假设我们要把一个数组的元素依次赋值给前面的三个<code>&lt;p&gt;</code>，调用<code>data()</code>绑定数据，并替换成相应的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Apple&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Pear&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Banana&lt;/p&gt;</span><br><span class="line">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dataset = [&quot;I like dogs&quot;, &quot;I like cats&quot;, &quot;I like snakes&quot;];</span><br><span class="line"></span><br><span class="line">    var body = d3.select(&quot;body&quot;);</span><br><span class="line">    var p = body.selectAll(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">    p.data(dataset)</span><br><span class="line">            .text(function (d, i) &#123;</span><br><span class="line">                return d</span><br><span class="line">            &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I like dogs</span><br><span class="line"></span><br><span class="line">I like cats</span><br><span class="line"></span><br><span class="line">I like snakes</span><br></pre></td></tr></table></figure>
<p>这里的<code>function(d, i)</code>和上面的一样，<code>d</code>代表绑定的数据,<code>i</code>代表选择集元素序号，也是对选择集进行依次设置值</p>
]]></content>
      <categories>
        <category>JScript</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>Web</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DataTables 常用操作</title>
    <url>/2016/11/04/DataTables-%E6%94%B9%E5%8F%98%E5%88%97%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>DataTables这个插件功能非常强大，也很灵活，所以这里介绍一下几个项目里用到的常用操作,基本使用可以参考上一篇<a href="2016/10/01/DataTables%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B">DataTables使用样例</a></p>
<h3 id="改变列渲染方式"><a href="#改变列渲染方式" class="headerlink" title="改变列渲染方式"></a>改变列渲染方式</h3><p>有时候需要给某些列单独渲染，或者在已有基础上增加一点特效，类似于状态之类的，比如:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/DataTables%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C01.png" alt="改变列渲染模式"><br>像这种可能状态列可能就是个0,1,2枚举值，需要根据不同的枚举值显示不同的效果，普通情况下当然就是显示数字了，现在假设状态列返回<code>True/False</code>代表激活&#x2F;未激活，实现效果的部分具体代码为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myTable = $(&#x27;#dynamic-table&#x27;).DataTable(&#123;</span><br><span class="line">                &quot;bDestroy&quot;: true,</span><br><span class="line">                //&quot;bProcessing&quot;: true,</span><br><span class="line">                &quot;bServerSide&quot;: true,</span><br><span class="line">                &quot;sAjaxSource&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;fnServerData&quot;: function (sSource, aoData, fnCallback) &#123;</span><br><span class="line">                    $.ajax(&#123;</span><br><span class="line">                        &#x27;dataType&#x27;: &#x27;json&#x27;,</span><br><span class="line">                        &#x27;type&#x27;: &#x27;POST&#x27;,</span><br><span class="line">                        &#x27;url&#x27;: sSource,</span><br><span class="line">                        &#x27;data&#x27;: aoData,</span><br><span class="line">                        &#x27;success&#x27;: fnCallback</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;columnDefs&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;render&quot;: function (data, type, row) &#123;</span><br><span class="line">                            if (data == true) &#123;</span><br><span class="line">                                return &#x27;&lt;span class=&quot;label label-sm label-success&quot;&gt;激活&lt;/span&gt;&#x27;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                return &#x27;&lt;span class=&quot;label label-sm label-inverse&quot;&gt;未激活&lt;/span&gt;&#x27;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;targets&quot;: 2</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br></pre></td></tr></table></figure>
<p>参数解释:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>单元格的实际值，这里为0&#x2F;1,即True&#x2F;False</td>
</tr>
<tr>
<td>targets</td>
<td>指定的是哪一列，下标从0开始,即你指定了哪一列，data就是那一列的值了</td>
</tr>
<tr>
<td>row</td>
<td>表格一行的值</td>
</tr>
</tbody></table>
<p>最后的效果就像上面那样了。</p>
<h3 id="单元格填充控件"><a href="#单元格填充控件" class="headerlink" title="单元格填充控件"></a>单元格填充控件</h3><p>有时候表格的元素是控件而不是简单的字符串填充，并且这个控件还必须有对应的事件监听，这个时候也可以使用上面的方法同样来实现，现在假设我要给表格的最后一列添加两个按钮，这两个按钮可以操作这行的元素:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var edit_str =</span><br><span class="line">       &#x27;&lt;div class=&quot;hidden-sm hidden-xs btn-group&quot;&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;button id=&quot;edit&quot; class=&quot;btn btn-xs btn-success&quot;&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;i class=&quot;ace-icon fa fa-pencil-square-o bigger-120&quot;&gt;&lt;/i&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;/button&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;button id=&quot;delete&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;/button&gt;&#x27; +</span><br><span class="line">       &#x27;&lt;/div&gt;&#x27;</span><br><span class="line"></span><br><span class="line">    //initiate dataTables plugin</span><br><span class="line">    var myTable = $(&#x27;#dynamic-table&#x27;).DataTable(&#123;</span><br><span class="line">        bAutoWidth: false,</span><br><span class="line">        &quot;columnDefs&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;render&quot;: function (data, type, row) &#123;</span><br><span class="line">                    row.edit = edit_str // 往每一行最后一列添加一个属性,即一列</span><br><span class="line">                    if (data == true) &#123;</span><br><span class="line">                        return &#x27;&lt;span class=&quot;label label-sm label-success&quot;&gt;激活&lt;/span&gt;&#x27;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return &#x27;&lt;span class=&quot;label label-sm label-inverse&quot;&gt;未激活&lt;/span&gt;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;targets&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>
<p>看一下最后的显示效果:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/DataTables%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C02.png" alt="单元格填充控件"><br>进一步需要给这两个按钮添加操作，例如编辑按钮可以编辑状态，删除按钮会删除这一行,注意我们添加的两个按钮的id分别为<code>edit</code>,<code>delete</code>,表格的id为<code>dynamic-table</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&#x27;#dynamic-table tbody&#x27;).on(&#x27;click&#x27;, &#x27;button#edit&#x27;, function () &#123;</span><br><span class="line">    var data = myTable.row($(this).parents(&#x27;tr&#x27;)).data();</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;xxx&quot;,</span><br><span class="line">        type: &quot;POST&quot;,</span><br><span class="line">        dataType: &quot;json&quot;,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;).done(function (resp) &#123;</span><br><span class="line">        if (resp.ret == true) &#123;</span><br><span class="line">            myTable.ajax.reload();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&quot;编辑失败!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).fail(function () &#123;</span><br><span class="line">        alert(&quot;网络错误！&quot;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(&#x27;#dynamic-table tbody&#x27;).on(&#x27;click&#x27;, &#x27;button#delete&#x27;, function () &#123;</span><br><span class="line">    var data = myTable.row($(this).parents(&#x27;tr&#x27;)).data();</span><br><span class="line"></span><br><span class="line">    var title_msg;</span><br><span class="line">    var text_msg;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        url: &quot;xxxx&quot;,</span><br><span class="line">        dataType: &quot;json&quot;,</span><br><span class="line">        data: data,</span><br><span class="line">        success: function (resp) &#123;</span><br><span class="line">            if (resp.ret) &#123;</span><br><span class="line">                    alert(&quot;成功删除!&quot;);</span><br><span class="line">                    myTable.ajax.reload();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;删除失败!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Datatables</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 6.4 安装matplotlib包</title>
    <url>/2016/02/04/Centos-6-4-%E5%AE%89%E8%A3%85matplotlib%E5%8C%85/</url>
    <content><![CDATA[<p>官方推荐的安装方法：</p>
<ul>
<li>Debian &#x2F; Ubuntu : sudo apt-get install python-matplotlib</li>
<li>Fedora &#x2F; Redhat : sudo yum install python-matplotlib</li>
</ul>
<p>判断是否安装成功的方法，在python交互式环境下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br></pre></td></tr></table></figure>
<p>如果没有报错，则说明安装成功了，如果这样还不成功，可以通过pip来安装，如何安装pip,<br>参见文章<a href="../../../2016/01/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85pip%E5%B7%A5%E5%85%B7">服务器安装pip工具</a>,具体的命令就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py</span><br><span class="line">$ sudo python ez_setup.py --insecure</span><br><span class="line">$ sudo wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-7.1.2.tar.gz</span><br><span class="line">$ sudo tar -xvf pip-7.1.2.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> pip-7.1.2</span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure>

<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo pip install module_name</span><br></pre></td></tr></table></figure>

<p>如果使用pip安装不成功，可以通过编译<code>matplotlib</code>源码来手动安装，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo wget --no-check-certificate https://pypi.python.org/packages/source/m/matplotlib/matplotlib-1.5.1.tar.gz </span><br><span class="line">$ sudo tar -xvf matplotlib-1.5.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> matplotlib-1.5.1</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure>
<p>但是我在执行<code>python setup.py build</code>的时候，,提示缺少依赖，无法构建，缺少依赖,根据<code>build</code>打印出的信息，把必须的依赖里为<code>no</code>的包都装上，基本就是<code>libpng</code>,<code>freetype</code>这两个，具体如何安装，可以先执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list | grep libpng</span><br></pre></td></tr></table></figure>
<p>从打印出来的结果里挑一个适合你系统的版本，记住，如果正统的版本安装了还不行，你还需要安装<code>libpng-devel</code>这种类似的名字的包，是情况而定。<br>然后所有的依赖安装好了之后，终于<code>build</code>成功了，但是我在执行<code>install</code>的时候，还是出错了，<code>gcc-plus</code>错误，出现这种错误是由于没有装<code>g++</code>的库，安装方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list | grep gcc</span><br><span class="line">gcc.x86_64                             4.4.7-3.el6                 @base        </span><br><span class="line">gcc-c++.x86_64                         4.4.7-3.el6                 @base        </span><br><span class="line">libgcc.x86_64                          4.4.7-3.el6                 @anaconda-CentOS-201303020151.x86_64/6.4</span><br><span class="line">compat-gcc-34.x86_64                   3.4.6-19.el6                base         </span><br><span class="line">compat-gcc-34-c++.x86_64               3.4.6-19.el6                base         </span><br><span class="line">compat-gcc-34-g77.x86_64               3.4.6-19.el6                base         </span><br><span class="line">gcc-gfortran.x86_64                    4.4.7-3.el6                 base         </span><br><span class="line">gcc-gnat.x86_64                        4.4.7-3.el6                 base         </span><br><span class="line">gcc-java.x86_64                        4.4.7-3.el6                 base         </span><br><span class="line">gcc-objc.x86_64                        4.4.7-3.el6                 base         </span><br><span class="line">gcc-objc++.x86_64                      4.4.7-3.el6                 base         </span><br><span class="line">libgcc.i686                            4.4.7-3.el6                 base         </span><br><span class="line">mingw32-gcc.x86_64                     4.4.6-4.el6                 base         </span><br><span class="line">mingw32-gcc-c++.x86_64                 4.4.6-4.el6                 base         </span><br><span class="line">mingw32-gcc-gfortran.x86_64            4.4.6-4.el6                 base         </span><br><span class="line">mingw32-gcc-objc.x86_64                4.4.6-4.el6                 base         </span><br><span class="line">mingw32-gcc-objc++.x86_64              4.4.6-4.el6                 base     </span><br></pre></td></tr></table></figure>
<p>可以看到有很多包，你可以都装上，但是此处我们只需要<code>gcc-c++.x86_64</code>，装完之后，然后重新执行<code>python setup.py install</code>安装即可。然后再进入<code>python</code>交互式环境就可以引用<code>matplotlib</code>包了。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>DataTables使用样例</title>
    <url>/2016/10/01/DataTables%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</url>
    <content><![CDATA[<p>最近开发公司内部系统里面大量要使用到数据的展示,所以最后就研究了一下<code>DataTables</code>这个Js的插件，功能确实很强大，总结一下如何使用这个插件以及使用过程中碰到的一些问题。<br>我会先做一个简单的事例,然后逐渐扩展功能达到系统想要的要求，环境准备:</p>
<table>
<thead>
<tr>
<th>环境</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>OS</td>
<td>Ubuntu 16.04 64bits <br>python2.7</td>
</tr>
<tr>
<td>Web框架</td>
<td><a href="http://docs.jinkan.org/docs/flask/">Flask 0.11.1</a></td>
</tr>
<tr>
<td>模板引擎</td>
<td><a href="http://docs.jinkan.org/docs/jinja2/">Jinjia2 2.8</a></td>
</tr>
<tr>
<td>前端框架</td>
<td><a href="http://ace.jeka.by/">ACE</a></td>
</tr>
<tr>
<td>Js插件</td>
<td><a href="https://www.datatables.net/">DataTables</a></td>
</tr>
</tbody></table>
<h3 id="初始环境搭建"><a href="#初始环境搭建" class="headerlink" title="初始环境搭建"></a>初始环境搭建</h3><p>把需要的东西都下载下来即可，如果嫌麻烦，可以直接用第三方的cdn,国内的话推荐:<a href="http://www.bootcdn.cn/">Bootstrap官方推荐</a>,但是Ace这个框架的东西你还是要下载的，毕竟里面包含的东西太多了，github上直接clone到本地即可<a href="https://github.com/bopoda/ace">Ace Github地址</a>:下载之后把<code>assets</code>整个文件夹拷过来即可，由于是演示，所以这个项目可能会又其他一些演示，这里我使用蓝图对不同的演示进行分模块,基本的项目结构如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">└── web</span><br><span class="line">    ├── config.py</span><br><span class="line">    ├── datatables</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── templates</span><br><span class="line">    │   │   └── data_table</span><br><span class="line">    │   │       └── index.html</span><br><span class="line">    │   └── views.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── run.py</span><br><span class="line">    ├── static</span><br><span class="line">    │   └── assets</span><br><span class="line">    │       ├── css</span><br><span class="line">    │       ├── font-awesome</span><br><span class="line">    │       ├── fonts</span><br><span class="line">    │       ├── images</span><br><span class="line">    │       ├── js</span><br><span class="line">    │       └── swf</span><br><span class="line">    └── templates</span><br><span class="line">        └── base.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据都是用Ajax异步请求获取,其中异步获取数据包括两个部分:</p>
<ul>
<li>异步获取表格的头部列信息,即表格头部一般是之前不知道的，这种情况尤其适用于BI平台这种专门展示数据的获取数据方式。</li>
<li>异步获取表格的填充数据信息,这个毫无疑问了，后端分页必须这么做</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端主要就两个接口，由于只是演示，所以数据不是从数据库里面查的，但是是一样的效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from flask import Blueprint, render_template, jsonify, request</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">data_table = Blueprint(&#x27;data_table&#x27;, __name__, template_folder=&#x27;templates&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@data_table.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&#x27;data_table/index.html&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@data_table.route(&#x27;/cols&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def cols():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取表格需要展示列信息</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return jsonify(ret=True, columns=[&#x27;col1&#x27;, &#x27;col2&#x27;, &#x27;col3&#x27;, &#x27;col4&#x27;, &#x27;col5&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@data_table.route(&#x27;/data&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def data():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取表格需要展示数据</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 生成一个100行 5列的二维数组</span><br><span class="line">    ao_data = map(lambda row: map(lambda col: &#x27;(%s,%s)&#x27; % (row, col), range(1, 6)), range(1, 101))</span><br><span class="line"></span><br><span class="line">    start = int(request.form.get(&#x27;iDisplayStart&#x27;))</span><br><span class="line">    end = int(request.form.get(&#x27;iDisplayStart&#x27;)) + int(request.form.get(&#x27;iDisplayLength&#x27;))</span><br><span class="line"></span><br><span class="line">    return jsonify(&#123;</span><br><span class="line">        &quot;sEcho&quot;: request.form.get(&#x27;sEcho&#x27;),</span><br><span class="line">        &quot;iTotalRecords&quot;: 100,</span><br><span class="line">        &quot;iTotalDisplayRecords&quot;: 100,</span><br><span class="line">        &quot;aaData&quot;: ao_data[start:end]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>**备注:**默认是解析<code>aaData</code>里面的数据进行填充，当然这个也可以在前端设置的。由于是后端获取数据进行分页，并且是用<code>POST</code>方式传输参数，所以可以用<code>request.form.get()</code>来获取各种<code>dataTables</code>的参数，又很多，将几个主要的:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>sEcho</td>
<td>点击标记位,每次查询这个数会自增，需要原封不动的给传回去，不然不能分页</td>
</tr>
<tr>
<td>iTotalRecords</td>
<td>总记录条数,显示用</td>
</tr>
<tr>
<td>iTotalDisplayRecords</td>
<td>过滤之后的条数</td>
</tr>
<tr>
<td>aaData</td>
<td>填充表格的数据，二维数组</td>
</tr>
<tr>
<td>iDisplayStart</td>
<td>数据开始位置,分页用</td>
</tr>
<tr>
<td>iDisplayLength</td>
<td>每页显示数据条数,分页用</td>
</tr>
<tr>
<td>sSortDir_[index]</td>
<td>第index列数据顺序,例如 sSortDir_0&#x3D;’desc’表示最后返回的数据按第一列升序排序</td>
</tr>
<tr>
<td>sSearch</td>
<td>搜索，即过滤条件</td>
</tr>
</tbody></table>
<p>所以如果你是从数据库查询数据的话，可以把这些参数解析了然后拼出你要的sql，这样就可以按条件查询出你要的结果了，不过这个搜索过滤条件就比较随意，这里我就假定是对第一列进行搜索,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">  col1,</span><br><span class="line">  col2,</span><br><span class="line">  col3,</span><br><span class="line">  col4,</span><br><span class="line">  col5</span><br><span class="line">from</span><br><span class="line">  user  </span><br><span class="line">where</span><br><span class="line">  col1 like $&#123;sSearch&#125;</span><br><span class="line">order by</span><br><span class="line">  col1 desc</span><br><span class="line">limit </span><br><span class="line">  $&#123;iDisplayLength&#125; offset $&#123;iDisplayStart&#125;;</span><br></pre></td></tr></table></figure>
<p>这样后端的工作就基本完成了。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端的代码就一个文件，主要是用到了<a href="http://docs.jinkan.org/docs/jinja2/">Jinjia2</a>,不熟悉这个语法的可以去官网大概看一下，非常好上手，就是一个模板替换引擎,有一个公共的基础模板，里面引入了一些外部的文件和样式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">    DataTables演示</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-xs-12&quot;&gt;</span><br><span class="line">                &lt;!-- PAGE CONTENT BEGINS --&gt;</span><br><span class="line">                &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;col-xs-12&quot;&gt;</span><br><span class="line">                        &lt;h3 class=&quot;header smaller lighter blue&quot;&gt;</span><br><span class="line">                            表格大标题</span><br><span class="line">                        &lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line">                            &lt;div class=&quot;pull-right tableTools-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                        &lt;div class=&quot;table-header&quot;&gt;</span><br><span class="line">                            我是表头</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;!-- div.dataTables_borderWrap --&gt;</span><br><span class="line">                        &lt;div&gt;</span><br><span class="line">                            &lt;table id=&quot;dynamic-table&quot;</span><br><span class="line">                                   class=&quot;table table-striped table-bordered table-hover&quot;&gt;</span><br><span class="line">                                &lt;thead&gt;</span><br><span class="line">                                    &lt;tr&gt;</span><br><span class="line">                                    &lt;/tr&gt;</span><br><span class="line">                                &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">                                &lt;tbody&gt;</span><br><span class="line">                                &lt;/tbody&gt;</span><br><span class="line">                            &lt;/table&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                &lt;div id=&quot;modal-table&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;modal-dialog&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;modal-content&quot;&gt;</span><br><span class="line">                            &lt;div class=&quot;modal-header no-padding&quot;&gt;</span><br><span class="line">                                &lt;div class=&quot;table-header&quot;&gt;</span><br><span class="line">                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;</span><br><span class="line">                                            aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">                                        &lt;span class=&quot;white&quot;&gt;&amp;times;&lt;/span&gt;</span><br><span class="line">                                    &lt;/button&gt;</span><br><span class="line">                                    Results for &quot;Latest Registered Domains</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;div class=&quot;modal-body no-padding&quot;&gt;</span><br><span class="line">                                &lt;table class=&quot;table table-striped table-bordered table-hover no-margin-bottom no-border-top&quot;&gt;</span><br><span class="line">                                    &lt;thead&gt;</span><br><span class="line"></span><br><span class="line">                                    &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">                                    &lt;tbody&gt;</span><br><span class="line"></span><br><span class="line">                                    &lt;/tbody&gt;</span><br><span class="line">                                &lt;/table&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;div class=&quot;modal-footer no-margin-top&quot;&gt;</span><br><span class="line">                                &lt;button class=&quot;btn btn-sm btn-danger pull-left&quot; data-dismiss=&quot;modal&quot;&gt;</span><br><span class="line">                                    &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;</span><br><span class="line">                                    Close</span><br><span class="line">                                &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">                                &lt;ul class=&quot;pagination pull-right no-margin&quot;&gt;</span><br><span class="line">                                    &lt;li class=&quot;prev disabled&quot;&gt;</span><br><span class="line">                                        &lt;a href=&quot;#&quot;&gt;</span><br><span class="line">                                            &lt;i class=&quot;ace-icon fa fa-angle-double-left&quot;&gt;&lt;/i&gt;</span><br><span class="line">                                        &lt;/a&gt;</span><br><span class="line">                                    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">                                    &lt;li class=&quot;next&quot;&gt;</span><br><span class="line">                                        &lt;a href=&quot;#&quot;&gt;</span><br><span class="line">                                            &lt;i class=&quot;ace-icon fa fa-angle-double-right&quot;&gt;&lt;/i&gt;</span><br><span class="line">                                        &lt;/a&gt;</span><br><span class="line">                                    &lt;/li&gt;</span><br><span class="line">                                &lt;/ul&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                        &lt;!-- /.modal-content --&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;!-- /.modal-dialog --&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.page-content --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;  &lt;!-- 单独一个完整报表展示--&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &lt;!-- DataTables　Js--&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/jquery.dataTables.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/jquery.dataTables.bootstrap.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/dataTables.buttons.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/buttons.flash.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/buttons.html5.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/buttons.print.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/buttons.colVis.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;assets/js/dataTables.select.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var table = $(&#x27;#dynamic-table&#x27;)</span><br><span class="line">        var aoColumns = []</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            contentType: &quot;application/json; charset=utf-8&quot;,</span><br><span class="line">            url: &quot;&#123;&#123; url_for(&#x27;data_table.cols&#x27;) &#125;&#125;&quot;,</span><br><span class="line">            type: &#x27;post&#x27;,</span><br><span class="line">            success: function (resp) &#123;</span><br><span class="line">                $.each(resp.columns, function (i, v) &#123;</span><br><span class="line">                    table.find(&#x27;thead &gt; tr&#x27;).append(&#x27;&lt;th&gt;&#x27; + v + &#x27;&lt;/th&gt;&#x27;)</span><br><span class="line">                    aoColumns.push(&#123;&quot;title&quot;: v&#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                showTables(table, aoColumns)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        function showTables(dom_table, cols) &#123;</span><br><span class="line"></span><br><span class="line">            //initiate dataTables plugin</span><br><span class="line">            var myTable = dom_table.DataTable(&#123;</span><br><span class="line">                bAutoWidth: false,</span><br><span class="line">                &quot;aoColumns&quot;: cols,</span><br><span class="line">                &quot;aaSorting&quot;: [],</span><br><span class="line"></span><br><span class="line">                //&quot;bProcessing&quot;: true,</span><br><span class="line">                &quot;bServerSide&quot;: true,</span><br><span class="line">                &quot;sAjaxSource&quot;: &quot;&#123;&#123; url_for(&#x27;data_table.data&#x27;) &#125;&#125;&quot;,</span><br><span class="line">                &quot;fnServerData&quot;: function (sSource, aoData, fnCallback) &#123;</span><br><span class="line">                    $.ajax(&#123;</span><br><span class="line">                        &#x27;dataType&#x27;: &#x27;json&#x27;,</span><br><span class="line">                        &#x27;type&#x27;: &#x27;POST&#x27;,</span><br><span class="line">                        &#x27;url&#x27;: sSource,</span><br><span class="line">                        &#x27;data&#x27;: aoData,</span><br><span class="line">                        &#x27;success&#x27;: fnCallback</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;,</span><br><span class="line">                //,</span><br><span class="line">                //&quot;sScrollY&quot;: &quot;200px&quot;,</span><br><span class="line">                //&quot;bPaginate&quot;: false,</span><br><span class="line"></span><br><span class="line">                //&quot;sScrollX&quot;: &quot;100%&quot;,</span><br><span class="line">                //&quot;sScrollXInner&quot;: &quot;120%&quot;,</span><br><span class="line">                //&quot;bScrollCollapse&quot;: true,</span><br><span class="line">                //Note: if you are applying horizontal scrolling (sScrollX) on a &quot;.table-bordered&quot;</span><br><span class="line">                //you may want to wrap the table inside a &quot;div.dataTables_borderWrap&quot; element</span><br><span class="line"></span><br><span class="line">                //&quot;iDisplayLength&quot;: 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                select: &#123;</span><br><span class="line">                    style: &#x27;multi&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            $.fn.dataTable.Buttons.defaults.dom.container.className = &#x27;dt-buttons btn-overlap btn-group btn-overlap&#x27;;</span><br><span class="line"></span><br><span class="line">            new $.fn.dataTable.Buttons(myTable, &#123;</span><br><span class="line">                buttons: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;colvis&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-search bigger-110 blue&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Show/hide columns&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;,</span><br><span class="line">                        columns: &#x27;:not(:first):not(:last)&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;copy&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-copy bigger-110 pink&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Copy to clipboard&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;csv&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-database bigger-110 orange&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Export to CSV&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;excel&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-file-excel-o bigger-110 green&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Export to Excel&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;pdf&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-file-pdf-o bigger-110 red&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Export to PDF&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;extend&quot;: &quot;print&quot;,</span><br><span class="line">                        &quot;text&quot;: &quot;&lt;i class=&#x27;fa fa-print bigger-110 grey&#x27;&gt;&lt;/i&gt; &lt;span class=&#x27;hidden&#x27;&gt;Print&lt;/span&gt;&quot;,</span><br><span class="line">                        &quot;className&quot;: &quot;btn btn-white btn-primary btn-bold&quot;,</span><br><span class="line">                        autoPrint: false,</span><br><span class="line">                        message: &#x27;This print was produced using the Print button for DataTables&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;);</span><br><span class="line">            myTable.buttons().container().appendTo($(&#x27;.tableTools-container&#x27;));</span><br><span class="line"></span><br><span class="line">            //style the message box</span><br><span class="line">            var defaultCopyAction = myTable.button(1).action();</span><br><span class="line">            myTable.button(1).action(function (e, dt, button, config) &#123;</span><br><span class="line">                defaultCopyAction(e, dt, button, config);</span><br><span class="line">                $(&#x27;.dt-button-info&#x27;).addClass(&#x27;gritter-item-wrapper gritter-info gritter-center white&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var defaultColvisAction = myTable.button(0).action();</span><br><span class="line">            myTable.button(0).action(function (e, dt, button, config) &#123;</span><br><span class="line"></span><br><span class="line">                defaultColvisAction(e, dt, button, config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if ($(&#x27;.dt-button-collection &gt; .dropdown-menu&#x27;).length == 0) &#123;</span><br><span class="line">                    $(&#x27;.dt-button-collection&#x27;)</span><br><span class="line">                            .wrapInner(&#x27;&lt;ul class=&quot;dropdown-menu dropdown-light dropdown-caret dropdown-caret&quot; /&gt;&#x27;)</span><br><span class="line">                            .find(&#x27;a&#x27;).attr(&#x27;href&#x27;, &#x27;#&#x27;).wrap(&quot;&lt;li /&gt;&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                $(&#x27;.dt-button-collection&#x27;).appendTo(&#x27;.tableTools-container .dt-buttons&#x27;)</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ////</span><br><span class="line"></span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                $($(&#x27;.tableTools-container&#x27;)).find(&#x27;a.dt-button&#x27;).each(function () &#123;</span><br><span class="line">                    var div = $(this).find(&#x27; &gt; div&#x27;).first();</span><br><span class="line">                    if (div.length == 1) div.tooltip(&#123;container: &#x27;body&#x27;, title: div.parent().text()&#125;);</span><br><span class="line">                    else $(this).tooltip(&#123;container: &#x27;body&#x27;, title: $(this).text()&#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;, 500);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            myTable.on(&#x27;select&#x27;, function (e, dt, type, index) &#123;</span><br><span class="line">                if (type === &#x27;row&#x27;) &#123;</span><br><span class="line">                    $(myTable.row(index).node()).find(&#x27;input:checkbox&#x27;).prop(&#x27;checked&#x27;, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            myTable.on(&#x27;deselect&#x27;, function (e, dt, type, index) &#123;</span><br><span class="line">                if (type === &#x27;row&#x27;) &#123;</span><br><span class="line">                    $(myTable.row(index).node()).find(&#x27;input:checkbox&#x27;).prop(&#x27;checked&#x27;, false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /////////////////////////////////</span><br><span class="line">            //table checkboxes</span><br><span class="line">            $(&#x27;th input[type=checkbox], td input[type=checkbox]&#x27;).prop(&#x27;checked&#x27;, false);</span><br><span class="line"></span><br><span class="line">            //select/deselect all rows according to table header checkbox</span><br><span class="line">            $(&#x27;#dynamic-table &gt; thead &gt; tr &gt; th input[type=checkbox], #dynamic-table_wrapper input[type=checkbox]&#x27;).eq(0).on(&#x27;click&#x27;, function () &#123;</span><br><span class="line">                var th_checked = this.checked;//checkbox inside &quot;TH&quot; table header</span><br><span class="line"></span><br><span class="line">                $(&#x27;#dynamic-table&#x27;).find(&#x27;tbody &gt; tr&#x27;).each(function () &#123;</span><br><span class="line">                    var row = this;</span><br><span class="line">                    if (th_checked) myTable.row(row).select();</span><br><span class="line">                    else  myTable.row(row).deselect();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            //select/deselect a row when the checkbox is checked/unchecked</span><br><span class="line">            $(&#x27;#dynamic-table&#x27;).on(&#x27;click&#x27;, &#x27;td input[type=checkbox]&#x27;, function () &#123;</span><br><span class="line">                var row = $(this).closest(&#x27;tr&#x27;).get(0);</span><br><span class="line">                if (this.checked) myTable.row(row).deselect();</span><br><span class="line">                else myTable.row(row).select();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            $(document).on(&#x27;click&#x27;, &#x27;#dynamic-table .dropdown-toggle&#x27;, function (e) &#123;</span><br><span class="line">                e.stopImmediatePropagation();</span><br><span class="line">                e.stopPropagation();</span><br><span class="line">                e.preventDefault();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //And for the first simple table, which doesn&#x27;t have TableTools or dataTables</span><br><span class="line">            //select/deselect all rows according to table header checkbox</span><br><span class="line">            var active_class = &#x27;active&#x27;;</span><br><span class="line">            $(&#x27;#simple-table &gt; thead &gt; tr &gt; th input[type=checkbox]&#x27;).eq(0).on(&#x27;click&#x27;, function () &#123;</span><br><span class="line">                var th_checked = this.checked;//checkbox inside &quot;TH&quot; table header</span><br><span class="line"></span><br><span class="line">                $(this).closest(&#x27;table&#x27;).find(&#x27;tbody &gt; tr&#x27;).each(function () &#123;</span><br><span class="line">                    var row = this;</span><br><span class="line">                    if (th_checked) $(row).addClass(active_class).find(&#x27;input[type=checkbox]&#x27;).eq(0).prop(&#x27;checked&#x27;, true);</span><br><span class="line">                    else $(row).removeClass(active_class).find(&#x27;input[type=checkbox]&#x27;).eq(0).prop(&#x27;checked&#x27;, false);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            //select/deselect a row when the checkbox is checked/unchecked</span><br><span class="line">            $(&#x27;#simple-table&#x27;).on(&#x27;click&#x27;, &#x27;td input[type=checkbox]&#x27;, function () &#123;</span><br><span class="line">                var $row = $(this).closest(&#x27;tr&#x27;);</span><br><span class="line">                if ($row.is(&#x27;.detail-row &#x27;)) return;</span><br><span class="line">                if (this.checked) $row.addClass(active_class);</span><br><span class="line">                else $row.removeClass(active_class);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /********************************/</span><br><span class="line">            //add tooltip for small view action buttons in dropdown menu</span><br><span class="line">            $(&#x27;[data-rel=&quot;tooltip&quot;]&#x27;).tooltip(&#123;placement: tooltip_placement&#125;);</span><br><span class="line"></span><br><span class="line">            //tooltip placement on right or left</span><br><span class="line">            function tooltip_placement(context, source) &#123;</span><br><span class="line">                var $source = $(source);</span><br><span class="line">                var $parent = $source.closest(&#x27;table&#x27;)</span><br><span class="line">                var off1 = $parent.offset();</span><br><span class="line">                var w1 = $parent.width();</span><br><span class="line"></span><br><span class="line">                var off2 = $source.offset();</span><br><span class="line">                //var w2 = $source.width();</span><br><span class="line"></span><br><span class="line">                if (parseInt(off2.left) &lt; parseInt(off1.left) + parseInt(w1 / 2)) return &#x27;right&#x27;;</span><br><span class="line">                return &#x27;left&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /***************/</span><br><span class="line">            $(&#x27;.show-details-btn&#x27;).on(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                $(this).closest(&#x27;tr&#x27;).next().toggleClass(&#x27;open&#x27;);</span><br><span class="line">                $(this).find(ace.vars[&#x27;.icon&#x27;]).toggleClass(&#x27;fa-angle-double-down&#x27;).toggleClass(&#x27;fa-angle-double-up&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">            /***************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             //add horizontal scrollbars to a simple table</span><br><span class="line">             $(&#x27;#simple-table&#x27;).css(&#123;&#x27;width&#x27;:&#x27;2000px&#x27;, &#x27;max-width&#x27;: &#x27;none&#x27;&#125;).wrap(&#x27;&lt;div style=&quot;width: 1000px;&quot; /&gt;&#x27;).parent().ace_scroll(</span><br><span class="line">             &#123;</span><br><span class="line">               horizontal: true,</span><br><span class="line">               styleClass: &#x27;scroll-top scroll-dark scroll-visible&#x27;,//show the scrollbars on top(default is bottom)</span><br><span class="line">               size: 2000,</span><br><span class="line">               mouseWheelLock: true</span><br><span class="line">             &#125;</span><br><span class="line">             ).css(&#x27;padding-top&#x27;, &#x27;12px&#x27;);</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要就说说后面的js获取数据这一块:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var table = $(&#x27;#dynamic-table&#x27;)</span><br><span class="line">var aoColumns = []</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    contentType: &quot;application/json; charset=utf-8&quot;,</span><br><span class="line">    url: &quot;&#123;&#123; url_for(&#x27;data_table.cols&#x27;) &#125;&#125;&quot;,</span><br><span class="line">    type: &#x27;post&#x27;,</span><br><span class="line">    success: function (resp) &#123;</span><br><span class="line">        $.each(resp.columns, function (i, v) &#123;</span><br><span class="line">            table.find(&#x27;thead &gt; tr&#x27;).append(&#x27;&lt;th&gt;&#x27; + v + &#x27;&lt;/th&gt;&#x27;)</span><br><span class="line">            aoColumns.push(&#123;&quot;title&quot;: v&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        showTables(table, aoColumns)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function showTables(dom_table, cols) &#123;</span><br><span class="line"></span><br><span class="line">    //initiate dataTables plugin</span><br><span class="line">    var myTable = dom_table.DataTable(&#123;</span><br><span class="line">        bAutoWidth: false,</span><br><span class="line">        &quot;aoColumns&quot;: cols,</span><br><span class="line">        &quot;aaSorting&quot;: [],</span><br><span class="line"></span><br><span class="line">        //&quot;bProcessing&quot;: true,</span><br><span class="line">        &quot;bServerSide&quot;: true,</span><br><span class="line">        &quot;sAjaxSource&quot;: &quot;&#123;&#123; url_for(&#x27;data_table.data&#x27;) &#125;&#125;&quot;,</span><br><span class="line">        &quot;fnServerData&quot;: function (sSource, aoData, fnCallback) &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                &#x27;dataType&#x27;: &#x27;json&#x27;,</span><br><span class="line">                &#x27;type&#x27;: &#x27;POST&#x27;,</span><br><span class="line">                &#x27;url&#x27;: sSource,</span><br><span class="line">                &#x27;data&#x27;: aoData,</span><br><span class="line">                &#x27;success&#x27;: fnCallback</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        //,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个<code>ajax</code>从后端获取列的名字,然后动态插入表头元素:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table.find(&#x27;thead &gt; tr&#x27;).append(&#x27;&lt;th&gt;&#x27; + v + &#x27;&lt;/th&gt;&#x27;)</span><br></pre></td></tr></table></figure>
<p>并且生成表头<code>aoColumns</code>供后面的<code>myTable</code>初始化用,格式就是{title:col_name}的一个数组，采用后端分页，所以需要设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;bServerSide&quot;: true</span><br></pre></td></tr></table></figure>
<p>及获取数据的源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;sAjaxSource&quot;: &quot;&#123;&#123; url_for(&#x27;data_table.data&#x27;) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>然后就是前后端数据交互:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;fnServerData&quot;: function (sSource, aoData, fnCallback) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        &#x27;dataType&#x27;: &#x27;json&#x27;,</span><br><span class="line">        &#x27;type&#x27;: &#x27;POST&#x27;,</span><br><span class="line">        &#x27;url&#x27;: sSource,</span><br><span class="line">        &#x27;data&#x27;: aoData,</span><br><span class="line">        &#x27;success&#x27;: fnCallback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样就完成了一个简单的前后端交互表格的服务器端分页的例子,访问<a href="http://127.0.0.1:5000/data_table">http://127.0.0.1:5000/data_table</a>完成后的效果如下:</p>
<p><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/DataTables%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B01.jpg" alt="DataTables样例效果"></p>
<h3 id="DataTables一些配置解释"><a href="#DataTables一些配置解释" class="headerlink" title="DataTables一些配置解释"></a>DataTables一些配置解释</h3><p>这里又一份非常详细的参数说明，不太清楚的可以先看看这个,这个是别人总结的，可以参考一下这些参数的含义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&#x27;#dataTable_ID1&#x27;).dataTable(&#123;</span><br><span class="line">    //&quot;aaSorting&quot; : [[1, &quot;asc&quot;]], //默认的排序方式，第1+1列，升序排列</span><br><span class="line">    &quot;aLengthMenu&quot; : [5, 10, 25, 50, 100], //更改显示记录数选项(默认：[10,25,50,100])</span><br><span class="line">    &quot;bAutoWidth&quot; : false, // 禁用自适应宽度(默认：true)</span><br><span class="line">    //&quot;bDeferRender&quot;:false,//推迟创建表元素每个元素,直到它们都创建完成(默认：false)</span><br><span class="line">    &quot;bDestroy&quot; : true,//重新初始化表格，未匹配到表格则新建 (默认：false)</span><br><span class="line">    &quot;bFilter&quot; : false,// 不适用搜索框过滤(默认：true)</span><br><span class="line">    //&quot;bInfo&quot; : true, //显示页脚信息，左下角显示记录数(默认：true)</span><br><span class="line">    //&quot;bJQueryUI&quot; : false, //不使用使用 jQury的UI theme(默认：false)</span><br><span class="line">    &quot;bLengthChange&quot; : true,//显示每页几条数据的显示框(默认：true)</span><br><span class="line">    //&quot;bPaginate&quot; : true, //显示(应用)分页器，不开启全显示(默认：true)</span><br><span class="line">    &quot;bProcessing&quot; : true,//加载进度提示(默认：false)</span><br><span class="line">    //&quot;bScrollInfinite&quot; : true, //启动初始化滚动条(默认：false)</span><br><span class="line">    //&quot;bRetrieve&quot;:false,//使用指定的选择器检索表格，注意，如果表格已经被初始化，该参数会直接返回已经被创建的对象，并不会顾及你传递进来的初始化参数对象的变化，将该参数设置为true说明你确认已经明白这一点，如果你需要的话，bDestroy可以用来重新初始化表格(默认：false)</span><br><span class="line">    &quot;bServerSide&quot; : true,//启动服务器端数据导入(默认：false)</span><br><span class="line">    &quot;bSort&quot; : true,//启用字段可排序(默认：true) TODO:单个列排序可禁用</span><br><span class="line">    //&quot;bStateSave&quot; : true,//开启状态缓存，如分页信息，展示长度，开启后在ajax刷新纪录的时候不会将个性化设定重置为初始化状态，如: 会导致默认的aaSorting设置失效(默认：false)</span><br><span class="line">    //&quot;bScrollCollapse&quot; : true, //开启高度自适应，当数据条数不够分页数据条数的时候，插件高度随数据条数而改变</span><br><span class="line">    //&quot;bScrollAutoCss&quot;:true,//指明滚动的标题元素是否被允许设置内边距和外边距等(默认：true)</span><br><span class="line">    //&quot;bScrollCollapse&quot;:false,//当垂直滚动被允许的时候，不强制强制表格视图在任何时候都是给定的高度(默认：false)</span><br><span class="line">    //&quot;bSortCellsTop&quot;:false,//允许使用底部的单元格，true为顶部(默认：false)</span><br><span class="line">    //&quot;iCookieDuration&quot;:7200,//cookie储存时长(单位:s)(默认：7200)</span><br><span class="line">    //&quot;iDeferLoading&quot;:null,//延时加载(type：int)(默认：null)</span><br><span class="line">    //&quot;iDisplayLength&quot;:10,//每页显示几条数据(默认：10)</span><br><span class="line">    //&quot;iDisplayStart&quot;:0,//当前页开始的记录序号(默认：0)</span><br><span class="line">    //&quot;iScrollLoadGap&quot;:100,//当前页面还有多少条数据可供滚动时自动加载新的数据(默认：100)</span><br><span class="line">    &quot;sDom&quot;: &#x27;&lt;&quot;top&quot;l&gt;rt&lt;&quot;bottom_left&quot;i&gt;&lt;&quot;bottom_right&quot;p&gt;&lt;&quot;clear&quot;&gt;&#x27;,//布局定义</span><br><span class="line">        //格式指定：包括分页，显示多少条数据和搜索等</span><br><span class="line">        //The following options are allowed:</span><br><span class="line">        //    &#x27;l&#x27; - 左上角按个下拉框，10个，20个，50个，所有的哪个</span><br><span class="line">        //    &#x27;f&#x27; - 快速过滤框</span><br><span class="line">        //    &#x27;t&#x27; - 表格本身</span><br><span class="line">        //    &#x27;i&#x27; - 分页信息</span><br><span class="line">        //    &#x27;p&#x27; - 分页按钮</span><br><span class="line">        //    &#x27;r&#x27; - 现在正在加载中……</span><br><span class="line">        //The following constants are allowed:</span><br><span class="line">        //    &#x27;H&#x27; - jQueryUI theme &quot;header&quot; classes (&#x27;fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix&#x27;)</span><br><span class="line">        //    &#x27;F&#x27; - jQueryUI theme &quot;footer&quot; classes (&#x27;fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix&#x27;)</span><br><span class="line">        //The following syntax is expected:</span><br><span class="line">        //    &#x27;&lt;&#x27; and &#x27;&gt;&#x27; - div 元素</span><br><span class="line">        //    &#x27;&lt;&quot;class&quot; and &#x27;&gt;&#x27; - 给div加clasa</span><br><span class="line">        //    &#x27;&lt;&quot;#id&quot; and &#x27;&gt;&#x27; - 给div加上id</span><br><span class="line">        //Examples:</span><br><span class="line">        //    &#x27;&lt;&quot;wrapper&quot;flipt&gt;&#x27;</span><br><span class="line">        //    &#x27;&lt;lf&lt;t&gt;ip&gt;&#x27;</span><br><span class="line">        //例子：</span><br><span class="line">        //&#x27;&lt;&quot;top&quot;i&gt;rt&lt;&quot;bottom&quot;flp&gt;&lt;&quot;clear&quot;&gt;&#x27;</span><br><span class="line">        //解析结果：</span><br><span class="line">        //    &lt;div class=&quot;top&quot;&gt;</span><br><span class="line">        //    i</span><br><span class="line">        //    &lt;/div&gt;</span><br><span class="line">        //    rt</span><br><span class="line">        //    &lt;div class=&quot;bottom&quot;&gt;</span><br><span class="line">        //    flp</span><br><span class="line">        //    &lt;/div&gt;</span><br><span class="line">        //    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &quot;sPaginationType&quot; : &quot;full_numbers&quot;,//全页数显示 || &quot;two_button&quot;：显示两个按钮(默认：two_button)</span><br><span class="line">    &quot;sAjaxSource&quot; : mediaHost+&#x27;/wxUsers/getDataTable1&#x27;,</span><br><span class="line">    //&quot;sAjaxDataProp&quot; : &quot;aaDataName&quot;,//指定返回的数据对象名称(默认：aaData)</span><br><span class="line">    //&quot;sScrollX&quot; : 720, //DataTables的宽，可以是css设置，或者一个数字(单位:px)，大于则开启水平滚动(默认:&quot;blank string - i.e. disabled&quot;)</span><br><span class="line">    //&quot;sScrollY&quot; : 480, //DataTables的高，可以是css设置，或者一个数字(单位:px)，大于则开启垂直滚动(默认:&quot;blank string - i.e. disabled&quot;)</span><br><span class="line">    //&quot;sCookiePrefix&quot; : &quot;SpryMedia_DataTables_&quot;,//指定cookie前缀(默认：&quot;SpryMedia_DataTables_&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //初始化过滤状态</span><br><span class="line">    //&quot;oSearch&quot;:&#123;</span><br><span class="line">    //    &quot;sSearch&quot;:&quot;value&quot;,</span><br><span class="line">    //    &quot;bRegex&quot;:false, //value不当成正则式</span><br><span class="line">    //    &quot;bSmart&quot;:true //灵活匹配策略</span><br><span class="line">    //&#125;,</span><br><span class="line"></span><br><span class="line">    //数据表列值</span><br><span class="line">    &quot;aoColumns&quot; : [ &#123;</span><br><span class="line">        &quot;mDataProp&quot; : &quot;data_properties0&quot;,</span><br><span class="line">        &quot;sClass&quot; : &quot;center&quot;,</span><br><span class="line">        &quot;bSortable&quot; : false</span><br><span class="line">        //&quot;sDefaultContent&quot;:&quot;&quot;,//此列默认值为&quot;&quot;，防数据无值报错</span><br><span class="line">        //&quot;bVisible&quot; : false //不显示此列</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            &quot;mDataProp&quot; : &quot;data_properties1&quot;,</span><br><span class="line">            &quot;sClass&quot; : &quot;center&quot;,</span><br><span class="line">            &quot;bSortable&quot; : false</span><br><span class="line">        &#125;,  &#123;</span><br><span class="line">            &quot;mDataProp&quot; : &quot;data_properties2&quot;,</span><br><span class="line">            &quot;sClass&quot; : &quot;center&quot;,</span><br><span class="line">            &quot;bSortable&quot; : false</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            &quot;mDataProp&quot; : &quot;data_properties2&quot;,</span><br><span class="line">            &quot;sClass&quot; : &quot;center&quot;,</span><br><span class="line">            &quot;bSortable&quot; : false</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    //国际化配置</span><br><span class="line">    &quot;oLanguage&quot; : &#123;</span><br><span class="line">        &quot;sProcessing&quot; : &quot;正在加载数据，请稍后...&quot;,</span><br><span class="line">        &quot;sLengthMenu&quot; : &quot;每页显示 _MENU_ 条记录&quot;,</span><br><span class="line">        &quot;sZeroRecords&quot; : &quot;没有数据！&quot;,</span><br><span class="line">        &quot;sEmptyTable&quot; : &quot;表中无数据存在！&quot;,</span><br><span class="line">        &quot;sInfo&quot; : &quot;当前显示 _START_ 到 _END_ 条，共 _TOTAL_ 条记录&quot;,</span><br><span class="line">        &quot;sInfoEmpty&quot; : &quot;显示0到0条记录&quot;,</span><br><span class="line">        &quot;sInfoFiltered&quot; : &quot;数据表中共有 _MAX_ 条记录&quot;,</span><br><span class="line">        //&quot;sInfoPostFix&quot;: &quot;&quot;,</span><br><span class="line">        //&quot;sSearch&quot;: &quot;搜索:&quot;,</span><br><span class="line">        //&quot;sUrl&quot;: &quot;&quot;,</span><br><span class="line">        //&quot;sLoadingRecords&quot;: &quot;载入中...&quot;,</span><br><span class="line">        //&quot;sInfoThousands&quot;: &quot;,&quot;,</span><br><span class="line">        &quot;oPaginate&quot; : &#123;</span><br><span class="line">            &quot;sFirst&quot; : &quot;首页&quot;,</span><br><span class="line">            &quot;sPrevious&quot; : &quot;上一页&quot;,</span><br><span class="line">            &quot;sNext&quot; : &quot;下一页&quot;,</span><br><span class="line">            &quot;sLast&quot; : &quot;末页&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //&quot;oAria&quot;: &#123;</span><br><span class="line">        //    &quot;sSortAscending&quot;: &quot;: 以升序排列此列&quot;,</span><br><span class="line">        //    &quot;sSortDescending&quot;: &quot;: 以降序排列此列&quot;</span><br><span class="line">        //&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param nRow 当前行内容</span><br><span class="line">     * @param aaData 当前数据对象</span><br><span class="line">     * @param iDisplayIndex 当前行索引，从0开始</span><br><span class="line">     * @param iDisplayIndexOfAadata 当前对象所在对象数组的索引，从0开始</span><br><span class="line">     * @returns &#123;*&#125;</span><br><span class="line">     */</span><br><span class="line">    &quot;fnRowCallback&quot; : function(nRow, aaData, iDisplayIndex, iDisplayIndexOfAadata) &#123;</span><br><span class="line"></span><br><span class="line">        //修改第一列为多选框内容</span><br><span class="line">        var firstTDHtml = &#x27;&lt;label&gt;firstTDHtml&lt;/label&gt;&#x27;;</span><br><span class="line">        $(&#x27;td:eq(0)&#x27;, nRow).html(firstTDHtml);</span><br><span class="line"></span><br><span class="line">        //修改第二列为序号</span><br><span class="line">        var secondTDHtml = iDisplayIndex+1;</span><br><span class="line">        $(&#x27;td:eq(1)&#x27;, nRow).html(secondTDHtml);</span><br><span class="line"></span><br><span class="line">        return nRow;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;fnDrawCallback&quot; : function(oSettings) &#123;</span><br><span class="line">        // jAlert( &#x27;DataTables 重绘了&#x27; );</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;fnFooterCallback&quot; : function(nFoot, aData, iStart, iEnd, aiDisplay) &#123;</span><br><span class="line">        // jAlert(&quot;FooterCallback&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Datatables</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 笔记01</title>
    <url>/2015/12/31/Django-%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<p>记录一下关于学习<code>Django</code>的一些细节，主要还是网上的一些教程实在是太坑了，可能是早期的版本，所以各种报错，所以最后都是参考了官方的原版教程，以及结合着其他博客慢慢折腾出来的，这里我会尽量把作为一个新手的常用问题记录下来。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote>
</blockquote>
<p>OS:Ubuntu 14.04 64bits<br>Python: 2.7.6<br>Django:1.10.dev20151230230702</p>
<h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><p>方法很多，只讲我的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/dev</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/django/django.git</span><br><span class="line">sudo pip install -e django/</span><br></pre></td></tr></table></figure>
<p>**注意:**如果没有装<code>pip</code>，可以直接在终端里装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure>
<p>最终目录结构看起来就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure>
<p>关于这些文件的用途，大概介绍一下，开始不必过多纠结这个，后面用到了会详细讲：</p>
<ol>
<li>外层的<code>mysite/</code>是工程的根目录，这个名字对于<code>Django</code>来说无所谓，你可以随便改个名字。</li>
<li><code>manage.py</code>:管家，启动服务器，数据库之类的都需要通过这个来完成。</li>
<li><code>mysite/__init__.py</code>：这个空的文件只是为了标示这个文件夹是个<code>Python</code>包。</li>
<li><code>mysite/settings.py</code>:整个工程的配置文件。</li>
<li><code>mysite/urls.py</code>:整个<code>Django</code>工程<code>url</code>映射。</li>
<li><code>mysite/wsgi.py</code>:一个供调试用的小型web服务器，类似Apache，tomcat。</li>
</ol>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>在外层的<code>mysite</code>目录下，在终端中执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>此时就可以在控制台看到成功启动服务器的信息，浏览器访问<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a>，能访问看到对应的欢迎信息则说明成功了。<br>再多说一点，如果不指定端口和IP，则默认的就是<code>127.0.0.1</code>和<code>8000</code>.着意味着你只能是在本地访问这个网址，如果要局域网里其他的机器可以访问你的这个网址，你需要像下面这样启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
<p>这样服务器会监听所有的公共IP地址，你可以通过局域网其他IP地址访问这台机器的ip地址加端口号来访问对应的网址。</p>
<h3 id="创建一个应用"><a href="#创建一个应用" class="headerlink" title="创建一个应用"></a>创建一个应用</h3><p>首先看看应用和工程有什么区别？我们可以这样理解，一个应用就是完成了一些功能的一个Web程序，一个工程就是由很多应用，或者说模块组成的，各个应用完成自己的功能，组成了功能强大的工程，下面我们来创建一个应用，还是到最外层的<code>mysite</code>下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure>
<p>刚刚创建的<code>polls</code>文件夹的目录就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">polls|master⚡ ⇒ tree</span><br><span class="line">.</span><br><span class="line">├── admin.py</span><br><span class="line">├── apps.py</span><br><span class="line">├── __init__.py</span><br><span class="line">├── migrations</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── models.py</span><br><span class="line">├── tests.py</span><br><span class="line">├── urls.py</span><br><span class="line">├── views.py</span><br></pre></td></tr></table></figure>
<p>来写我们的第一个视图，编辑<code>polls/views.py</code>文件，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, world. You&#x27;re at the polls index.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个是一个最简单的视图了，为了访问到这个视图，我们需要创建一个<code>URL</code>映射，编辑<code>polls/urls.py</code>文件，最终文件看上去像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^$&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>光这样还不行，这个只是把访问这个应用时，内部如何处理映射了，但是最外层如何访问到这个内层应用，还需要在<code>mysite</code>中配置一个<code>URL</code>映射,修改<code>mysite/urls.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> include, url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^polls/&#x27;</span>, include(<span class="string">&#x27;polls.urls&#x27;</span>)),</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>记得要导入<code>include</code>模块。<br>**注意:**什么时候需要使用<code>include</code>模块？当你的URL匹配中包含另外的URL匹配映射时，你需要用<code>include()</code>,对于我们的例子，当在处理<code>127.0.0.1:8000/polls/</code>这个链接时，需要用到<code>polls/urls.py</code>里面的映射，所以我们要用<code>include()</code>将其他的匹配规则包含进来。<br>一切都完成了之后，我们来启动工程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>同样，浏览器访问<a href="http://127.0.0.1:8000/polls/">http://127.0.0.1:8000/polls/</a>,如果看到输出了：</p>
<blockquote>
<p>Hello, world. You’re at the polls index.</p>
</blockquote>
<p>则说明我们的第一个应用完成了。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 笔记03</title>
    <url>/2016/01/03/Django-%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<p>上一篇文章讲了数据库如何存储在数据库中，以及模块如何显示在网页中，利用管理模块添加管理模块。现在我们来做一个简单的投票网站，大概有以下几个页面：</p>
<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><ol>
<li><code>index</code>Page:展示最近最新的问题</li>
<li><code>detail</code>Page:展示一个问题的具体描述</li>
<li><code>results</code>Page:展示具体的结果</li>
<li><code>vote</code>Page:具体投票的界面</li>
</ol>
<h3 id="增加几个视图"><a href="#增加几个视图" class="headerlink" title="增加几个视图"></a>增加几个视图</h3><p>编辑<code>polls.views.py</code>文件，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;You&#x27;re looking at question %s.&quot;</span> % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">results</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    response = <span class="string">&quot;You&#x27;re looking at the result of question %s.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vote</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;You&#x27;re voting on question %s.&quot;</span> % question_id)</span><br></pre></td></tr></table></figure>
<p>增加了视图，还要把视图的<code>url</code>写到<code>polls.urls</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^$&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/</span></span><br><span class="line">    url(<span class="string">r&#x27;(?P&lt;question_id&gt;[0-9]+)/$&#x27;</span>, views.detail, name=<span class="string">&#x27;detail&#x27;</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/results/</span></span><br><span class="line">    url(<span class="string">r&#x27;(?P&lt;question_id&gt;[0-9]+)/results/$&#x27;</span>, views.results, name=<span class="string">&#x27;results&#x27;</span>),</span><br><span class="line">    <span class="comment"># ex:/polls/5/vote/</span></span><br><span class="line">    url(<span class="string">r&#x27;(?P&lt;question_id&gt;[0-9]+)/vote/$&#x27;</span>, views.vote, name=<span class="string">&#x27;vote&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>分别访问<a href="http://127.0.0.1:8000/polls/3/">&#x2F;pools&#x2F;3&#x2F;</a>,<a href="http://127.0.0.1:8000/polls/3/results/">polls&#x2F;3&#x2F;results&#x2F;</a>,<a href="http://127.0.0.1:8000/polls/3/vote/">polls&#x2F;3&#x2F;vote&#x2F;</a>会分别调用这几个模块视图,返回对应的结果.<br>稍微解释一下这个访问过程:当有个人访问<a href="http://127.0.0.1:8000/polls/3/">127.0.0.1:8000&#x2F;polls&#x2F;3&#x2F;</a>这个链接的时候,Django会加载<code>mysite.urls</code>这个模块,因为这个文件是项目的根配置链接模块,然后在这个模块里找到了对应的匹配项<code>^polls/</code>,然后把<code>3/</code>根据<code>include()</code>函数找到对应的模块的<code>urls</code>配置文件<code>polls.urls</code>,最终调用对应的视图<code>r&#39;^P&lt;question_id&gt;[0-9]+)/$</code>.调用视图的参数传递像下面这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">detail(request=&lt;HttpRequest <span class="built_in">object</span>&gt;, question_id=<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>question_id=&#39;34&#39;</code>是从正则表达式<code>(?P&lt;question_id&gt;[0-9]+)</code>中来的,这个就是正则表达式里的一种用法,用括号括起来可以捕获正则匹配到的值,并且把他们作为参数传递给视图函数.其中<code>?P&lt;question_id&gt;</code>定义了这个匹配到的值的使用名,<code>[0-9]+</code>意思是匹配任意数字1次或者多次.</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>上面的是一个简单的示例,其实这个视图根本没做什么事情,一般一个视图会做两件事:返回一个<code>HttpResponse</code>包含请求页面的内容,或者返回一个异常,例如<code>Http404</code>,这个取决于你.<br>为了让视图有内容,我们从数据库里读数据,将这些数据展示在网页上,例如显示最近的5条记录,修改<code>polls/views.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&#x27;-pub_date&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line">    output = <span class="string">&#x27;, &#x27;</span>.join([q.quetion_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure>
<p>这里又有一个问题了,一般的网页设计都是写死的,如果你想改变网页的展示方式,你就要取改对应的Python代码,所以Django采用了设计和数据分离的模板模式,下面讲一讲如何使用模板来展示数据.</p>
<h3 id="网页模板"><a href="#网页模板" class="headerlink" title="网页模板"></a>网页模板</h3><p>首先在<code>polls</code>目录下创建一个<code>templates</code>目录,Django会到这个目录里找模板.在<code>mysite/settings.py</code>文件里,有如下内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>看到<code>&#39;APP_DIRS&#39;: True</code>,这个会在我们刚创建的<code>templates</code>目录下扫描你已经安装的<code>APP</code>的目录里的模板.以我们这个例子为例,我们创建的模板的相对路径为:<code>polls/templates/polls/index.html</code>.当你使用的时候,直接就是<code>polls/index.html</code>.不要觉得这个麻烦,为什么要多创建一个<code>polls</code>的子目录而不是把模板文件直接放在<code>templates</code>下,这个就涉及到一个模板的查找个加载,Django默认从<code>templates</code>下查找,如果找到了就匹配第一个,所以不要省略子目录<code>polls</code>,你可以把这个看成是Java里的包的路径或者C++里的命名空间.<br>编辑<code>polls/templates/pools/index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% for question in latest_question_list %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/polls/&#123;&#123; question.id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; question.question_text&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新视图文件<code>polls/views.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&#x27;-pub_date&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line">    template = loader.get_template(<span class="string">&#x27;polls/index.html&#x27;</span>)</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;latest_question_list&#x27;</span>: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure>
<p>这段代码加载了一个模板<code>polls/index.html</code>,并且给模板传递了一个上下文,这是个字典.启动服务器,访问对应的网址<code>127.0.0.1:8000/polls/</code>默认会调用<code>index()</code>视图函数,返回一个列表,就是数据库里查询出来的几条记录.<br><code>Django</code>对于这种常用的模板操作,也提供了一个简便的用法,我们来重写一下<code>index()</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&#x27;-pub_date&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;latest_question_list&#x27;</span>: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;polls/index.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure>
<p>**render()**函数接收三个参数,第一个是一个<code>request</code>对象,第二个是一个模板,第三个是一个可选参数,字典内容.它返回一个渲染过的模板过后的<code>HttpResponse</code>对象以及字典内容</p>
<h3 id="返回404错误"><a href="#返回404错误" class="headerlink" title="返回404错误"></a>返回404错误</h3><p>现在我们来处理一下详情<code>detail()</code>函数,编辑<code>polls/views.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoseNotExists:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">&quot;Question does not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;polls/detail.html&#x27;</span>, &#123;<span class="string">&#x27;question&#x27;</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在<code>polls/detail.html</code>中添加简单的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123; question &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>同理,调用对应的方法,如果数据有,则会调用模板,没有则会跑出异常.</p>
<h3 id="get-object-or-404"><a href="#get-object-or-404" class="headerlink" title="get_object_or_404()"></a>get_object_or_404()</h3><p>由于我们经常使用这个用法,即有就获取内容,没有就抛出异常,所以Django也有一个简单的用法,重写<code>detail()</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;polls/detail.html&#x27;</span>, &#123;<span class="string">&#x27;question&#x27;</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<p>这个会自动捕获<code>object doesn&#39;t exist</code>这个异常,还有个类似的方法<code>get_list_or_404()</code>,在列表是空的时候会抛异常.</p>
<h3 id="使用模板系统"><a href="#使用模板系统" class="headerlink" title="使用模板系统"></a>使用模板系统</h3><p>编辑模板文件夹下的<code>polls/detail.html</code>文件:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>移除模板里的硬编码,让模板可以动态的显示内容,编辑<code>polls/index.html</code>:<br>把如下的内容:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先说一下为什么要这么改,上面一种写法为什么不好,其实可以想象,如果连接都写死,一旦我们的模板多起来了,改链接会很麻烦.其实有个简单的方法,在前面<code>urls.py</code>里,我们在写正则匹配url的时候,还定义了模板的名字,所以你可以使用<code>{% url %}</code>这个模板标签,这个是根据下面的定义来的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># the &#x27;name&#x27; value as called by the &#123;% url %&#125; template tag</span></span><br><span class="line">url(<span class="string">r&#x27;^(?P&lt;question_id&gt;[0-9]+)/$&#x27;</span>, views.detail, name=<span class="string">&#x27;detail&#x27;</span>),</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样当你改了外部访问链接,例如<code>127.0.0.1:8000/polls/specifics/12/</code>,你只用在<code>polls/url.py</code>里改对应的正则规则就行,模板里的代码不用改.</p>
<h3 id="URL命名空间"><a href="#URL命名空间" class="headerlink" title="URL命名空间"></a>URL命名空间</h3><p>虽然上面的方法可以让我们少改代码,但是试想一下,一个真正的工程不可能只有一个<code>APP</code>模块,Django怎么知道在找到多个的时候用那个,答案是命名空间,是的,就是C++里的那个命名空间,我们来修改<code>polls/urls.py</code>文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app_name = <span class="string">&#x27;polls&#x27;</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">	......</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>然后修改<code>polls/index.html</code>文件,将</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;polls:detail&#x27; question.id %&#125;&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果这样直接运行,然后访问<code>127.0.0.1:8000/polls/</code>会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u&#x27;polls&#x27; is not a registered namespace</span><br></pre></td></tr></table></figure>
<p>解决办法是在project的<code>urls.py</code>中<code>include()</code>的时候加上<code>namespace</code>属性,编辑<code>mysite/urls.py</code>文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^polls/&#x27;</span>, include(<span class="string">&#x27;polls.urls&#x27;</span>, namespace=<span class="string">&#x27;polls&#x27;</span>)),</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后就可以访问了.</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 笔记04</title>
    <url>/2016/01/07/Django-%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<p>通过第三篇笔记我们也基本知道怎么处理Web的视图和数据库及链接和模板,这次主要讲一讲表单,因为Web免不了要提交数据给服务器,表单作为一种非常常见和基本的提交数据的方式,在Web开发中是很重要的一种方法.</p>
<h3 id="一个简单的表单"><a href="#一个简单的表单" class="headerlink" title="一个简单的表单"></a>一个简单的表单</h3><p>更新我们的模板文件,编辑<code>polls/detail.html</code>,改成如下内容:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% if error_message %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; error_message &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>&lt;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;% url &#x27;polls:vote&#x27; question.id %&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;choice&quot;</span> <span class="attr">id</span>=<span class="string">&quot;choice&#123;&#123;forloop.counter&#125;&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; choice.id&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;choice&#123;&#123;forloop.counter&#125;&#125;&quot;</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    &lt;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Vote&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面的是一个简单的单选按钮的模板，每一个投票选项是一个单选按钮，然后这个单选按钮的值就是关联的问题选项的<code>id</code>。每个单选按钮的名字都一样，是<code>choice</code>，也就是如果你选了某个选项，那么POST的数据就是<code>choice=#id</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^(?P&lt;question_id&gt;[0-9]+)/vote/$&#x27;</span>, views.vote, name=<span class="string">&#x27;vote&#x27;</span>),</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forloop.counter</strong>暗示了有多少个选项，其实就是外层循环次数。</p>
</li>
<li><p><code> {% csrf_token %} </code>是个防止跨域攻击的标签，只需要知道这么用就行了。</p>
</li>
</ul>
<p>这回我们可以来完善一下我们的<code>vote</code>视图，让它有一些功能，编辑<code>polls/views.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, get_object_or_404</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question, Choice</span><br><span class="line"><span class="comment"># 省略其他视图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vote</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        select_choice = question.choice_set.get(pk=request.POST[<span class="string">&#x27;choice&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class="line">        <span class="comment"># 重新展示问题的投票按钮</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;polls/detail.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;question&#x27;</span>: question,</span><br><span class="line">            <span class="string">&#x27;error_message&#x27;</span>: <span class="string">&quot;You didn&#x27;t select a choice.&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        select_choice.votes += <span class="number">1</span></span><br><span class="line">        select_choice.save()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 投票成功之后要重定向到一个结果网页</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">&#x27;polls:results&#x27;</span>, args=(question.<span class="built_in">id</span>,)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有一些代码需要解释一下，好多前面并没有介绍过：</p>
<ul>
<li><strong>request.POST</strong>就像一个字典一样，你可以通过key来访问表单提交的数据，<code>request.POST[&#39;choice&#39;]</code>返回的是选项的<code>id</code>，不过返回的是个字符串形式，因为它返回的始终是字符串形式。</li>
<li>**request.POST[‘choice’]**会抛出一个<code>KeyError</code>当这个值没有提供的时候，这里我们的处理是没提供就返回到提交投票的表单并且给出一个信息提示。</li>
<li>当投票成功之后，代码中返回了一个<code>HttpResponseRedirect</code>而不是普通的<code>HttpResponse</code>,这个函数还可以带参数，可以重定向到我们想访问的网址,建议当我们成功处理的一个POST请求的时候都可以这么做。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/polls/3/results/</span><br></pre></td></tr></table></figure>
这个3就是参数中带的<code>question.id</code>的值。<br>当某个人对这个问题投票的时候，<code>vote()</code>视图将会重定向到结果页面，还需要增加一个<code>results()</code>视图，编辑<code>polls/views.py</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">results</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;polls/results.html&#x27;</span>, &#123;<span class="string">&#x27;question&#x27;</span>: question&#125;)</span><br></pre></td></tr></table></figure>
这个和之前的<code>detail()</code>视图非常相似，用到了<code>results.html</code>模板，新建<code>template/polls/results.html</code>文件:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote &#123;&#123; choice.votes | pluralize &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &lt;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;polls:detail&#x27; question.id %&#125;&quot;</span>&gt;</span>Vote again?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
此时如果你直接运行，访问<code>polls/1/</code>这个链接里面是空的，因为你的数据库里没有<code>Choice</code>,你可以直接在命令行中运行插入，或者一个简单的，直接按照前面讲的，把<code>choice</code>模块注册到<code>admin</code>模块中管理，就可以在网页上直接操作了，加入注册模块也很简单，修改<code>polls/admin.py</code>文件，内容如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question, Choice</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br><span class="line">admin.site.register(Choice)</span><br></pre></td></tr></table></figure>
然后就去管理员后台直接添加几个选项和问题吧。添加完毕然后再访问，就会出现一个问题和对应的投票选项，就像我们做选择题一样，一个题有几个选项。假设我们什么都不选，然后点提交。会得到一个错误信息，就显示在选项上面<strong>You didn’t select a choice.</strong></li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask Blueprint笔记</title>
    <url>/2016/08/07/Flask-Blueprint%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近开始用Flask做一个报表系统，为了方便组织代码，网上了解了一下<code>Flask Blueprint</code>这个东西，算是一个入门，新手容易碰到的问题。<br>关于蓝图的介绍网上也很多了，我也不多讲，主要是上代码，然后有常见的问题</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  script git:(3a429f0) tree -L 4</span><br><span class="line">.</span><br><span class="line">├── my_site</span><br><span class="line">│   ├── app1</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   │   └── index.html</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   ├── app2</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   │   └── index.html</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   ├── app3</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   │   └── index.html</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── README.md</span><br><span class="line">└── run.py</span><br></pre></td></tr></table></figure>
<p>项目的目录结构如上面所示，项目根目录为<code>scirpt</code>,真正的项目为<code>my_site</code>目录,<code>app1</code>,<code>app2</code>,<code>app3</code>为三个不同的应用，对应为3个不同模块.<br><code>env</code>文件夹为<code>virtualenv</code>虚拟<code>python</code>环境安装目录.</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装虚拟Python环境，这个不多说，网上教程一堆，因为我用的Pycharm IDE,所以在Pycharm里面设置成我的安装环境就行。具体方法:<code>File--&gt;Settings--&gt;Project--&gt;Project Interpreter</code>,选你安装虚拟环境的地址即可。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>一般自己写着玩或者写个小网站，就几个访问URL，都写在一个<code>views.py</code>里面当然没啥问题，但是项目大了，越来越复杂的话，肯定不可能都写在一个文件里面，极难维护，所以一般会按功能分成不同模块，下面以<code>app1</code>模块为例讲解一下:</p>
<ul>
<li><code>my_site/app1/views.py</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from flask import Blueprint, render_template</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">app1 = Blueprint(&#x27;app1&#x27;, __name__, template_folder=&#x27;templates&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app1.route(&#x27;/index&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    print &#x27;访问app1&#x27;</span><br><span class="line">    return render_template(&#x27;index.html&#x27;)</span><br></pre></td></tr></table></figure>
<p>这就相当于完成了一个模块了，模块里访问的<code>index.html</code>模板文件为:</p>
<ul>
<li><code>my_site/app1/templates/index.html</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;应用1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    测试1</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>完成了模块之后还需要注册模块.</p>
<ul>
<li><code>my_site/__init__.py</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">app = Flask(__name__, instance_relative_config=True)</span><br><span class="line"></span><br><span class="line">app.config.from_object(&#x27;config&#x27;)</span><br><span class="line"></span><br><span class="line">from my_site.app1.views import app1</span><br><span class="line">from my_site.app2.views import app2</span><br><span class="line">from my_site.app3.views import app3</span><br><span class="line"></span><br><span class="line">app.register_blueprint(app1, url_prefix=&#x27;/app1&#x27;)</span><br><span class="line">app.register_blueprint(app2, url_prefix=&#x27;/app2&#x27;)</span><br><span class="line">app.register_blueprint(app3, url_prefix=&#x27;/app3&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里注册了三个模块，为了演示，有三个模块，内容就不多虽说了，<code>views.py</code>的内容都是一样的，但是<code>index.html</code>稍作区分，以标志我们访问的是哪一个页面.</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>然后在项目的根目录下创建一个<code>run.py</code>文件作为主启动文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from my_site import app</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;localhost&#x27;, debug=True)</span><br><span class="line"></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>然后直接用IDE运行<code>run.py</code>文件就行。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>然后通过浏览器访问<code>http://localhost:5000/app1/index.html</code>，结果返回的值为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试3</span><br></pre></td></tr></table></figure>
<p>问题有点儿奇怪，通过设置断点,请求确实进入了<code>app1/views.py</code>文件，但是返回的却是<code>app3/index.html</code>的内容，上网查了一下，发现这个问题好像还挺常见的，官方也没把这个问题定义成bug,这个就涉及到<code>Flask</code>的<code>render_template()</code>函数在查找模板的时候是如何处理模板的了，默认是在项目的目录下查找<code>template</code>文件夹,如果没找到，就去模块下找，最后会把所有模块下找到的模板文件的路径加到一个字典文件里面，因为字典是无序的，所以具体会返回哪个页面得看字典的<code>hash</code>算法了,核心模块代码如下:</p>
<ul>
<li><code>python2.7/site-packages/flask/templating.py</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_source(self, environment, template):</span><br><span class="line">    if self.app.config[&#x27;EXPLAIN_TEMPLATE_LOADING&#x27;]:</span><br><span class="line">        return self._get_source_explained(environment, template)</span><br><span class="line">    return self._get_source_fast(environment, template)</span><br><span class="line"></span><br><span class="line">def render_template(template_name_or_list, **context):</span><br><span class="line">    &quot;&quot;&quot;Renders a template from the template folder with the given</span><br><span class="line">    context.</span><br><span class="line"></span><br><span class="line">    :param template_name_or_list: the name of the template to be</span><br><span class="line">                                  rendered, or an iterable with template names</span><br><span class="line">                                  the first one existing will be rendered</span><br><span class="line">    :param context: the variables that should be available in the</span><br><span class="line">                    context of the template.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ctx = _app_ctx_stack.top</span><br><span class="line">    ctx.app.update_template_context(context)</span><br><span class="line">    return _render(ctx.app.jinja_env.get_or_select_template(template_name_or_list),</span><br><span class="line">                   context, ctx.app)</span><br></pre></td></tr></table></figure>

<p>针对这个情况，有两种解决办法:</p>
<ul>
<li>官方解决方案:</li>
</ul>
<p>在每个模块的<code>template</code>文件夹下面的模板文件不要重名，怎么做呢？很简单，就是以模块名再建一个文件夹，把所有的模板文件放到这个文件夹下面，最后的结构可能就变成了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── config.py</span><br><span class="line">└─── my_site</span><br><span class="line">    ├── app1</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── templates</span><br><span class="line">    │   │   └── app1</span><br><span class="line">    │   │       └── index.html</span><br><span class="line">    │   └── views.py</span><br><span class="line">    └── app2</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── templates</span><br><span class="line">        │   └── app2</span><br><span class="line">        │       └── index.html</span><br><span class="line">        └── views.py</span><br></pre></td></tr></table></figure>
<p>所以对应的<code>views.py</code>文件中需要改成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return render_template(&#x27;app1/index.html&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第三方解决方案</li>
</ul>
<p>既然已经知道问题出在处理模板的文件<code>templating.py</code>文件中，所以在对应额地方加上处理逻辑即可，github上的一位道友给出的解决方案,修改<code>python2.7/site-packages/flask/templating.py</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def render_template(template_name_or_list, **context):</span><br><span class="line">    &quot;&quot;&quot;Renders a template from the template folder with the given</span><br><span class="line">    context.</span><br><span class="line">    :param template_name_or_list: the name of the template to be</span><br><span class="line">                                  rendered, or an iterable with template names</span><br><span class="line">                                  the first one existing will be rendered</span><br><span class="line">    :param context: the variables that should be available in the</span><br><span class="line">                    context of the template.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ctx = _app_ctx_stack.top</span><br><span class="line">    ctx.app.update_template_context(context)</span><br><span class="line"></span><br><span class="line">    template = None</span><br><span class="line"></span><br><span class="line">    if _request_ctx_stack.top is not None and \</span><br><span class="line">            _request_ctx_stack.top.request.blueprint is not None and \</span><br><span class="line">            isinstance(template_name_or_list, string_types):</span><br><span class="line">        bp = ctx.app.blueprints[_request_ctx_stack.top.request.blueprint]</span><br><span class="line">        if bp.jinja_loader is not None:</span><br><span class="line">            try:</span><br><span class="line">                template = bp.jinja_loader.load(ctx.app.jinja_env,</span><br><span class="line">                                                template_name_or_list,</span><br><span class="line">                                                ctx.app.jinja_env.globals)</span><br><span class="line">            except TemplateNotFound:</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">    if template is None:</span><br><span class="line">        template = ctx.app.jinja_env\</span><br><span class="line">            .get_or_select_template(template_name_or_list)</span><br><span class="line"></span><br><span class="line">    return _render(template, context, ctx.app)</span><br></pre></td></tr></table></figure>
<p>然后再访问就可以了。<br>**注意:**两种方式都可以，但是推荐使用第一种官方的方案，因为如果改源码，虽然可以正常运行，但是换个环境，或者项目重新给别人部署，如果不加说明，不知道的人不会去改<code>Flask</code>代码,那么这个项目则会出错。</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title>Error creating beans and Injection of autowired dependencies failed</title>
    <url>/2017/04/06/Error-creating-beans-and-Injection-of-autowired-dependencies-failed/</url>
    <content><![CDATA[<p>Spring中需要用到spring的事务回滚,注解方式是最简单易用的，一开始发现spring的事务没有起作用，最后查了很多资料,最后发现是配置文件中没有添加事务注解的配置,所以在spring的配置文件里面加了下面这行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>结果发现之前可以运行的项目突然不能运行了,涉及到事务注解的service全部无法注入</p>
<p>一般出现这个问题都会去网上查查是不是自己用的注入方式不对,有一些人还建议使用<code>@Resource</code>注解替换<code>@Autowried</code>,我试过时候发现还是不行．后来网上查了一下，其实很多人这么说都是人云亦云，很多人都不知道为什么，就知道<code>@Resource</code>是java自带的注解，所以比<code>@Autowried</code>靠谱,真的是这样吗?其实这个通过查资料就很容易知道并不是这样的:</p>
<ul>
<li>@Autowire</li>
</ul>
<p>默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，可以设置它required属性为false，如果我们想使用按照名称装配，可 以结合@Qualifier注解一起使用;</p>
<ul>
<li>@Resource</li>
</ul>
<p>默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，如果没有指定name属 性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找 依赖对象.</p>
<p>所以说,正常情况下你可以理解为没啥区别,如果非要说后者比前者的优势,那就是减少外部依赖,因为<code>@Autowried</code>是spring提供的.</p>
<p>但是我还是照着网上说的,既然注入失败,那肯定是bean的名字还有类型找不到,所以我尝试强制指定<code>Service</code>的名字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service(&quot;serviceName&quot;)</span><br></pre></td></tr></table></figure>
<p>然后在<code>Controller</code>里面注入的时候使用<code>@Resource</code>注解指定名字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Resource(name = &quot;serviceName&quot;)</span><br></pre></td></tr></table></figure>
<p>结果奇迹出现了,还是报错,不过这个错误和之前不一样了,关键信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">but was actually of type [com.sun.proxy.$Proxy17</span><br></pre></td></tr></table></figure>
<p>这句话什么意思呢?意思是bean的名字是找到了，但是这个类型不符合,所以注入依然失败,总而言之就是我们要注入的<code>Service</code>的类型变成了<code>com.sun.proxy.$Proxy17</code>这个类型了,这是个啥类型？然后我网上查了很久,最后终于在stackoverflow上找到了答案,原来很多人都碰到了这个问题,原帖地址</p>
<blockquote>
</blockquote>
<p><a href="http://stackoverflow.com/questions/841231/fixing-beannotofrequiredtypeexception-on-spring-proxy-cast-on-a-non-singleton-be">http://stackoverflow.com/questions/841231/fixing-beannotofrequiredtypeexception-on-spring-proxy-cast-on-a-non-singleton-be</a></p>
<p>摘一段Spring官方的文档:</p>
<blockquote>
</blockquote>
<p>Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If “proxy-target-class” attribute is set to “true”, then class-based proxies will be created. If “proxy-target-class” is “false” or if the attribute is omitted, then standard JDK interface-based proxies will be created. (See the section entitled Section 6.6, “Proxying mechanisms” for a detailed examination of the different proxy types.)</p>
<p>大概翻译一下就是:是否只采用代理模式来做事务管理,并且有个关键字<code>class-based proxies</code>,这样就不会有类型不匹配的了.<br>而且这个作者的这个问题也是由于他使用的事务注解而导致的,和我的这个问题非常相像，核心意思是这个注解默认是使用系统的代理模式,即<code>com.sun.proxy</code>这个里面的类,但是一般<code>spring</code>的项目都是使用的<code>cglib,aspectj</code>这类的库来做代理的默认实现,所以导致了以上的这种问题,那么解决方法就是将最开始的配置改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 学习笔记 02</title>
    <url>/2016/04/30/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</url>
    <content><![CDATA[<p>从简单的例子学习Flask,因为是简单的例子，就用子单的<code>sqlite3</code>数据库了，如果项目大了，数据量大可以考虑使用<code>MySQL</code>。</p>
<h3 id="项目步骤"><a href="#项目步骤" class="headerlink" title="项目步骤"></a>项目步骤</h3><p>一步步来演示一个项目是如何创建的</p>
<ul>
<li>先创建文件夹<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  flasker  tree</span><br><span class="line">.</span><br><span class="line">├── static</span><br><span class="line">└── templates</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据库模式，将下面的内容保存在schema-sql，放在flasker目录下就行"><a href="#数据库模式，将下面的内容保存在schema-sql，放在flasker目录下就行" class="headerlink" title="数据库模式，将下面的内容保存在schema.sql，放在flasker目录下就行:"></a>数据库模式，将下面的内容保存在<code>schema.sql</code>，放在<code>flasker</code>目录下就行:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists entries;</span><br><span class="line">create table entries (</span><br><span class="line">  id integer primary key autoincrement,</span><br><span class="line">  title text not null,</span><br><span class="line">  text text not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="应用构建"><a href="#应用构建" class="headerlink" title="应用构建"></a>应用构建</h4><p>创建应用模块，吧模块命名为<code>flaskr.py</code>,就放在flaskr文件夹中，为了方便学习，把库的导入和相关配置放在了一起，但是一个清晰的方案应该是放在一个独立的<code>__init__.py</code>文件中，然后在模块里导入配置，不过这个也有一个不好的地方，就是你在主文件里不知道的包到底是从哪导入的,flaskr.py内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># all the imports</span><br><span class="line">import sqlite3</span><br><span class="line">from flask import Flask, request, session, g, redirect, url_for, \</span><br><span class="line">     abort, render_template, flash</span><br><span class="line"></span><br><span class="line"># configuration</span><br><span class="line">DATABASE = &#x27;/tmp/r.db&#x27;</span><br><span class="line">DEBUG = True</span><br><span class="line">SECRET_KEY = &#x27;development key&#x27;</span><br><span class="line">USERNAME = &#x27;admin&#x27;</span><br><span class="line">PASSWORD = &#x27;default&#x27;</span><br></pre></td></tr></table></figure>
<p>然后在同一个文件中创建真正的应用，使用配置来初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># create our little application :)</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(__name__)</span><br></pre></td></tr></table></figure>
<p><code>from_object</code>的传入参数如果是字符串则直接导入，它会搜索加载多有大写的变量名，就是我们写在最前面的，你也可以把这个写在<code>__init__.py</code>文件中。一般都是总配置文件导入配置的，建议使用<code>from_envvar()</code>来导入配置，上面的第二行可以替换为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.config.from_envvar(&#x27;FLASKR_SETTINGS&#x27;, silent=True)</span><br></pre></td></tr></table></figure>
<p>这个可以设置一个<code>FLASKR_SETTINGS</code>变量来指定一个配置文件，并根据该文件来重载缺省配置，<code>silent</code>意思是如果没有，则不报错。<br>然后添加一个用于连接数据库的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def connect_db():</span><br><span class="line">    return sqlite3.connect(app.config[&#x27;DATABASE&#x27;])</span><br></pre></td></tr></table></figure>
<p>然后在最后以单机模式启动的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>这样虽然可以启动服务器，但是无法访问界面，因为没有构建任何视图。</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>每次去执行命令导入不是很方便，受限于系统，所以添加一个数据库初始化函数，首先要导入<code>contextlib.closing()</code>函数,即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from contextlib import closing</span><br></pre></td></tr></table></figure>
<p>然后创建一个初始数据库的函数<code>init_db()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def init_db():</span><br><span class="line">    with closing(connect_db()) as db:</span><br><span class="line">        with app.open_resource(&#x27;schema.sql&#x27;, mode=&#x27;r&#x27;) as f:</span><br><span class="line">            db.cursor().executescript(f.read())</span><br><span class="line">        db.commit()</span><br></pre></td></tr></table></figure>
<p><code>closing()</code>函数允许我们在with代码块中保持数据库打开，然后<code>open_resouce()</code>也支持这个功能，直接在with代码块中使用，<code>sqlite3</code>里面的sql都必须显示的提交才会生效。</p>
<h4 id="请求数据库连接"><a href="#请求数据库连接" class="headerlink" title="请求数据库连接"></a>请求数据库连接</h4><p>当然你可以生成一个全局的数据库连接句柄，这样在每个函数里面就可以使用数据库连接了，但是并不推荐这样，会带来很多问题，也不够优雅。Flask里面利用装饰器能够做到优雅的访问数据库，<code>before_request()</code>,<code>after_request()</code>,<code>teardown_request()</code>这三个装饰器就可以满足需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.before_request</span><br><span class="line">def before_request():</span><br><span class="line">    g.db = connect_db()</span><br><span class="line"></span><br><span class="line">@app.teardown_request</span><br><span class="line">def teardown_request(exception):</span><br><span class="line">    db = getattr(g, &#x27;db&#x27;, None)</span><br><span class="line">    if db is not None:</span><br><span class="line">        db.close()</span><br><span class="line">    g.db.close()</span><br></pre></td></tr></table></figure>
<p>来看看这段代码是如何的优雅，使用<code>before_request()</code>装饰函数会在请求之前调用，不用传递任何参数，这样在每个视图函数里面都可以通过全局<code>g</code>对象获取数据库连接句柄。使用<code>after_request()</code>会在请求之后调用，并且会传递相应对象给客户端，所以出错了就不会执行。因此需要用到第三个装饰器<code>teardown_request()</code>装饰器，这个装饰器会在响应对象构建完之后才调用被装饰的函数，不允许修改请求，而且返回值也会被忽略，如果出错了，这个错误会传递给每个函数。这里的<code>g</code>对象简单理解就是一个神奇的全局对象，并且多线程也可以正常工作。</p>
<h4 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h4><p>在数据库连接处理完之后，就可以来构造视图了，下面简单介绍一个例子：</p>
<h5 id="显示条目"><a href="#显示条目" class="headerlink" title="显示条目"></a>显示条目</h5><p>这个视图将会显示所有数据库中的连接，模板为<code>show_entries.html</code>,并返回渲染结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def show_entries():</span><br><span class="line">    cur = g.db.execute(&#x27;select title, text from entries order by id desc&#x27;)</span><br><span class="line">    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]</span><br><span class="line">    return render_template(&#x27;show_entries.html&#x27;, entries=entries)</span><br></pre></td></tr></table></figure>
<h4 id="添加条目"><a href="#添加条目" class="headerlink" title="添加条目"></a>添加条目</h4><p>添加一条新记录，添加完之后并不会显示，结果显示在<code>show_entries</code>页面中，如果成功，则会flash()一个消息给下一个请求并重定向到<code>show_entries</code>页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/add&#x27;, methods=[&#x27;POST&#x27;])</span><br><span class="line">def add_entry():</span><br><span class="line">    if not session.get(&#x27;logged_in&#x27;):</span><br><span class="line">        abort(401)</span><br><span class="line">    g.db.execute(&#x27;insert into entries (title, text) values (?, ?)&#x27;,</span><br><span class="line">                 [request.form[&#x27;title&#x27;], request.form[&#x27;text&#x27;]])</span><br><span class="line">    g.db.commit()</span><br><span class="line">    flash(&#x27;New entry was successfully posted&#x27;)</span><br><span class="line">    return redirect(url_for(&#x27;show_entries&#x27;))</span><br></pre></td></tr></table></figure>
<p>这里还有个检查是否登陆的，就是<code>logged_in</code>是否为<code>True</code>。另外一个，为了防止SQL注入，劲量不要拼sql,用<code>?</code>代替。</p>
<h4 id="登陆和注销"><a href="#登陆和注销" class="headerlink" title="登陆和注销"></a>登陆和注销</h4><p>用于登陆和注销，根据配置中的用户名和密码验证用户会话中设置<code>logged_in</code>的键值。如果通过验证，则设置<code>logged_in</code>为True,然后重定向到<code>show_entries</code>页面。另外闪现一个信息，告诉用户已登陆成功，如果出错，则提示错误信息，并重新登陆:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def login():</span><br><span class="line">    error = None</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        if request.form[&#x27;username&#x27;] != app.config[&#x27;USERNAME&#x27;]:</span><br><span class="line">            error = &#x27;Invalid username&#x27;</span><br><span class="line">        elif request.form[&#x27;password&#x27;] != app.config[&#x27;PASSWORD&#x27;]:</span><br><span class="line">            error = &#x27;Invalid password&#x27;</span><br><span class="line">        else:</span><br><span class="line">            session[&#x27;logged_in&#x27;] = True</span><br><span class="line">            flash(&#x27;You were logged in&#x27;)</span><br><span class="line">            return redirect(url_for(&#x27;show_entries&#x27;))</span><br><span class="line">    return render_template(&#x27;login.html&#x27;, error=error)</span><br></pre></td></tr></table></figure>
<p>注销视图则会相反，移除键值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/logout&#x27;)</span><br><span class="line">def logout():</span><br><span class="line">    session.pop(&#x27;logged_in&#x27;, None)</span><br><span class="line">    flash(&#x27;You were logged out&#x27;)</span><br><span class="line">    return redirect(url_for(&#x27;show_entries&#x27;))</span><br></pre></td></tr></table></figure>
<p>使用<code>pop()</code>函数如果传递了第二个参数(键的缺省值),如果有的话就会删掉，如果没有，就啥也不做。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>光有视图还不够，上面用到的模板还没有写好，访问也会报错，然后还用到了模板继承保存所有页面布局统一，这些文件都保存在<code>templates</code>文件夹中:</p>
<h4 id="layout-html"><a href="#layout-html" class="headerlink" title="layout.html"></a>layout.html</h4><p>这个模板包含了HTML的骨架，头部和一个登陆链接(如果用户已登陆则变为一个注销连接)。如果有闪现消息，则也显示出来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block body %&#125;</span><br></pre></td></tr></table></figure>
<p>上面的块儿会被子模块中同名的body替换。而且session在模板中也可以使用，如果键值(属性)不存在也可以正常运行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Flaskr<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">stylesheet</span> <span class="attr">type</span>=<span class="string">text/css</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Flaskr<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">metanav</span>&gt;</span></span><br><span class="line">  &#123;% if not session.logged_in %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;login&#x27;) &#125;&#125;&quot;</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;logout&#x27;) &#125;&#125;&quot;</span>&gt;</span>log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">flash</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">  &#123;% block body %&#125;&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="show-entries-html"><a href="#show-entries-html" class="headerlink" title="show_entries.html"></a>show_entries.html</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;layout.html&quot; %&#125;</span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">  &#123;% if session.logged_in %&#125;</span><br><span class="line">    &lt;form action=&quot;&#123;&#123; url_for(&#x27;add_entry&#x27;) &#125;&#125;&quot; method=post class=add-entry&gt;</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;Title:</span><br><span class="line">        &lt;dd&gt;&lt;input type=text size=30 name=title&gt;</span><br><span class="line">        &lt;dt&gt;Text:</span><br><span class="line">        &lt;dd&gt;&lt;textarea name=text rows=5 cols=40&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;dd&gt;&lt;input type=submit value=Share&gt;</span><br><span class="line">      &lt;/dl&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;ul class=entries&gt;</span><br><span class="line">  &#123;% for entry in entries %&#125;</span><br><span class="line">    &lt;li&gt;&lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;&#123;&#123; entry.text|safe &#125;&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &lt;li&gt;&lt;em&gt;Unbelievable.  No entries here so far&lt;/em&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>我们在第一行使用了<code>layout.html</code>模板，扩展了基础模板，用于显示信息。for遍历了我们通过<code>render_template()</code>函数所有传递信息。模板也指明了method为post提交数据。</p>
<h4 id="login-html"><a href="#login-html" class="headerlink" title="login.html"></a>login.html</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;layout.html&quot; %&#125;</span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">  &lt;h2&gt;Login&lt;/h2&gt;</span><br><span class="line">  &#123;% if error %&#125;&lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt; &#123;&#123; error &#125;&#125;&#123;% endif %&#125;</span><br><span class="line">  &lt;form action=&quot;&#123;&#123; url_for(&#x27;login&#x27;) &#125;&#125;&quot; method=post&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;Username:</span><br><span class="line">      &lt;dd&gt;&lt;input type=text name=username&gt;</span><br><span class="line">      &lt;dt&gt;Password:</span><br><span class="line">      &lt;dd&gt;&lt;input type=password name=password&gt;</span><br><span class="line">      &lt;dd&gt;&lt;input type=submit value=Login&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加样式"><a href="#添加样式" class="headerlink" title="添加样式"></a>添加样式</h3><p>现在数据库连接有了，视图也有了，然后模板也有了，最后就差样式了，我们来添加一下样式，保存为<code>style.css</code>保存在<code>static</code>文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body            &#123; font-family: sans-serif; background: #eee; &#125;</span><br><span class="line">a, h1, h2       &#123; color: #377ba8; &#125;</span><br><span class="line">h1, h2          &#123; font-family: &#x27;Georgia&#x27;, serif; margin: 0; &#125;</span><br><span class="line">h1              &#123; border-bottom: 2px solid #eee; &#125;</span><br><span class="line">h2              &#123; font-size: 1.2em; &#125;</span><br><span class="line"></span><br><span class="line">.page           &#123; margin: 2em auto; width: 35em; border: 5px solid #ccc;</span><br><span class="line">                  padding: 0.8em; background: white; &#125;</span><br><span class="line">.entries        &#123; list-style: none; margin: 0; padding: 0; &#125;</span><br><span class="line">.entries li     &#123; margin: 0.8em 1.2em; &#125;</span><br><span class="line">.entries li h2  &#123; margin-left: -1em; &#125;</span><br><span class="line">.add-entry      &#123; font-size: 0.9em; border-bottom: 1px solid #ccc; &#125;</span><br><span class="line">.add-entry dl   &#123; font-weight: bold; &#125;</span><br><span class="line">.metanav        &#123; text-align: right; font-size: 0.8em; padding: 0.3em;</span><br><span class="line">                  margin-bottom: 1em; background: #fafafa; &#125;</span><br><span class="line">.flash          &#123; background: #cee5F5; padding: 0.5em;</span><br><span class="line">                  border: 1px solid #aacbe2; &#125;</span><br><span class="line">.error          &#123; background: #f0d6d6; padding: 0.5em; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试Flask"><a href="#测试Flask" class="headerlink" title="测试Flask"></a>测试Flask</h3><p>这个必须介绍一下，因为写代码的过程中免不了要调试和测试，现在讲一下怎么用<code>unittest</code>包来测试flask应用</p>
<h4 id="测试骨架"><a href="#测试骨架" class="headerlink" title="测试骨架"></a>测试骨架</h4><p>为了测试我们的应用，我们添加一个新的模块<code>flaskr_tests.py</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import flaskr</span><br><span class="line">import unittest</span><br><span class="line">import tempfile</span><br><span class="line"></span><br><span class="line">class FlaskrTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.db_fd, flaskr.app.config[&#x27;DATABASE&#x27;] = tempfile.mkstemp()</span><br><span class="line">        flaskr.app.config[&#x27;TESTING&#x27;] = True</span><br><span class="line">        self.app = flaskr.app.test_client()</span><br><span class="line">        flaskr.init_db()</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        os.close(self.db_fd)</span><br><span class="line">        os.unlink(flaskr.app.config[&#x27;DATABASE&#x27;])</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>稍微介绍一下这个测试是个啥意思:</p>
<ol>
<li><code>setUp()</code>方法中会创建一个新的测试客户端并出书画了一个连接，每一个独立的测试函数运行之前都要调用这个函数</li>
<li><code>tearDown()</code>功能是在测试结束以后关闭文件，并在文件中删除数据库库文件，另外<code>TESTING=True</code>,这意味着在请求时关闭错误捕捉，这样可以真实的捕捉到错误，得到更好的错误报告。</li>
</ol>
<p>测试客户端会提供一个简单的应用接口，我们通过这个接口向应用发送测试请求，还可以追踪cookies。<br>因为<code>sqlite3</code>是一个文件系统数据库，所以可以使用临时文件来创建一个临时数据库并初始化它。<code>mkstemp()</code>函数返回两个东西:一个低级别的文件句柄和一个随机文件名,这个文件名将会作为我们的数据库名称。必须把句柄保存到<code>self.db_fd</code>种，这样在整个测试类里面才能在其他方法中来关闭文件。<br>可以在终端中运行测试程序，如果没有报错，才说明没有语法错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(env)➜  flasker  python flaskr_tests.py </span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 0 tests in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="第一个测试"><a href="#第一个测试" class="headerlink" title="第一个测试"></a>第一个测试</h4><p>Web应用就是测试一些URL访问是否正常，添加一个访问URL(&#x2F;)的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FlaskrTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.db_fd, flaskr.app.config[&#x27;DATABASE&#x27;] = tempfile.mkstemp()</span><br><span class="line">        self.app = flaskr.app.test_client()</span><br><span class="line">        flaskr.init_db()</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        os.close(self.db_fd)</span><br><span class="line">        os.unlink(flaskr.app.config[&#x27;DATABASE&#x27;])</span><br><span class="line"></span><br><span class="line">    def test_empty_db(self):</span><br><span class="line">        rv = self.app.get(&#x27;/&#x27;)</span><br><span class="line">        assert &#x27;No entries here so far&#x27; in rv.data</span><br></pre></td></tr></table></figure>
<p><strong>注意:<strong>测试的函数都是以<code>test</code>开始的，这样<code>unittest</code>就会自动识别这些用于测试的函数并运行它们。通过使用<code>self.app.get()</code>可以给制定的URL发送</strong>HTTP GET</strong>请求，其返回的是一个<code>～flask.Flask.reponse_class</code>对象，通过检查其data属性来检测其返回值</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 笔记02</title>
    <url>/2016/01/03/Django-%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<p>上一篇文章简单的搭建了一个<code>Django</code>的应用,互联网的应用，最后的数据都必须存储在数据库里，所以一个Web应用不可能不用到数据库，今天简单介绍一下<code>Django</code>中如何使用和配置数据库。</p>
<h3 id="数据库设置"><a href="#数据库设置" class="headerlink" title="数据库设置"></a>数据库设置</h3><p>打开配置文件<code>mysite/settings.py</code>,默认这个配置文件是使用的<code>SQLite</code>数据库，如果只是简单的学些这个框架，做一些简单的应用，这个数据库很方便，是Python内置的，你不用再安装任何其他的驱动，包之类的。当然，如果你想使用更牛逼的数据库，例如<code>MySQL</code>，<code>PostgreSQL</code>，看配置文件的下面的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Database</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/dev/ref/settings/#databases</span></span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ENGINE</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line">&#x27;django.db.backends.postgresql&#x27;,</span><br><span class="line">&#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">&#x27;django.db.backends.oracle&#x27;,</span><br></pre></td></tr></table></figure>
<p><strong>NAME</strong>:你所创建的数据库文件的地址，记得是绝对路径，默认的是<code>os.path.join(BASE_DIR,&#39;db.sqlite3&#39;)</code>。<br>如果使用的是其他的数据库，还需要数据库的用户名和密码，记得一定要安装对应的驱动，例如，使用<code>MySQL</code>要安装类似于<code>python-mysqldb</code>这样的驱动，配置文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;test&#x27;</span>,    	<span class="comment">#你的数据库名称</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,   	<span class="comment">#你的数据库用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;&#x27;</span>, 	<span class="comment">#你的数据库密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;&#x27;</span>, 		<span class="comment">#你的数据库主机，留空默认为localhost</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>, 	<span class="comment">#你的数据库端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于只是练手，简单的就是用默认配置了，在使用数据库之前，需要创建表，在终端里执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>这个命令其实是会根据<code>mysite/settings.py</code>里安装的模块创建对应的表，如果某些模块需要使用数据库，它就会创建对应的表，这么看实在是强大又方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Application definition</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>看看执行命令的输出确实是这样的,有四个模块使用了数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, contenttypes, auth, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Rendering model states... DONE</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  Applying auth.0001_initial... OK</span><br><span class="line">  Applying admin.0001_initial... OK</span><br><span class="line">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class="line">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class="line">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure>

<h3 id="实体类设计"><a href="#实体类设计" class="headerlink" title="实体类设计"></a>实体类设计</h3><p>在我们之前创建的一个应用里，我们来创建两个实体类：<code>Question</code>和<code>Choice</code>,每个<code>Choice</code>都关联着一个<code>Question</code>。编辑<code>polls/models.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">    quetion = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>**NOTE:**每个实体类有两个字段属性，注意<code>Choice</code>里的<code>question</code>不是字段，只是定义一个外键。</p>
<h3 id="激活模块"><a href="#激活模块" class="headerlink" title="激活模块"></a>激活模块</h3><p>现在我们已经创建了模块，剩下的我们要告诉我们的工程，<code>polls</code>这个应用要被安装，就是上面我们提到的配置文件，修改<code>mysite/settings.py</code>，改为以下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;polls.apps.PollsConfig&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后在终端里运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure>
<p>将会看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Migrations for &#x27;polls&#x27;:</span><br><span class="line">  polls/migrations/0001_initial.py:</span><br><span class="line">    - Create model Choice</span><br><span class="line">    - Create model Question</span><br><span class="line">    - Add field quetion to choice</span><br></pre></td></tr></table></figure>
<p>运行上面的命令的意思就是说，你已经修改了你的实体类，然后想把这些改动存储到数据库里。关于这个命令目前不需要知道太详细，知道这样用就可以了，但这样还不够，还需要运行下面的命令来把这些操作生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>看到如下输出就说明成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, contenttypes, polls, auth, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Rendering model states... DONE</span><br><span class="line">  Applying polls.0001_initial... OK</span><br></pre></td></tr></table></figure>
<p>上面的命令是把改变写到数据库中，使之生效，如果不运行这个，会报错，找不到表。</p>
<h3 id="使用API交互调试"><a href="#使用API交互调试" class="headerlink" title="使用API交互调试"></a>使用API交互调试</h3><p>上回忘了说，<code>manage.py</code>有很多命令，其中有一个是交互式调试工具<code>manage.py shell</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: django.setup()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">from</span> polls.models <span class="keyword">import</span> Question,Choice</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: Question.objects.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">4</span>]: &lt;QuerySet []&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面我们来插入一条记录，稍微多说一句，使用`timezone.now()`来替代</span></span><br><span class="line"><span class="comment"># datetime.datetime.now()</span></span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: q = Question(question_text=<span class="string">&quot;What&#x27;s new?&quot;</span>, pub_date=timezone.now())</span><br><span class="line"><span class="comment"># 把这条记录存到数据库里</span></span><br><span class="line">In [<span class="number">7</span>]: q.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存到数据库之后这条记录就有id了</span></span><br><span class="line">In [<span class="number">8</span>]: q.<span class="built_in">id</span></span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: q.question_text</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">&quot;What&#x27;s new?&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: q.pub_date</span><br><span class="line">Out[<span class="number">10</span>]: datetime.datetime(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">39966</span>, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: Question.objects.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">11</span>]: &lt;QuerySet [&lt;Question: Question <span class="built_in">object</span>&gt;]&gt;</span><br></pre></td></tr></table></figure>
<p>看最后一行，是不是觉得根本看不出什么东西？类比于<code>Java</code>里，我们知道，有些类都会自带一个<code>toString()</code>方法，可以把一个类作为一个字符串输出来，这里我们也来定义一下类的<code>toString</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">    quetion = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.choice_text</span><br></pre></td></tr></table></figure>
<p>然后你需要退出交互式Python环境，重新进一边，就可以看到变化了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: Question.objects.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">4</span>]: &lt;QuerySet [&lt;Question: What<span class="string">&#x27;s new?&gt;]&gt;</span></span><br></pre></td></tr></table></figure>
<p>再给<code>Question</code>加一个比较常用的方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.question_text</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">was_published_recently</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.pub_date &gt;= timezone.now() - datetime.timedelta(days=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用admin模块"><a href="#使用admin模块" class="headerlink" title="使用admin模块"></a>使用admin模块</h3><p>这个模块主要是管理员模块，管理网站的各种权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>
<p>后面照着填就行了。开启服务器：<code>python manage.py runserver</code>,访问<code>http://127.0.0.1:8000/admin/</code>。<br>登陆进去之后界面大概是这样的：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Django%20%E7%AC%94%E8%AE%B00201.png" alt="Django 后台管理模块"></p>
<h3 id="导入模块到后台管理"><a href="#导入模块到后台管理" class="headerlink" title="导入模块到后台管理"></a>导入模块到后台管理</h3><p>编辑<code>polls/admin.py</code>文件，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure>
<p>把模块注册到后台管理模块中之后，就可以在管理模块中操作我们的数据了，再次刷新就可以看到我们的模块了：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Django%20%E7%AC%94%E8%AE%B00202.png" alt="polls模块"><br>还可以添加管理数据：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Django%20%E7%AC%94%E8%AE%B00203.png" alt="后台管理数据库数据"><br>这些数据会根据自己的类型选择自己的展示方式，日期的会有一个日历展示框。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 循环依赖导入解决办法</title>
    <url>/2016/08/23/Flask-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%AF%BC%E5%85%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>今天在是使用Flask的<code>Flask-login</code>搭建一个系统的时候，在登陆<code>views.py</code>视图文件里面引用<code>models.py</code>实体类的时候出现了一个错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: cannot import name db</span><br></pre></td></tr></table></figure>
<p>看看项目的文件结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  financial_bi git:(dev) ✗ tree -L 3</span><br><span class="line">.</span><br><span class="line">├── config.py</span><br><span class="line">├── instances</span><br><span class="line">│   └── dev_init.sql</span><br><span class="line">├── README.md</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── run.py</span><br><span class="line">└── web</span><br><span class="line">    ├── common</span><br><span class="line">    │   └── __init__.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── security</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── models.py</span><br><span class="line">    │   ├── templates</span><br><span class="line">    │   └── views.py</span><br><span class="line">    ├── static</span><br><span class="line">    │   ├── assets</span><br><span class="line">    │   └── favicon.ico</span><br><span class="line">    └── templates</span><br><span class="line">        └── layout</span><br><span class="line"></span><br><span class="line">9 directories, 15 files</span><br></pre></td></tr></table></figure>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from web.security.views import security</span><br><span class="line"></span><br><span class="line">app = Flask(&#x27;web&#x27;, static_folder=&#x27;static&#x27;)</span><br><span class="line">app.config.from_pyfile(&#x27;../config.py&#x27;)</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_app():</span><br><span class="line">    # 注册模块</span><br><span class="line">    app.register_blueprint(security, url_prefix=&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">    configure_flask_login(app)</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure>
<p>看到这里确实有问题，我们来梳理一下这个引用关系:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Flask%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%AF%BC%E5%85%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%9501.png" alt="循环依赖图"><br>我们对照着这个图分析一下怎么产生循环依赖的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. __init__.py 先import web/security/views.py,然后声明变量db</span><br><span class="line">2. web/security/views.py依赖web/security/models.py的User实体类</span><br><span class="line">3. web/security/models.py依赖__init__.py中声明的变量db</span><br></pre></td></tr></table></figure>
<p>结果就导致了这个问题，所以我们要想解决这个问题，可以在<code>__init__.py</code>中把变量<code>db</code>的声明顺序放到<code>import web/security/views.py</code>之后，如此一来<code>__init__.py</code>的<code>db</code>变量就不会依赖其他模块了.<br>所以我们得出一个技巧，在用蓝图注册模块的时候，把引用放到工厂函数里面去，像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def create_app():</span><br><span class="line">    # 注册模块</span><br><span class="line">    from web.security.views import security</span><br><span class="line"></span><br><span class="line">    app.register_blueprint(security, url_prefix=&#x27;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就不会有循环依赖的问题了。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 恢复误删除文件</title>
    <url>/2016/07/07/Git-%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>有时候在项目里面不小心把某个文件删除了，并且代码也推送到远端了，或者我们删除了一个我们认为没啥用的文件,但是过了很长一段时间之后我们又想把这个文件找回来，当然笨一点的办法也有，就是去git的Web端找到删除那个文件的提交版本号，然后通过改动历史把那个文件内容复制，然后在本地新建那个文件，然后把内容复制过来，添加到项目中，自然这个文件也回来了，但是这个方法比较麻烦，下面介绍一下恢复一个被删掉的文件的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br><span class="line"></span><br><span class="line">* commit e4985f8fdac2b14468c0348e88180b5348417d04</span><br><span class="line">| Author: san.zhang &lt;san.zhang@gmail.com&gt;</span><br><span class="line">| Date:   Fri Dec 18 18:03:44 2015 +0800</span><br><span class="line">| </span><br><span class="line">|     xxxxx bugfix2</span><br><span class="line">|  </span><br><span class="line">* commit 5bb4f8e49f26e27991d9ab84812cd6eb5a0a3dd6</span><br><span class="line">| Author: san.zhang &lt;san.zhang@gmail.com&gt;</span><br><span class="line">| Date:   Fri Dec 18 17:27:21 2015 +0800</span><br><span class="line">| </span><br><span class="line">|     xxxxx,buggix2,删除配置文件</span><br><span class="line">|  </span><br><span class="line">* commit d835c652209ad430decdef28498d03379b06ae06</span><br><span class="line">| Author: san.zhang &lt;san.zhang@gmail.com&gt;</span><br><span class="line">| Date:   Fri Dec 18 16:44:04 2015 +0800</span><br><span class="line">| </span><br><span class="line">|     commit 1</span><br></pre></td></tr></table></figure>
<p>在<strong>commit</strong><code>5bb4f8e49f26e27991d9ab84812cd6eb5a0a3dd6</code>这次提交删错了文件,具体日志为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* commit 5bb4f8e49f26e27991d9ab84812cd6eb5a0a3dd6</span><br><span class="line">| Author: san.zhang &lt;san.zhang@gmail.com&gt;</span><br><span class="line">| Date:   Fri Dec 18 17:27:21 2015 +0800</span><br><span class="line">| </span><br><span class="line">|     xxxxx,buggix2,删除配置文件</span><br></pre></td></tr></table></figure>

<p>这次提交版本号为:<code>5bb4f8e</code>,这个commit之前的commit为<code>d835c65</code>,也就是说在<code>5bb4f8e</code>这个版本中其实是没有这个文件的，在<code>d835c65</code>这个版本中，这个文件的状态为被删之前的样子，我们只要能把文件恢复到这个版本就可以了，怎么做呢？<br>假设被删的文件叫<code>test.conf</code>,恢复<code>test.conf</code>有两个办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &quot;5bb4f8e~1&quot; test.conf</span><br><span class="line">git checkout d835c65 test.conf</span><br></pre></td></tr></table></figure>

<p>其实这两个命令是一样的，<code>5bb4f8e~1</code>就是指这个commit的上一次，同理<code>~2</code>指的是前两次</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/2015/10/08/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="初级命令"><a href="#初级命令" class="headerlink" title="初级命令"></a>初级命令</h3><h4 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h4><p>初次拉取项目也就是克隆项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  docments  git <span class="built_in">clone</span> git@repository_url/project_name.git</span><br><span class="line">Cloning into <span class="string">&#x27;project_name&#x27;</span>...</span><br><span class="line">remote: Counting objects: 14930, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (5769/5769), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14930 (delta 10903), reused 12396 (delta 9013)</span><br><span class="line">Receiving objects: 100% (14930/14930), 127.75 MiB | 11.20 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (10903/10903), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>git@repository_url/project_name.git</code>就是<code>git</code>服务器上项目的<code>ssh</code>地址<br>另外项目更新需要用到两个命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch   <span class="comment"># 拉取远端数据到本地，不和并</span></span><br><span class="line">git pull    <span class="comment"># 相当于git fetch 和 git merge</span></span><br></pre></td></tr></table></figure>

<h4 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h4><ul>
<li>新分支</li>
</ul>
<p>把项目从服务器上拉取下来之后，一般都需要建立一个自己的分支方便开发，比如新建一个本地<code>test</code>分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  data git:(master) git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果你只是想看看项目里的分支代码，不想新建一个分支，有时候拉取的分支可能包括你想要看的分支，这个时候可以按照下面来做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  data git:(master) git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/init</span><br><span class="line">  origin/master</span><br><span class="line">➜  data git:(master) git checkout -b init origin/init </span><br><span class="line">Branch init <span class="built_in">set</span> up to track remote branch init from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;init&#x27;</span></span><br></pre></td></tr></table></figure>
<p>后面的<code>origin/init</code>可以省略，默认创建本地的<code>init</code>分支上游分支为<code>origin/init</code>.<br>如果有时候建分支忘了指定本地分支和远端的哪个分支对应，需要设定分支的远端对应分支可以这样，假设我想让我的本地master分支追踪远端的master分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --track master origin/master	</span><br></pre></td></tr></table></figure>
<p>不过貌似这种方式不推荐了<br>例如远端有个Python分支,那么想让本地分支追踪远端的Python分支，可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地的Python和远端仓库origin的Python分支关联</span></span><br><span class="line">git branch --set-upstream-to=origin/Python Python</span><br></pre></td></tr></table></figure>

<ul>
<li>删除分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d -r &lt;branch_name&gt;</span><br><span class="line">git branch -D -r &lt;branch_name&gt;	# 强制删除</span><br></pre></td></tr></table></figure>

<ul>
<li>分支重命名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;new_name&gt;	# 重命名当前分支</span><br><span class="line">git branch -m &lt;old_branch&gt; &lt;new_branch&gt;	# 重命名指定分支</span><br></pre></td></tr></table></figure>

<ul>
<li>删除缓存分支</li>
</ul>
<p>有时候远端的分支已经删除了,使用<code>git branch -a</code>仍然可以看到那些被删除的分支，清除远端分支缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin --prune</span><br></pre></td></tr></table></figure>

<h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><p>添加一个新文件，<code>git</code>不会自动跟踪，需要手动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add file1 file2 file3       <span class="comment"># 把file1 file2 file3添加到git索引中</span></span><br><span class="line">git add .                       <span class="comment"># 把当前项目中的所有文件添加到git索引中，</span></span><br><span class="line">git commit -am <span class="string">&quot;add thefile&quot;</span>    <span class="comment"># 添加新文件到本地暂存区</span></span><br></pre></td></tr></table></figure>

<h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>关于<code>git push</code>使用还有很高级的用法，具体参见<a href="http://www.yiibai.com/git/git_push.html">git push 详解</a></p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>编辑项目下的<code>.gitignore</code>文件，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.txt   # 忽略所有的txt文本文件</span><br><span class="line">dir/    # 忽略项目根目录下dir文件夹里所有的文件</span><br></pre></td></tr></table></figure>

<h4 id="查看变更内容"><a href="#查看变更内容" class="headerlink" title="查看变更内容"></a>查看变更内容</h4><ul>
<li>查看某次提交的修改内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show commit_id</span><br></pre></td></tr></table></figure>

<ul>
<li>查看提交历史</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p -2 # 查看最近两次提交的历史</span><br></pre></td></tr></table></figure>

<h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">git config --global user.name yourname</span><br><span class="line">git config --global user.email emailaddress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地配置，进到具体的项目目录下</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name yourname</span><br><span class="line">git config --<span class="built_in">local</span> user.email emailaddress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定git编辑器</span></span><br><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>


<h3 id="Git错误信息汇总"><a href="#Git错误信息汇总" class="headerlink" title="Git错误信息汇总"></a>Git错误信息汇总</h3><ul>
<li>git push 出错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: The current branch master has multiple upstream branches, refusing to push.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git config remote.origin.push HEAD</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 撤销冲突，用远端代码覆盖本地</title>
    <url>/2016/07/07/Git-%E6%92%A4%E9%94%80%E5%86%B2%E7%AA%81%EF%BC%8C%E7%94%A8%E8%BF%9C%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0/</url>
    <content><![CDATA[<p>本地改了一个代码，结果忘了推送到远端，晚上下班之后又改动了代码推送到了远端，结果第二天来公司一pull代码，果断悲剧了，冲突了。其实解冲突到没什么，但是其实我是想以远端的代码为准，完全丢弃我本地的代码更改，但是此时已经位于合并分支上，也没办法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash	# 将更改的代码压栈</span><br></pre></td></tr></table></figure>
<p>如果你已经处在合并代码的分支了，不合并完代码<code>commit</code>是没办法使用压栈命令把代码还原到更改之前的，当然暴力的办法当然是直接把项目删了，重新<code>clone</code>到本地，但是这个方法显然不是很好，如果项目特别大就很慢了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  data git:(init) ✗ git revert 5d49773</span><br><span class="line">error: revert is not possible because you have unmerged files.</span><br><span class="line">提示：请在工作区改正文件，然后酌情使用 &#x27;git add/rm &lt;文件&gt;&#x27; 命令标记</span><br><span class="line">提示：解决方案并提交。</span><br><span class="line">fatal: 还原失败</span><br><span class="line">➜  data git:(init) ✗ git stash </span><br><span class="line">shell/ordercenter/order_snap/order_common_scene_snap.sh: needs merge</span><br><span class="line">shell/ordercenter/order_snap/order_common_scene_snap.sh: needs merge</span><br><span class="line">shell/ordercenter/order_snap/order_common_scene_snap.sh: unmerged (0abc52f84a64ad5d5e8157303b0b50cd095e4319)</span><br><span class="line">shell/ordercenter/order_snap/order_common_scene_snap.sh: unmerged (eb8bd3095d572d0c6bde26eec1b7de0c3359ac78)</span><br><span class="line">shell/ordercenter/order_snap/order_common_scene_snap.sh: unmerged (dce00518150b3a26f5fb04315cd7b3fedf1c2396)</span><br><span class="line">fatal: git-write-tree: error building trees</span><br><span class="line">无法保存当前索引状态</span><br></pre></td></tr></table></figure>
<p>网上查阅了一下，有个命令可以将代码还原到指定历史:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  data git:(init) ✗ git fetch --all</span><br><span class="line">正在获取 origin</span><br><span class="line">➜  data git:(init) ✗ git reset --hard origin/init</span><br><span class="line">HEAD 现在位于 612af0e update</span><br><span class="line">➜  data git:(init) git pull</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>
<p>**备注:**git fetch 只是下载远程的库的内容，不做任何的合并 git reset 把HEAD指向刚刚下载的最新的版本</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 获取远端指定分支</title>
    <url>/2015/10/08/Git-%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%AB%AF%E6%8C%87%E5%AE%9A%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>通过<code>git</code>远端仓库地址拉取项目，结果只有<code>master</code>分支，使用<code>git fetch</code>后没有用，还是没有拉取到其他的分支。</p>
<p>问题定位： 通过<code>git clone</code>获取的远端<code>git</code>库，只包含了远端<code>git</code>库的当前工作分支。如果还想获取其他的分支信息，可以按照以下步骤来。</p>
<ul>
<li>查看远端分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  data git:(master) git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/init</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取远端指定分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;本地分支&gt; &lt;远程分支&gt;</span><br></pre></td></tr></table></figure>
<p>例如我想拉取远端的<code>init</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  data git:(master) git checkout -b init origin/init </span><br><span class="line">Branch init <span class="built_in">set</span> up to track remote branch init from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;init&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看是否成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  data git:(init) <span class="built_in">ls</span>  </span><br><span class="line">build.sh  database  pay_shell  report  UDF          userprofile2</span><br><span class="line">cron      design    README.md  shell   userprofile</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 如果本地分支已经存在，则不需要<code>-b</code>参数，<code>远程分支名</code>的名字就是你<code>git branch -r</code>所列出来的，诸如<code>origin/分支名</code>。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Streaming收集日志</title>
    <url>/2016/07/18/Hadoop-Streaming%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>公司的日志一般会有专门的日志收集系统，但是上传到hdfs上目录太多，一般都是按机房，按小时分割日志文件的。路径类似于下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/user/xxx/l-xxxx1.pay.cn1/20160717/log.20160717-18.gz</span><br><span class="line">/user/xxx/l-xxxx1.pay.cn1/20160717/log.20160717-19.gz</span><br><span class="line">/user/xxx/l-xxxx2.pay.cn1/20160717/log.20160717-18.gz</span><br><span class="line">/user/xxx/l-xxxx3.pay.cn1/20160717/log.20160717-19.gz</span><br></pre></td></tr></table></figure>
<p>即日志文件会按小时打包<code>log.20160717-xx.gz</code>,另外日志可能会标注机房<code>l-xxxx[1-9].pay.cn[1-9]</code>不同机器,这样会对应很多个目录，这样就无法通过在Hive里面建一个表指向一个固定的hdfs路径来分析日志数据。我们必须通过一个方法把这些日志转化到一个路径，然后把数据<code>load</code>到Hive表中，然后就可以对日志的数据做一些分析，或者使用了。</p>
<h3 id="Hadoop-Streaming"><a href="#Hadoop-Streaming" class="headerlink" title="Hadoop Streaming"></a>Hadoop Streaming</h3><p>这里使用到的是Hadoop原生的<code>Streaming</code>，毕竟我们的目的也不是很负复杂，就是一个数据收集汇总的过程，当然这中间也可以做一些简单的处理，例如过滤掉不需要的日志，毕竟日志不比MySQL里面的结构化数据，日志的量级一般都很大，都装到Hive表里面数据量大分析的时候也需要更多的计算资源，也更慢</p>
<p>由于服务器上的<code>hadoop</code>是2.2.0版本的，所以我这里使用的是<code>hadoop-streaming-2.2.0.jar</code>。主要使用<code>shell</code>,<code>python</code>简单介绍一下如何使用这个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$HADOOP_HOME/bin/hadoop  jar $HADOOP_HOME/hadoop-streaming.jar \</span><br><span class="line">    -input myInputDirs \</span><br><span class="line">    -output myOutputDir \</span><br><span class="line">    -mapper /bin/cat \</span><br><span class="line">    -reducer /bin/wc</span><br></pre></td></tr></table></figure>
<p>上面是具体的在shell里面执行的时候参数的指定，这里最简单的用法就是执行输入目录或者输入文件，以我上面的例子为例，涉及到多个机房，日志还按小时分割打包，可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-input /user/xxx/l-xxxx*.pay.cn*/20160717/log.20160717-*.gz</span><br></pre></td></tr></table></figure>
<p>即路径可以使用通配符<code>*</code>指定,然后还要指定一个汇总日志输出路径:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-output /user/xxx/logs/xxxx/output/20160717/log_parse </span><br></pre></td></tr></table></figure>

<p>这里主要是想讲一下<code>mapper</code>和<code>reducer</code>文件的编写，采用python实现:<br>先看一下<code>mapper.py</code>文件的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">reg_pattern = r&#x27;(\d+-\d+-\d+ \d+:\d+:\d+.\d+).*GwRouteBizImpl\s*-\s*(\w*)\&#123;(.*)\&#125;.*&#x27;</span><br><span class="line">re_gx = re.compile(reg_pattern)</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    line = line.strip().replace(&#x27;\t&#x27;, &#x27; &#x27;).replace(&#x27;\r&#x27;, &#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">    if re_gx.match(line):</span><br><span class="line">        print &#x27;%s&#x27; % re.sub(reg_pattern, r&#x27;\1\t\2\t\3&#x27;, line)</span><br></pre></td></tr></table></figure>
<p>这就是一个最简单的过滤日志，并简单做一些字段的提取，因为我们采用<code>\t</code>分割，所以需要把每一行的特殊字符去掉，然后用正则匹配满足格式的日志，如果不满足，这条日志就直接过滤掉了。<br>**注意:**使用Hadoop原生的<code>Streaming</code>程序，只能处理标准输入输出,另外如果对输入不做任何处理，可以直接使用系统自带的<code>/bin/cat</code>，不用单独写<code>mapper</code>或者<code>reducer</code>，当然你也可以使用python写一个,什么也不干，原样输出<code>reducer.py</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    print &#x27;%s\t&#x27; % line</span><br></pre></td></tr></table></figure>

<p>具体使用就很简单了，在shell里面调用:</p>
<blockquote>
<p>sudo -u${HADOOP_USER} ${HADOOP_HOME}&#x2F;bin&#x2F;hadoop jar ${HADOOP_HOME}&#x2F;share&#x2F;hadoop&#x2F;tools&#x2F;lib&#x2F;hadoop-streaming-2.2.0.jar -D stream.non.zero.exit.is.failure&#x3D;false -mapper “python mapper.py” -reducer “python reducer.py” -input ${HADOOP_LOG_FILE} -output ${HADOOP_OUTPUT_DIR} -file reducer.py -file mapper.py</p>
</blockquote>
<p>**备注:**如果<code>mapper</code>,<code>reducer</code>不是使用系统的shell命令,那么就需要加上<code>-file</code>参数来把我们用其他程序写的代码分发到所有节点。另外还有一个地方需要注意，要确保<code>-output output_dir</code>路径不存在，你需要在调用之前调用删除命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u$&#123;HADOOP_USER&#125; $&#123;HADOOP_HOME&#125;/bin/hadoop fs -rm -r output_dir</span><br></pre></td></tr></table></figure>

<p>还有一些常用的参数设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-jobconf &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-jobconf mapreduce.job.queue.name=xxx -jobconf mapreduce.job.name=xxx</span><br></pre></td></tr></table></figure>

<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>对于日志这种，其实是多路输入，合并到一路输出，中间只是把一行内容变成一行内容，用特定字符分隔开来而已，所以并没有<code>reduce</code>过程，如果我们用了上面那个参数，最后会又有一个<code>reducer</code>，特别慢，关键是有可能内存不够，所以可以取消掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-jobconf mapred.reduce.tasks=0</span><br></pre></td></tr></table></figure>
<p>这样就不会有<code>reducer</code>了，会快很多。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 主题同步</title>
    <url>/2016/07/06/Hexo-%E4%B8%BB%E9%A2%98%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>由于经常在两台电脑上同步博客，一般博客文件夹下面的文件我会单独同步到Git上的一个项目。但是碰上重装系统了，虽然博客的内容可以直接从Github上同步下来，但是主题没了，所以研究了一下主题同步的方法。</p>
<p>系统环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo -v</span><br><span class="line">hexo: 3.2.0</span><br><span class="line">hexo-cli: 1.0.1</span><br><span class="line">os: Linux 4.4.0-28-generic linux x64</span><br><span class="line">http_parser: 2.5.0</span><br><span class="line">node: 4.1.1</span><br><span class="line">v8: 4.5.103.33</span><br><span class="line">uv: 1.7.4</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 46</span><br><span class="line">openssl: 1.0.2d</span><br></pre></td></tr></table></figure>
<p>我用的主题是<a href="https://github.com/wuchong/jacman">jacmam</a>,顺便说一下，Hexo的主题列表地址为<a href="https://hexo.io/themes/">Hexo主题列表</a></p>
<h3 id="主题同步"><a href="#主题同步" class="headerlink" title="主题同步"></a>主题同步</h3><p>这里采取的是<code>fork + subtree</code>来实现同步，下面都是以<code>jacman</code>主题为例</p>
<ul>
<li>fork目标主题</li>
</ul>
<p>jacman的git地址为:<code>https://github.com/wuchong/jacman.git</code>，然后我fork这个主题,于是我的项目的地址为:<code>https://github.com/sjq597/jacman</code>,然后我先把我本地的主题删掉:</p>
<ul>
<li>主题集成同步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ sudo rm -r themes/jacman</span><br><span class="line">➜  Blog git:(master) ✗ git remote add -f jacman https://github.com/sjq597/jacman</span><br><span class="line">更新 jacman 中</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 1292, done.</span><br><span class="line">remote: Total 1292 (delta 0), reused 0 (delta 0), pack-reused 1292</span><br><span class="line">接收对象中: 100% (1292/1292), 2.81 MiB | 311.00 KiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (665/665), 完成.</span><br><span class="line">来自 https://github.com/sjq597/jacman</span><br><span class="line"> * [新分支]          closeaside -&gt; jacman/closeaside</span><br><span class="line"> * [新分支]          gh-pages   -&gt; jacman/gh-pages</span><br><span class="line"> * [新分支]          master     -&gt; jacman/master</span><br><span class="line"> * [新分支]          site       -&gt; jacman/site</span><br><span class="line"> * [新标签]          v0.9.0     -&gt; v0.9.0</span><br><span class="line">➜  Blog git:(master) ✗ git subtree add --prefix=themes/jacman jacman master --squash</span><br><span class="line">git fetch jacman master</span><br><span class="line">来自 https://github.com/sjq597/jacman</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Added dir &#x27;themes/jacman&#x27;</span><br><span class="line">➜  Blog git:(master) ✗ git fetch jacman master </span><br><span class="line">来自 https://github.com/sjq597/jacman</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br></pre></td></tr></table></figure>
<p>这样就把<code>jacman</code>作为了我的博客<code>Blog</code>项目的一个子项目了，子项目可以单独更新以及推送，同理，如果父项目中更新了子项目，那么这个更新也会推送到父项目，下面有一些常用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a -m &#x27;update some&#x27;</span><br><span class="line">git subtree push --prefix=themes/jacman/ jacman master</span><br><span class="line">git push origin master # 顺便主项目也 push 了</span><br></pre></td></tr></table></figure>
<p>或者单独推送子项目:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git subtree push -P themes/jacman/ jacman master</span><br></pre></td></tr></table></figure>
<p>命令参考:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git subtree add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class="line">git subtree add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class="line">git subtree pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class="line">git subtree push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class="line">git subtree merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class="line">git subtree split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 学习笔记01 </title>
    <url>/2016/04/24/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<p>由于平时经常使用Python,所以想使用Python的微框架开发一些简单的工具来提升工作效率，特此记录一下学习Flask的笔记。</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>本机系统: Ubuntu 14.04 64bits<br>所有的学习第一步就是配置开发环境，还好Ubuntu自带了Python,这里采用的虚拟Python配置，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install python-virtualenv</span><br></pre></td></tr></table></figure>
<p>或者使用pip安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ $ sudo pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>如果你是Windows用户，并且你已经安装了<code>pip</code>工具，则去掉<code>sudo</code>在cmd命令下也可以安装<br>然后创建一个包含<code>venv</code>的文件夹的项目文件夹，项目就建在这里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir flask_project</span><br><span class="line">$ cd flask_project</span><br><span class="line">$ sudo virtualenv venv</span><br></pre></td></tr></table></figure>
<p>现在每次要使用项目，就可以在<code>flask_project</code>文件夹中运行下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ . venv/bin/activate</span><br></pre></td></tr></table></figure>
<p>对应的Windows启动命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ . venv/Scripts/activate</span><br></pre></td></tr></table></figure>
<p>你现在进入你的virtualenv(注意查看你的shell提示符已经改变了)。每次需要安装包的时候就先激活虚拟环境，下面安装<code>flask</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure>
<p>**注意:**这里有个地方需要个别强调一下，安装包不能使用sudo权限来安装，如果不带<code>sudo</code>安装提示权限不够，请把<code>flask_project</code>文件夹的权限设置为当前用户,例如，当前用户为<code>zhangsan</code>,在<code>flask_project</code>的父目录执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown zhangsan:zhangsan -R flask_project</span><br></pre></td></tr></table></figure>
<p>相应的退出使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure>

<h3 id="一个最简单的应用"><a href="#一个最简单的应用" class="headerlink" title="一个最简单的应用"></a>一个最简单的应用</h3><p>在<code>flask_project</code>文件夹中创建一个文件<code>hello.py</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#x27;Hello World!&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>在命令行或者终端里运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python hello.py</span><br></pre></td></tr></table></figure>
<p>然后在浏览器打开<code>http://127.0.0.1:5000/</code>就可以看到一个最简单的hello world页面了。大概解释一下：</p>
<ol>
<li>首先我们导入了<strong>Flask</strong>类。这个类的实例将会成为我们的<strong>WSGI</strong>应用,即后面的<strong>app</strong>。</li>
<li>接着我们创建了这个类的实例。第一个参数是应用模块或者包的名称。如果你使用一个 单一模块（就像本例），那么应当使用<code>__name__</code>,因为名称会根据这个模块是按 应用方式使用还是作为一个模块导入而发生变化（可能是<code>__main__</code>，也可能是 实际导入的名称）。这个参数是必需的，这样<strong>Flask</strong>就可以知道在哪里找到模板和 静态文件等东西。不明白也没关系，先这么写，后面慢慢会深入研究。</li>
<li>然后我们使用<code>route()</code>装饰器来告诉<strong>Flask</strong>触发函数的<strong>URL</strong>。函数名称可用于生成相关联的<strong>URL</strong>，并返回需要在用户浏览器中显示的信息。这个和Java里的<strong>Controller</strong>非常的像，用过Spring的同学对此应该很熟悉。</li>
<li>最后，使用<code>run()</code>函数来运行本地服务器和我们的应用。<code>if __name__ == &#39;__main__&#39;:</code> 确保服务器只会在使用Python解释器运行代码的情况下运行，而不会在作为模块导入时运行。</li>
</ol>
<p>本机访问没问题，但是局域网的其他机器如果也想访问，则需要这样启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.run(host=&#x27;0.0.0.0&#x27;)</span><br></pre></td></tr></table></figure>
<p>这行代码告诉你的操作系统监听一个公开的IP 。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><p>开发程序不可能这么简单，需要不断的调试，所以<strong>Flask</strong>也为我们想好了，专门有个调试模式，这样不用重启服务器，代码有变动，会自动重启，并且出错提示信息也很强大，打开调试器的有两种方式：</p>
<ol>
<li>通过设置实例的属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.debug = True</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure></li>
<li>启动传参设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.run(debug=True)</span><br></pre></td></tr></table></figure>
**注意:**调试器很强大，可以执行任意代码，所以千万不要在项目上线之后打开调试模式。</li>
</ol>
<h3 id="路由route"><a href="#路由route" class="headerlink" title="路由route()"></a>路由route()</h3><p>路由装饰器用于将一个函数和一个<strong>URL</strong>绑定，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return &#x27;Index Page&#x27;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/hello&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    return &#x27;Hello World&#x27;</span><br></pre></td></tr></table></figure>
<p>这只是最简单，最基础的，实际开发中不可能都是这么简单的URL,大多数情况下URL里面有一部分是动态变化的，例如好多URL里面会带ID,表示网页的一个标号。</p>
<h4 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h4><p><variable_name>里面可以添加变量，<a href="converter:variable_name">converter:variable_name</a>可以为变量加一个转换器,目前只支持<code>int,float,path</code>最后一个为路径，接受<code>/</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/user/&lt;username&gt;&#x27;)</span><br><span class="line">def show_user_profile(username):</span><br><span class="line">    # 通过获取URL的user_name作为函数的传入参数</span><br><span class="line">    return &#x27;User %s&#x27; % username</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)</span><br><span class="line">def show_post(post_id):</span><br><span class="line">    # 传入post_id，并且必须是一个整数</span><br><span class="line">    return &#x27;Post %d&#x27; % post_id</span><br></pre></td></tr></table></figure>

<h4 id="唯一URL-重定向问题"><a href="#唯一URL-重定向问题" class="headerlink" title="唯一URL&#x2F;重定向问题"></a>唯一URL&#x2F;重定向问题</h4><p>看下面一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/projects/&#x27;)</span><br><span class="line">def projects():</span><br><span class="line">    return &#x27;The project page&#x27;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/about&#x27;)</span><br><span class="line">def about():</span><br><span class="line">    return &#x27;The about page&#x27;</span><br></pre></td></tr></table></figure>
<p>注意一个尾部有<strong>斜杠</strong>，一个没有。看上去带<strong>斜杠</strong>的URL很像一个文件夹，当我们访问一个没有带<strong>斜杠</strong>的URL的时候，为自动加一个<strong>斜杠</strong>。但是反过来，如果访问第二个URL你在尾部带了一个<strong>斜杠</strong>，则会报错。可能你有些疑惑，为啥要这么做，答案也很简单：这样在访问一个不带<strong>斜杠</strong>的URL时，不管真正的URL是否带<strong>斜杠</strong>我们都可以继续访问URL,并且URL是唯一的。</p>
<h4 id="URL构建"><a href="#URL构建" class="headerlink" title="URL构建"></a>URL构建</h4><p>设想一下，你想先设定好页面的访问URL,你需要测试你写的函数能不能被你指定的URL访问到，直接构建这些URL就可以了。<code>url_for</code>它把函数名称作为第一个参数，其余参数对应URL中的变量。未知变量将添加到URL中作为查询参数。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, url_for</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index(): pass</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/login&#x27;)</span><br><span class="line">def login(): pass</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/user/&lt;username&gt;&#x27;)</span><br><span class="line">def profile(username): pass</span><br><span class="line"></span><br><span class="line">with app.test_request_context():</span><br><span class="line">	print url_for(&#x27;index&#x27;)</span><br><span class="line">	print url_for(&#x27;login&#x27;)</span><br><span class="line">	print url_for(&#x27;login&#x27;, next=&#x27;/&#x27;)</span><br><span class="line">	print url_for(&#x27;profile&#x27;, username=&#x27;John Doe&#x27;)</span><br></pre></td></tr></table></figure>
<p>运行程序会输出以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">/login</span><br><span class="line">/login?next=/</span><br><span class="line">/user/John%20Doe</span><br></pre></td></tr></table></figure>
<p>这里用到了一个方法<code>test_request_context()</code>,这个会告诉<code>Flask</code>我们正在处理一个请求，虽然我们并没有真正的去请一个URL.</p>
<h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><p>访问一个URL有好几个方法，常见的就是get，post方法,缺省情况下一个路由只回应GET请求，也可以像下面这样手动指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        do_the_login()</span><br><span class="line">    else:</span><br><span class="line">        show_the_login_form()</span><br></pre></td></tr></table></figure>

<h4 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h4><p>一般就是指css,js文件，如果工程里面要用到这些静态的库，可以在应用的根目录下新建<code>static</code>文件夹,设用选定的<code>static</code>端点就可以生成对应的URL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;)</span><br></pre></td></tr></table></figure>
<p>因此该文件对应的在文件系统中的路径应该是<code>static/style.css</code></p>
<h4 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h4><p>这是个很强大的功能，基本上目前的框架都得支持这个，毕竟原生的写HTML很慢，还要考虑各种转义，乱码等，Flask内置Jinja2模板引擎。使用<code>render_template()</code>来渲染模板,只需要把模板的名字和对应的一些参数传进去就行了，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/hello/&#x27;)</span><br><span class="line">@app.route(&#x27;/hello/&lt;name&gt;&#x27;)</span><br><span class="line">def hello(name=None):</span><br><span class="line">    return render_template(&#x27;hello.html&#x27;, name=name)</span><br></pre></td></tr></table></figure>
<p>Flask默认会在<code>templates</code>文件夹内寻找模板，如果你的应用是一个模块,则<code>templates</code>文件夹应该和应用在一个目录下,即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/application.py</span><br><span class="line">/templates</span><br><span class="line">    /hello.html</span><br></pre></td></tr></table></figure>
<p>如果你的应用是一个包,则应该在包里面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/application</span><br><span class="line">    /__init__.py</span><br><span class="line">    /templates</span><br><span class="line">        /hello.html</span><br></pre></td></tr></table></figure>
<p>这个就类似预JSP一类的东西，你也可以在模板内部访问**request, session, get_flashed_messages()<code>等，不过比JSP更加强大,因为模板可以实现继承，这样就能保持很多特定的元素重用，保持一致。 默认特殊的一些变量会被转义，例如HTML,如果信任某个变量，也可以使用</code>Markup&#96;类来把它标记为安全的,具体的等学到了再详细研究。</p>
<h3 id="操作请求数据"><a href="#操作请求数据" class="headerlink" title="操作请求数据"></a>操作请求数据</h3><p>一个Web应用其实就是服务器相应客户端发来的消息，Flask中由全局对象<code>request</code>来提供请求信息，如果你熟悉Python你就会知道，全局的对象大家都可以访问，其实也并不是通常意义上的全局变量，这个request只是特定环境下的本地对象的一个代理。</p>
<h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>首先必须从flask模块导入请求对象<code>from flask import request</code>,使用<code>method</code>属性可以操作当前请求的具体方法，<code>form</code>可以处理表单数据,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def login():</span><br><span class="line">    error = None</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        if valid_login(request.form[&#x27;username&#x27;],</span><br><span class="line">                       request.form[&#x27;password&#x27;]):</span><br><span class="line">            return log_the_user_in(request.form[&#x27;username&#x27;])</span><br><span class="line">        else:</span><br><span class="line">            error = &#x27;Invalid username/password&#x27;</span><br><span class="line">    # 如果请求访求是 GET 或验证未通过就会执行下面的代码</span><br><span class="line">    return render_template(&#x27;login.html&#x27;, error=error)</span><br></pre></td></tr></table></figure>
<p>如果form属性中不存在这个键值，会像普通集合那样抛出一个<code>KeyError</code>的异常。如果不捕获的话，就会显示一个<code>HTTP 400 Bad Request</code>错误页面，虽然你可以不用处理这个异常，但是显然不是很友好，所以推荐捕获异常，然会一个预定义好的错误页面.<br>如果要处理URL中的参数，可以使用<code>request.args.get(&#39;key&#39;, &#39;&#39;)</code>来获取.</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>使用Flask实现文件上传很简单，需要在HTML表单中设置<code>enctype=&quot;multipart/form-data</code>属性即可，上传的文件被存储在内存或者文件系统临时位置，通过请求对象files属性可以访问上传文件,看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def upload_file():</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        f = request.files[&#x27;the_file&#x27;]</span><br><span class="line">        f.save(&#x27;/var/www/uploads/uploaded_file.txt&#x27;)</span><br></pre></td></tr></table></figure>
<p>要想知道文件上传之前在客户端系统的名字，可以使用<code>filename</code>属性，但是这个可以伪造，所以建议通过<code>Werkzeug</code>提供的<code>secure_filename()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import request</span><br><span class="line">from werkzeug import secure_filename</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def upload_file():</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        f = request.files[&#x27;the_file&#x27;]</span><br><span class="line">        f.save(&#x27;/var/www/uploads/&#x27; + secure_filename(f.filename))</span><br></pre></td></tr></table></figure>

<h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>对于Web应用来说，这个必不可少，要访问cookeis,可以使用<code>cookies</code>属性。通过请求对象的<code>set_cookies</code>方法设置<code>cookies</code>，请求对象的<code>cookies</code>包含了客户端的所有cookies字典，所以这很不安全，能使用会话就不要直接使用cookies.</p>
<ul>
<li>读cookies:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    username = request.cookies.get(&#x27;username&#x27;)</span><br><span class="line">    # 使用 cookies.get(key) 来代替 cookies[key] ，</span><br><span class="line">    # 以避免当 cookie 不存在时引发 KeyError 。</span><br></pre></td></tr></table></figure></li>
<li>存储cookies:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import make_response</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    resp = make_response(render_template(...))</span><br><span class="line">    resp.set_cookie(&#x27;username&#x27;, &#x27;the username&#x27;)</span><br><span class="line">    return resp</span><br></pre></td></tr></table></figure>
**注意:**cookies设置在响应对象上，通常只是视图函数返回字符串，Flask会把它们转化为响应对象,显示的转化可以使用<code>make_response()</code>函数,然后再修改对应的值.</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect()</code>函数可以重定向,<code>abort()</code>可以更早的退出请求，返回错误码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import abort, redirect, url_for</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return redirect(url_for(&#x27;login&#x27;))</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/login&#x27;)</span><br><span class="line">def login():</span><br><span class="line">    abort(401)</span><br><span class="line">    this_is_never_executed()</span><br></pre></td></tr></table></figure>
<p><code>401</code>表示一个无法访问的页面,缺省情况下每种错误代码都会对应显示一个黑白的出错页面。使用<code>errorhandler()</code>装饰器可以定制出错页面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line"></span><br><span class="line">@app.errorhandler(404)</span><br><span class="line">def page_not_found(error):</span><br><span class="line">    return render_template(&#x27;page_not_found.html&#x27;), 404</span><br></pre></td></tr></table></figure>

<h4 id="关于响应"><a href="#关于响应" class="headerlink" title="关于响应"></a>关于响应</h4><p>视图函数的返回值会自动转化为一个响应对象。如果你返回一个字符串，那么就会被转换为一个响应对象，其中包含这个字符串以及一些其他的必要信息，如果想在视图内部掌控响应对象的结果，可以使用一个<code>make_response()</code>函数进行强制转换，例如原始视图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.errorhandler(404)</span><br><span class="line">def not_found(error):</span><br><span class="line">    return render_template(&#x27;error.html&#x27;), 404</span><br></pre></td></tr></table></figure>
<p>可以手动包装，修改某些特定的内容，例如头部信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.errorhandler(404)</span><br><span class="line">def not_found(error):</span><br><span class="line">    resp = make_response(render_template(&#x27;error.html&#x27;), 404)</span><br><span class="line">    resp.headers[&#x27;X-Something&#x27;] = &#x27;A value&#x27;</span><br><span class="line">    return resp</span><br></pre></td></tr></table></figure>

<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>除了请求对象和响应对象之外，还有个<code>session</code>这个对象，这个主要是用来在不同请求之间存储信息的。你可以简单理解为用密钥签名加密的cookie,cookie都可以查看，但是如果没有密钥就无法修改。所以使用会话之前必须设置一个密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, session, redirect, url_for, escape, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    if &#x27;username&#x27; in session:</span><br><span class="line">        return &#x27;Logged in as %s&#x27; % escape(session[&#x27;username&#x27;])</span><br><span class="line">    return &#x27;You are not logged in&#x27;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        session[&#x27;username&#x27;] = request.form[&#x27;username&#x27;]</span><br><span class="line">        return redirect(url_for(&#x27;index&#x27;))</span><br><span class="line">    return &#x27;&#x27;&#x27;</span><br><span class="line">        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">            &lt;p&gt;&lt;input type=text name=username&gt;</span><br><span class="line">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/logout&#x27;)</span><br><span class="line">def logout():</span><br><span class="line">    # 如果会话中有用户名就删除它。</span><br><span class="line">    session.pop(&#x27;username&#x27;, None)</span><br><span class="line">    return redirect(url_for(&#x27;index&#x27;))</span><br><span class="line"></span><br><span class="line"># 设置密钥，复杂一点：</span><br><span class="line">app.secret_key = &#x27;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&#x27;</span><br></pre></td></tr></table></figure>
<p><code>escape()</code>可以用来转义，如果你使用模板就简单的多，不用管这些。<br>生成密钥要保证做够随机,例如根据操作系统来生成一个密钥:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.urandom(24)</span><br></pre></td></tr></table></figure>
<p>基于<code>cookies</code>的会话，Flask其实是把会话对象里面的值都放在了cookies里面，如果你访问的会话里没有对应的属性。</p>
<h4 id="消息闪现"><a href="#消息闪现" class="headerlink" title="消息闪现"></a>消息闪现</h4><p>啥意思？简单来说就是在你请求结束的时候记录一个消息，然后你下次再请求的时候可以使用，然后用完就销毁了，所以叫闪现。<code>flash()</code>用于闪现一个消息，<code>get_flashed_messages()</code>来操作一个消息，具体的不介绍了，这个用的不是很多，用到再研究。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>一个Web应用当然少不了日志，万一崩了，直接看日志定位问题，使用也很简单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.logger.debug(&#x27;A value for debugging&#x27;)</span><br><span class="line">app.logger.warning(&#x27;A warning occurred (%d apples)&#x27;, 42)</span><br><span class="line">app.logger.error(&#x27;An error occurred&#x27;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用Gitment评论功能</title>
    <url>/2018/05/18/Hexo-%E4%BD%BF%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>一直想整一下博客的评论系统,以前听说多说比较有名气．但是当我想搞的时候发现多说居然关闭了，找了一圈发现除了<code>Gitment</code>这个<code>Github</code>自家的东西比较靠谱,所以就折腾了一下,期间碰到不少问题.</p>
<h2 id="安装Gitment"><a href="#安装Gitment" class="headerlink" title="安装Gitment"></a>安装Gitment</h2><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>在你的blog根目录安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i --save gitment</span><br></pre></td></tr></table></figure>

<h3 id="申请应用"><a href="#申请应用" class="headerlink" title="申请应用"></a>申请应用</h3><p>首先去<a href="https://github.com/settings/applications/new">New OAuth App</a>为你的博客应用一个密钥:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Application name:随便写</span><br><span class="line">Homepage URL:这个也可以随意写,就写你的博客地址就行</span><br><span class="line">Application description:描述,也可以随意写</span><br><span class="line">Authorization callback URL:这个必须写你的博客地址</span><br></pre></td></tr></table></figure>
<p>申请好之后点注册,然后就可以看到两个东西<code>ClientID</code>和<code>Client Secret</code>,后面会用到.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>下面就是配置<code>Gitment</code>,主要编辑在<code>themes/next/_config.yml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &#x27;Powered by ...&#x27; on footer, and more</span><br><span class="line">  language: # Force language, or auto switch by theme</span><br><span class="line">  github_user: &#123;you github user id&#125;</span><br><span class="line">  github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue</span><br><span class="line">  client_id: &#123;刚才申请的ClientID&#125;</span><br><span class="line">  client_secret: &#123;刚才申请的Client Secret&#125;</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure>

<h3 id="开通评论"><a href="#开通评论" class="headerlink" title="开通评论"></a>开通评论</h3><p>注意到这里基本上已经OK了,再看你的博客应该可以显示评论了.不过每篇博客都需要你手动初始化评论功能(如果你的历史博客很多那就一篇一篇去点吧，不过貌似有人写了批量处理脚本,没试过哈).</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>Error: Validation Failed</li>
</ul>
<p>issue的Label有长度限制,对于中文博客来说,中文标题很容易就超过长度限制,所以需要做一下特殊处理,修改<code>themes/next/layout/_third-party/comments/gitment.swig</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123;</span><br><span class="line">     id: &#x27;&#123;&#123; page.date &#125;&#125;&#x27;,</span><br><span class="line">     owner: &#x27;&#123;&#123; theme.gitment.github_user &#125;&#125;&#x27;,</span><br><span class="line">     repo: &#x27;&#123;&#123; theme.gitment.github_repo &#125;&#125;&#x27;,</span><br></pre></td></tr></table></figure>
<p>主要是那个id改一下,一般而言你写博客不可能同一时间创建两份博客,所以这个一般而言是不会重的．<br>**NOTE:**这一需要特别强调一下缓存问题,必须清除浏览器缓存,否则会一直报<code>Not Found</code>,具体表现就获取issue的地址里面有<code>undefined</code>,这个折腾了差不多一天才搞定.</p>
<ul>
<li>object ProgressEvent</li>
</ul>
<p>出现这个问题是由于作者在<code>gitment.browser.js</code>中硬编码了自己的服务器人证域名:<code>https://gh-oauth.imsun.net</code>，现在域名过期了,要么自己搭一个认证服务器，要么可以用其他人的，在gitment的issues里面找到了答案:<a href="https://github.com/imsun/gitment/issues/175">#175</a>,需要把Hexo你所用的主题中的引用文件给改一下，我用的是next主题,改动方法如下:<br>修改<code>themes/next/layout/_third-party/comments/gitment.swig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- LOCAL: You can save these files to your site and update links --&gt;</span><br><span class="line">    &#123;% if theme.gitment.mint %&#125;</span><br><span class="line">        &#123;% set CommentsClass = &quot;Gitmint&quot; %&#125;</span><br><span class="line">        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://aimingoo.github.io/gitmint/style/default.css&quot;&gt;</span><br><span class="line">        &lt;script src=&quot;https://aimingoo.github.io/gitmint/dist/gitmint.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        &#123;% set CommentsClass = &quot;Gitment&quot; %&#125;</span><br><span class="line">        &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; --&gt;</span><br><span class="line">        &lt;!-- &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css&quot;&gt;</span><br><span class="line">        &lt;script src=&quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;!-- END LOCAL --&gt;</span><br></pre></td></tr></table></figure>
<p>注释的部分是原来的地址，后面的是引用的网友的解决方案地址,需要注意的是确保<code>themes/next/_config.yml</code>中<code>theme.gitment.mint</code>设置为false,才会走到我们改动的分支.</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 基本配置</title>
    <url>/2015/10/25/Hexo-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>前面的文章介绍了如何安装hexo和使用hexo，但是关于hexo的常用配置，还是需要自己折腾一下。</p>
<h3 id="给文章添加分类"><a href="#给文章添加分类" class="headerlink" title="给文章添加分类"></a>给文章添加分类</h3><p>在根目录下的<code>scaffolds</code>目录下，修改<code>post.md</code>文件，内容改为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 目前貌似标签可以有很多个，语法类似于<code>tags: [tag1,tag2,tag3]</code>这样，但是分类好像只能填一个，类似于<code>categories: 测试</code>。</p>
<h3 id="更换Hexo博客模板"><a href="#更换Hexo博客模板" class="headerlink" title="更换Hexo博客模板"></a>更换Hexo博客模板</h3><p>这里以Jackman配置为例，首先在github官网下载主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wuchong/jacman.git themes/jacman</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> <a href="http://pan.baidu.com/s/1o67ZUvK">百度云备份地址</a>,提取密码：s7r6。</p>
<p>将<code>themes</code>文件夹下的<code>jacman</code>文件夹复制到你的Hexo项目的<code>themes</code>文件夹下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">sudo <span class="built_in">mv</span> jacman ~/Documents/blog/themes</span><br></pre></td></tr></table></figure>

<p>然后修改<code>blog</code>文件夹下的<code>_config.yml</code>文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">## Themes: http://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure>
<p>把<code>theme:landscape</code>修改为<code>theme:jacman</code>。</p>
<h3 id="Hexo使用公式"><a href="#Hexo使用公式" class="headerlink" title="Hexo使用公式"></a>Hexo使用公式</h3><p>我是使用的<code>jacman</code>的主题,这个主题使用公式很简单,只需要修改主题文件夹下的<code>_config.yml</code>文件即可.具体为修改<code>themes/jacman/_config.yml</code>文件.<br>将文件中的:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">close_aside:</span> <span class="literal">false</span>  <span class="comment">#close sidebar in post page if true</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span>      <span class="comment">#enable mathjax if true</span></span><br></pre></td></tr></table></figure>
<p>里的<code>mathjax</code>对应的值改为<code>true</code>就可以了,测试一下:<br>$$E&#x3D;MC^2$$<br>公式写法参见<a href="http://iori.sinaapp.com/17.html/comment-page-1?replytocom=2">MathJax使用LaTeX语法编写数学公式教程</a></p>
<h3 id="Hexo常见为题"><a href="#Hexo常见为题" class="headerlink" title="Hexo常见为题"></a>Hexo常见为题</h3><ul>
<li>Error: watch ENOSPC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用七牛图床</title>
    <url>/2015/10/06/Hexo-%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><p>本来图片放在本地的文件夹里也可以，但是<code>github</code>还是有存储空间限制的，而且这样也慢，所以用云存储商的云服务来作图床还可以加速，图片也不会丢。<br>假设你已经搭建好了博客了，如果没有，参照之前的文章来看。</p>
<h3 id="使用七牛运存储"><a href="#使用七牛运存储" class="headerlink" title="使用七牛运存储"></a>使用七牛运存储</h3><p>没有账号可以去注册，实名认证之后就可以使用云存储服务了。</p>
<ul>
<li><p>新建空间<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Hexo%20%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A01.png" alt="新建一个存储空间"><br><strong>注意：</strong> 一定要选公开空间，不然别人访问不到，开始一直没找到外链的链接在哪里，最后发现是自己开始把空间设置成私有空间了。</p>
</li>
<li><p>引用图片<br>把图片链接地址放到你想加载图片的地方，图片的地址是：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Hexo%20%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A02.png" alt="图片外链地址"></p>
</li>
</ul>
<h3 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h3><p>虽然这样可以显示了，但是在我的博客里显示的时候，图片特别小，有点儿看不清，后来才发现是七牛的默认设置图片显示尺寸太小，去七牛的控制台里设置自己的样式。<br>在<code>数据处理-&gt;图片处理里</code>，点<code>新建图片样式</code>，我把图片的宽度设的很大，这样就基本可以保持很清晰的图片样式了。<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Hexo%20%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A03.png" alt="新建图片样式"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用next.Pisces主题</title>
    <url>/2018/05/15/Hexo%E4%BD%BF%E7%94%A8next-Pisces%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>之前Hexo博客一直是使用的<a href="https://github.com/wuchong/jacman">Jacman</a>主题,用久的有点儿审美疲劳，最近看上比较简洁的主题<a href="https://github.com/theme-next/hexo-theme-next">Next</a>,视觉上确实要好看很多,配色简洁看着比较舒服.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先进入到你的博客的根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ </span><br><span class="line">➜  Blog git:(master) ✗ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>接下来就是把主题配置成<code>Next</code>,修改博客根目录下的配置文件<code>_config.yml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">## Themes: http://hexo.io/themes/</span><br><span class="line">theme: next </span><br></pre></td></tr></table></figure>
<p>然后启动博客就可以看到效果了.</p>
<h1 id="修改next样式"><a href="#修改next样式" class="headerlink" title="修改next样式"></a>修改next样式</h1><p>不过默认的博客样式不是很好,一些标签页展示的不是很好,所以还需要改下样式.进入<code>themes/next</code>文件夹,修改<code>_config.yml</code></p>
<h2 id="修改导航菜单"><a href="#修改导航菜单" class="headerlink" title="修改导航菜单"></a>修改导航菜单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
<p>修改了这几个之后还不够,需要创建这几个的导航页面(home导航页为根目录不需要创建):</p>
<h3 id="创建归档页面"><a href="#创建归档页面" class="headerlink" title="创建归档页面"></a>创建归档页面</h3><p>创建页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>修改内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2018-05-14 23:34:12</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="创建标签页"><a href="#创建标签页" class="headerlink" title="创建标签页"></a>创建标签页</h3><p>创建标签页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags </span><br></pre></td></tr></table></figure>
<p>修改内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2018-05-14 23:36:18</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="个人主页"><a href="#个人主页" class="headerlink" title="个人主页"></a>个人主页</h3><p>创建个人主页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>修改内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 个人简介</span><br><span class="line">date: 2018-05-14 23:38:55</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="切换主题布局"><a href="#切换主题布局" class="headerlink" title="切换主题布局"></a>切换主题布局</h3><p>可以看到<code>_config.yaml</code>文件中默认是使用的<code>Muse</code>主题,这个主题是把标签之类的放到顶部,我更喜欢双栏布局，所以把对应部分改成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h2><p>默认语言在<code>~/Blog/next/languages</code>下面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  next git:(master) ✗ ls -l languages/zh-*</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2100 5月  15 10:47 languages/zh-CN.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages/zh-HK.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages/zh-TW.yml</span><br></pre></td></tr></table></figure>
<p>默认<code>zh-CN.yml</code>就已经给我们映射好了，只需要把博客设置成对应的语言,修改<code>~/Blog/_config.yml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Chongqing</span><br></pre></td></tr></table></figure>

<h1 id="GitComment"><a href="#GitComment" class="headerlink" title="GitComment"></a>GitComment</h1><p>如果你配了用GitComment来作为你的博客评论，那你还需要改下对应得配置,不然评论都不会显示了,详情可以参见:<a href="../../18/Hexo-%E4%BD%BF%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">Hexo 使用Gitment评论功能</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive:SemanticException [Error 10025]: Line 1:7 Expression not in GROUP BY key</title>
    <url>/2015/11/11/Hive-SemanticException-Error-10025-Line-1-7-Expression-not-in-GROUP-BY-key/</url>
    <content><![CDATA[<p>在Hive表里同时用<code>group by</code>和<code>order by</code>的时候，出现了错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FAILED: SemanticException [Error 10025]: Line 1:7 Expression not <span class="keyword">in</span> GROUP BY key <span class="string">&#x27;sys_code&#x27;</span></span><br></pre></td></tr></table></figure>
<p>具体的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sys_code,status, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> ap_user_order_his</span><br><span class="line"><span class="keyword">where</span> link_end_date<span class="operator">=</span><span class="string">&#x27;2099-12-31&#x27;</span> <span class="keyword">and</span> sys_code <span class="keyword">in</span> (<span class="number">1000</span>,<span class="number">1001</span>,<span class="number">1003</span>,<span class="number">1004</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> status</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>后来上网查了一下，这个主要问题还是，<code>sys_code</code>也有多个种类，如果只是对<code>status</code>进行<code>group by</code>。那么<code>sys_code</code>没有办法分类，不知道该如何排序，所以解决办法有两种：</p>
<ul>
<li><p>既然按某一个字段分类，那么其他字段也只能有一种情况，所以可以使用集合，针对上面的这个语句就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collect_set(sys_code),status, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> ap_user_order_his</span><br><span class="line"><span class="keyword">where</span> link_end_date<span class="operator">=</span><span class="string">&#x27;2099-12-31&#x27;</span> <span class="keyword">and</span> sys_code <span class="keyword">in</span> (<span class="number">1000</span>,<span class="number">1001</span>,<span class="number">1003</span>,<span class="number">1004</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> status</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>或者可以只取一个值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collect_set(sys_code)[<span class="number">0</span>],status, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> ap_user_order_his</span><br><span class="line"><span class="keyword">where</span> link_end_date<span class="operator">=</span><span class="string">&#x27;2099-12-31&#x27;</span> <span class="keyword">and</span> sys_code <span class="keyword">in</span> (<span class="number">1000</span>,<span class="number">1001</span>,<span class="number">1003</span>,<span class="number">1004</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> status</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种就比较简单了，直接报错的字段也加到<code>GROUP BY</code>选项里即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive cannot recognize input near &#39;&lt;EOF&gt;&#39; &#39;&lt;EOF&gt;&#39; &#39;&lt;EOF&gt;&#39;</title>
    <url>/2015/11/17/Hive-cannot-recognize-input-near-EOF-EOF-EOF/</url>
    <content><![CDATA[<p>在Hive中复制表数据,把一个表的查询结果存储起来放到一个完整的表中,用到了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1_name <span class="keyword">as</span> <span class="keyword">select</span> filed1[,field2][,field3...] <span class="keyword">from</span> table2_name;</span><br></pre></td></tr></table></figure>
<p>根据上面的语法,我想直接把一个表的查询结果作为<code>table2_name</code>,看看我的写法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> substr(login_time,<span class="number">0</span>,<span class="number">10</span>) <span class="keyword">as</span> <span class="keyword">day</span>,<span class="built_in">count</span>(user_name) <span class="keyword">as</span> empty_user</span><br><span class="line"><span class="keyword">from</span> table2_name</span><br><span class="line"><span class="keyword">where</span> user_name<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> user_name <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> substr(login_time,<span class="number">0</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong><code>table2_name</code>表存放的是每天有登陆记录的用户,上面的语句其实是想统计每天用户名为空或者没有用户名的用户.<br>出现了报错信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FAILED: ParseException line 6:34 cannot recognize input near &#x27;&lt;EOF&gt;&#x27; &#x27;&lt;EOF&gt;&#x27; &#x27;&lt;EOF&gt;&#x27; in subquery source</span><br></pre></td></tr></table></figure>
<p>意思是子查询的语法不对,语句的结尾不正确,后来仔细想了一下,想到别名这个sql里常用的语法,虽然表的别名本身并没有什么大用,但是在子查询中经常用到,而且没有别名没有时还会报错,于是把后面加了一个表别名,改为如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> substr(login_time,<span class="number">0</span>,<span class="number">10</span>) <span class="keyword">as</span> <span class="keyword">day</span>,<span class="built_in">count</span>(user_name) <span class="keyword">as</span> empty_user</span><br><span class="line"><span class="keyword">from</span> table2_name</span><br><span class="line"><span class="keyword">where</span> user_name<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> user_name <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> substr(login_time,<span class="number">0</span>,<span class="number">10</span>)) p1;</span><br></pre></td></tr></table></figure>
<p>然后就好了.</p>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive count(*)和count(expr)</title>
    <url>/2015/11/11/Hive-count-%E5%92%8Ccount-expr/</url>
    <content><![CDATA[<p>最近在给PM做报表时，要统计登陆订单的下单比例，也就是说哪些订单是登陆用户的订单，那些没有用户名，即用户名为<code>null</code>的用户不需要统计到最后的登陆订单中。<br>一开始我想这直接在<code>count</code>函数内写一个条件判断:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> user_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> login_order</span><br><span class="line"><span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<p>但是后来我在查询Hive里count函数的用法时，发现了网上有人说，其实count在统计行数的时候，会根据使用的用法进行不同的逻辑运算，具体看Hive参考文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(*) - Returns the total number of retrieved rows, including rows containing NULL values;</span><br><span class="line">count(expr) - Returns the number of rows for which the supplied expression is non-NULL;</span><br><span class="line">count(DISTINCT expr[, expr]) - Returns the number of rows for which the supplied expression(s) are unique and non-NULL.</span><br></pre></td></tr></table></figure>
<p>上面的意思简单明了，除了<code>count(*)</code>之外，其他的计算的是非空值的条数，并且加上<code>distinct</code>还会合并重复记录到一类里面。<br>看到这里，我才发现，上面的写法有些多余，可以直接就count(user_name)，会自动略过那些user_name为空的记录。但是后面我还是采用了这个多余的写法，为什么？其实还是出于可读性和可维护性，这样写虽然复杂，但是后来维护的人起码知道你没有统计null用户。</p>
<h3 id="Hive-count高级用法"><a href="#Hive-count高级用法" class="headerlink" title="Hive count高级用法"></a>Hive count高级用法</h3><p>count不是简单只有<code>count(*)</code>用法，下面还有一些更为高级的用法，加上条件语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> type,</span><br><span class="line">	<span class="built_in">count</span>(<span class="operator">*</span>),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> u),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> plat<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> u <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> plat<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> u <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> (type<span class="operator">=</span><span class="number">2</span> <span class="keyword">or</span> type<span class="operator">=</span><span class="number">6</span>) <span class="keyword">then</span> u <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> (type<span class="operator">=</span><span class="number">2</span> <span class="keyword">or</span> type<span class="operator">=</span><span class="number">6</span>) <span class="keyword">then</span> u <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">in</span> (<span class="string">&#x27;2015-11-01&#x27;</span>, <span class="string">&#x27;2015-11-01)</span></span><br><span class="line"><span class="string">group by type</span></span><br><span class="line"><span class="string">order by type;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive UDF函数开发使用样例</title>
    <url>/2015/11/25/Hive-UDF%E5%87%BD%E6%95%B0%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</url>
    <content><![CDATA[<p>关于<code>UDF</code>的废话也不多讲了,主要讲一下如何开发一个<code>UDF</code>函数以及如何部署到服务器的<code>Hive</code>中使用.</p>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>有一个Hive表的某个字段是一个<code>collect_set</code>类型,里面是一些数字,类似下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhang.san	[2,3]</span><br><span class="line">li.si		[0,3]</span><br><span class="line">wang.wu		[1,2]</span><br></pre></td></tr></table></figure>
<p>每个数字都代表着对应的特定的名字,假设配置文件<code>code.properties</code>内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0=北京</span><br><span class="line">1=上海</span><br><span class="line">2=深圳</span><br><span class="line">3=香港</span><br></pre></td></tr></table></figure>
<p>你可以假设这是一个统计一个人去过的城市列表,那么<code>[2,3]</code>就代表这个人去过深圳和香港.当然有些时候数据表里会按照代码的方式来记录,到要用的时候再做一个映射即可,现在有个需求就是,我们要把这些代码换成具体的城市,即一个字典映射,来看看我们如何用UDF函数来解决这个问题.</p>
<h3 id="开发UDF函数"><a href="#开发UDF函数" class="headerlink" title="开发UDF函数"></a>开发UDF函数</h3><p>以java代码为例,基于maven构建工程.</p>
<h4 id="新建maven工程"><a href="#新建maven工程" class="headerlink" title="新建maven工程"></a>新建maven工程</h4><p>怎么新建Maven工程我这里就不详细讲解了,建好了目录如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hive  tree</span><br><span class="line">.</span><br><span class="line">├── hive.iml</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── UDF</span><br><span class="line">│   │   │       └── BusinessType.java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       └── business_no.properties</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── UDF</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   ├── business_no.properties</span><br><span class="line">    │   └── UDF</span><br><span class="line">    │       └── BusinessType.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    └── MANIFEST.MF</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong><code>src/main</code>目录下的<code>java</code>为代码根目录,<code>resources</code>为资源根目录,<code>test</code>目录为测试根目录,<code>target</code>下的<code>classes</code>目录为<code>.class</code>文件输出路径.</p>
<h3 id="开发代码"><a href="#开发代码" class="headerlink" title="开发代码"></a>开发代码</h3><p>分为三个地方:</p>
<blockquote>
<p>pom.xml文件<br>BusinessType.java源码文件<br>business_no.properties为配置文件,即一个映射字典.</p>
</blockquote>
<h4 id="BusinessType-java"><a href="#BusinessType-java" class="headerlink" title="BusinessType.java"></a>BusinessType.java</h4><p>代码很简单,如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> hive</span></span><br><span class="line"><span class="comment"> * Created by junqiangshen on 15-11-24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessType</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, String&gt; sysCodeMapping = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessType</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">propFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;business_no.properties&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(propFile);</span><br><span class="line">        <span class="keyword">for</span> (Object key : prop.keySet()) &#123;</span><br><span class="line">            sysCodeMapping.put(Integer.valueOf((String)key), prop.getProperty(String.valueOf(key)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(<span class="type">int</span> business_no)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysCodeMapping.get(business_no) == <span class="literal">null</span> ? Integer.valueOf(business_no).toString() : sysCodeMapping.get(business_no);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BusinessType</span> <span class="variable">businessType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusinessType</span>();</span><br><span class="line">        <span class="type">int</span> list[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            System.out.println(businessType.evaluate(list[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong> 函数一定要继承<code>UDF类</code>,并且根据你的业务需求重写里面的<code>evaluate()</code>方法,构造函数从资源根目录读取配置文件,把<code>key-value</code>加载到一个集合中,<code>Hive</code>每次调用的其实是<code>evaluate()</code>函数,对于每个传入的为<code>int</code>型的字段,经过我们的处理,在<code>evaluate()</code>函数内部会被当成<code>key</code>去我们的集合中查找,若有,则返回<code>key</code>对应的<code>value</code>;若没有,直接返回数字字符串.主函数是一个简单的测试,别忘了,提交到<code>Hive</code>里运行的时候要把<code>main</code>函数注释掉.</p>
<h4 id="business-no-properties"><a href="#business-no-properties" class="headerlink" title="business_no.properties"></a>business_no.properties</h4><p>配置文件即为我们替换的字典文件,格式就是每一行<code>key=value</code>这种格式,部分内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0=北京</span><br><span class="line">1=上海</span><br><span class="line">2=深圳</span><br><span class="line">3=香港</span><br></pre></td></tr></table></figure>
<p>根据你的需要,你可以换成任何值.</p>
<h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><p>开发UDF函数,还需要一些关键的包,这里我们采用Maven来管理我们的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>UDF<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="打包jar包"><a href="#打包jar包" class="headerlink" title="打包jar包"></a>打包jar包</h4><p>在main函数里调试没问题之后,就可以把main函数注释掉,打包成jar包.打包有很多方法,用IDEA自带的工具就可以打包,具体方法如下:</p>
<ul>
<li><code>File--&gt;Project Structure</code></li>
<li><code>Artifacts</code>,点中间绿色的<code>+</code>:<code>--&gt;JAR--&gt;From modules with dependencies</code></li>
<li><code>Name:</code>里填你希望生成的名字,例如<code>BusinessType:jar</code></li>
<li>输出路径默认就行,不用改.然后一定要勾选上<code>Build on make</code></li>
<li>依赖的jar包这里可以不用,Hive,Hadoop里都有,除非有其他包你需要加入,全选上,点<code>-</code>号都去掉</li>
</ul>
<p>回到IDEA主界面,<code>Build--&gt;Make Project</code>.在输出路径就可以找到jar包了<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Hive%20UDF%E5%87%BD%E6%95%B0%E5%BC%80%E5%8F%91%E6%A0%B7%E4%BE%8B01.png" alt="打包设置界面"><br>还有个打包比较简单的,直接用jar命令,以本程序为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd target/classes</span><br><span class="line">➜  classes  tree</span><br><span class="line">.</span><br><span class="line">├── business_no.properties</span><br><span class="line">└── UDF</span><br><span class="line">    └── BusinessType.class</span><br></pre></td></tr></table></figure>
<p>目录结构如上所示,打包命令为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jar cvf BusinessType.jar .</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><code>.</code>表示打包当前目录下所有文件,包括子目录,<code>BusinessType.jar</code>是生成的jar包名.</p>
<h3 id="部署到Hive上使用"><a href="#部署到Hive上使用" class="headerlink" title="部署到Hive上使用"></a>部署到Hive上使用</h3><p>写了个UDF,最后怎么在Hive里用呢?介绍两种方法,一种是临时使用.</p>
<h4 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h4><p>如果只是想测试一下,可以使用临时方案,简单方便,只是每次启动Hive客户端之前都要添加,创建函数,退出Hive客户端函数就会自动销毁了.<br>假设jar包存放在服务器上的<code>/home/tmp/</code>目录下:</p>
<ul>
<li>添加jar包</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">add</span> jar <span class="operator">/</span>home<span class="operator">/</span>tmp<span class="operator">/</span>BusinessType.jar;</span><br><span class="line">Added [<span class="operator">/</span>home<span class="operator">/</span>tmp<span class="operator">/</span>BusinessType.jar] <span class="keyword">to</span> class path</span><br><span class="line">Added resources: [<span class="operator">/</span>home<span class="operator">/</span>tmp<span class="operator">/</span>BusinessType.jar]</span><br></pre></td></tr></table></figure>

<ul>
<li>创建临时函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> temporary <span class="keyword">function</span> business_type_func <span class="keyword">as</span> <span class="string">&#x27;UDF.BusinessType&#x27;</span>;</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.015</span> seconds</span><br></pre></td></tr></table></figure>
<p> **注意:**切记,如果你的类有包名,要添加完整路径,例如我的类在UDF包里面,所以在创建函数的时候天的路径为<code>UDF.BusinessType</code>.</p>
<ul>
<li>建一张dual表测试</li>
</ul>
<p>dual表的概念来自oracle，数据库建立时即与数据字典一起初始化，该表只有一个varchar2类型名为dummy的字段，表数据只有一行“X”，用来查询一些系统信息，如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sysdate <span class="keyword">from</span> dual; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> seq.nextval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p> 为了能在hive中测试一些时间、数学、聚合函数，可以仿照oracle创建dual表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> dual (dummy String);</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> (<span class="number">1</span><span class="operator">+</span><span class="number">2</span>) <span class="keyword">from</span> dual;</span><br><span class="line">OK</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.145</span> seconds, Fetched: <span class="number">1</span> <span class="type">row</span>(s)</span><br></pre></td></tr></table></figure>

<ul>
<li>测试函数</li>
</ul>
<p>我们新建的临时函数名为business_type_func,可以这么测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> business_type_func(<span class="number">1</span>) <span class="keyword">from</span> dual;</span><br><span class="line">OK</span><br><span class="line">上海</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.145</span> seconds, Fetched: <span class="number">1</span> <span class="type">row</span>(s)</span><br></pre></td></tr></table></figure>

<h4 id="持久方案"><a href="#持久方案" class="headerlink" title="持久方案"></a>持久方案</h4><p>每次都要执行这个命令,如果确实是需要用的,不用每次都这么麻烦.还有一个原因,我写的这个函数不知道为什么,每次运行都会出问题,但是数据明明都可以跑出来,后来我就采用了下面的方法,就可以了.<br>我们可以把我们开发的jar包拷贝到Hive的lib目录下,然后如果这个目录在环境变量里,就可以每次启动的时候加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拷贝jar包到hive的lib目录</span></span><br><span class="line">sudo <span class="built_in">cp</span> /home/tmp/BusinessType.jar /home/hive/hive-0.12.0/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改hive配置文件</span></span><br><span class="line">sudo vim /home/hive/hive-0.12.0/conf/.hiverc</span><br></pre></td></tr></table></figure>
<p>在文件中添加下面两行内容:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> jar <span class="operator">/</span>home<span class="operator">/</span>hive<span class="operator">/</span>hive<span class="number">-0.12</span><span class="number">.0</span><span class="operator">/</span>lib<span class="operator">/</span>BusinessType.jar;</span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">function</span> business_type_func <span class="keyword">as</span> <span class="string">&#x27;UDF.BusinessType&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后重启就可以了,也不用再创建函数了,这个函数就在Hive启动时就会一起加载到Hive内部.</p>
<p><strong>后记:</strong> 如果你也出现了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1148 (42000) at line 1: The used command is not allowed with this MySQL version</span><br></pre></td></tr></table></figure>
<p>可以尝试采用第二种部署方式,至于原因还不明,有时间再研究.</p>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive group by distinct性能调优</title>
    <url>/2016/04/24/Hive-group-by-distinct%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h3 id="Hive去重统计"><a href="#Hive去重统计" class="headerlink" title="Hive去重统计"></a>Hive去重统计</h3><p>相信使用Hive的人平时会经常用到去重统计之类的吧，但是好像平时很少关注这个去重的性能问题，但是当一个表的数据量非常大的时候，会发现一个简单的<code>count(distinct order_no)</code>这种语句跑的特别慢，和直接运行<code>count(order_no)</code>的时间差了很多，于是研究了一下。<br>**先说结论:**能使用<code>group by</code>代替<code>distinc</code>就不要使用<code>distinct</code>，例子：</p>
<h3 id="实际论证"><a href="#实际论证" class="headerlink" title="实际论证"></a>实际论证</h3><p>order_snap为订单的快照表 总记录条数763191489，即将近8亿条记录,总大小:108.877GB,存储的是公司所有的订单信息，表的字段大概有20个,其中订单号是没有重复的,所以在统计总共有多少订单号的时候去重不去重结果都一样，我们来看看:<br>统计所有的订单有多少条条数，一个<code>count</code>函数就可以搞定的sql性能如何。</p>
<ul>
<li>DISTINCT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct order_no) from order_snap;</span><br><span class="line">Stage-Stage-1: Map: 396  Reduce: 1   Cumulative CPU: 7915.67 sec   HDFS Read: 119072894175 HDFS Write: 10 SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: 0 days 2 hours 11 minutes 55 seconds 670 msec</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">763191489</span><br><span class="line">Time taken: 1818.864 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

<ul>
<li>GROUP BY</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(t.order_no) from (select order_no from order_snap group by order_no) t;</span><br><span class="line">Stage-Stage-1: Map: 396  Reduce: 457   Cumulative CPU: 10056.7 sec   HDFS Read: 119074266583 HDFS Write: 53469 SUCCESS</span><br><span class="line">Stage-Stage-2: Map: 177  Reduce: 1   Cumulative CPU: 280.22 sec   HDFS Read: 472596 HDFS Write: 10 SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: 0 days 2 hours 52 minutes 16 seconds 920 msec</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">763191489</span><br><span class="line">Time taken: 244.192 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

<p>**结论:**第二种写法的性能是第一种的<code>7.448499541</code>倍<br>注意到为什么会有这个差异，Hadoop其实就是处理大数据的，Hive并不怕数据有多大，怕的就是数据倾斜,我们看看两者的输出信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># distinct</span><br><span class="line">Stage-Stage-1: Map: 396  Reduce: 1   Cumulative CPU: 7915.67 sec   HDFS Read: 119072894175 HDFS Write: 10 SUCCESS</span><br><span class="line"># group by</span><br><span class="line">Stage-Stage-1: Map: 396  Reduce: 457   Cumulative CPU: 10056.7 sec   HDFS Read: 119074266583 HDFS Write: 53469 SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发现猫腻了没有，使用distinct会将所有的order_no都shuffle到一个reducer里面，这就是我们所说的数据倾斜，都倾斜到一个reducer这样性能能不低么？再看第二个，直接按订单号分组，起了457个<code>reducer</code>，将数据分布到多台机器上执行，时间当然快了.<br>由于没有手动指定Reduce的个数，Hive会根据数据的大小动态的指定Reduce大小，你也可以手动指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; set mapred.reduce.tasks=100；</span><br></pre></td></tr></table></figure>
<p>类似这样,所以如果数据量特别大的情况下，尽量不要使用<code>distinct</code>吧。<br>但是如果你想在一条语句里看总记录条数以及去重之后的记录条数，那没有办法过滤，所以你有两个选择，要么使用两个sql语句分别跑，然后union all或者就使用普通的distinct。具体来说得看具体情况，直接使用distinct可读性好，数据量如果不大的话推荐使用，如果数据太大了，性能受到影响了，再考虑优化。</p>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 控制生成文件个数</title>
    <url>/2016/11/21/Hive-%E6%8E%A7%E5%88%B6mapper-reducer%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>在有些时候，想要控制hql执行的mapper,reducer个数,reducer设置过少，会导致每个reducer要处理的数据过多，这样可能会导致OOM异常，如果reducer设置过多，则会导致产生很多小文件，这样对任务的执行以及集群都不太好.通常情况下这两个参数都不需要手动设置，Hive会根据文件的大小和任务的情况自动计算,但是某些特殊情况下可能需要进行调优，下面列举两个常用的调优场景看看这两个参数在调优的时候都是怎么用的:</p>
<h3 id="设置reducer个数"><a href="#设置reducer个数" class="headerlink" title="设置reducer个数"></a>设置reducer个数</h3><p>reducer个数最直接的影响是hql执行完之后生成的文件个数，假设你的任务有n个reducer,那么最后可能会生成的文件肯定至少有n个,前提是你没有设置合并小文件，这个有什么用处呢？最简单的一个用处是我们在hive里面经常会调第三方接口来获取数据，例如解密之内的，假设接口不限速，我们在udf里面调接口的时候会发现特别慢，感觉直接select很快，但是把查询结果insert到一个表保存就很慢，这个原因就在于数据请求线程太少了。<br>在hadoop里面，一个文件至少会起一个mapper,如果你的文件很小(默认1G起一个mapper),那就完了，整个任务就一直是一个个来请求接口的，所以非常的慢。那如果想加快接口的调用呢？其实也简单，把文件分成几个小文件，假设分成了10个小文件，那么再次调接口就会快很多了，10线程和单线程的差别还是非常大的。<br>具体的语句也就两句话，记住，划分小文件还得保证每个文件尽量大小一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set mapred.reduce.tasks=50;</span><br><span class="line">insert into table xxx</span><br><span class="line">select</span><br><span class="line">  *</span><br><span class="line">from</span><br><span class="line"> xxx</span><br><span class="line">distribute by rand();</span><br></pre></td></tr></table></figure>
<p>**备注:**第一个set设置的就是最后你要生成的文件个数，后面的<code>distribute by rand()</code>保证了记录随机分配到50个文件，不管里数据量有多小，最后这50个文件的大小应该是一致的.</p>
<h3 id="动态分区产生小文件"><a href="#动态分区产生小文件" class="headerlink" title="动态分区产生小文件"></a>动态分区产生小文件</h3><p>有些场景会产生大量的文件，比如动态分区插入，或者两个比较大的表做join，对于大表做join，我没有细测，但是我发现我用一个很小的表(大概70M),去join一个很大的表(大概400G),由于Hive在处理小表join大表的时候会做优化,左边的表会都加载到内存里面，然后分发到各个节点和大表做join,这样最后就会在大表所在的节点产生最终的结果，后果就是会原来大表的那些文件现在都变成小文件了,小文件太多其实对性能还是有影响的,这个其实可以最后用一个reducer来合并小文件。<br>主要说一下动态分区产生小文件问题,这是个很有意思的问题，动态分区好用，但是为啥会产生这么多小文件。原因就在于，假设动态分区初始有N个mapper,那么最后生成了m个分区，最终会有多少个文件生成呢？答案是<code>N*m</code>,是的，每一个mapper会生成m个文件，就是每个分区都会对应一个文件，这样的话你算一下。所以小文件就会成倍的产生。怎么解决这个问题，通常处理方式也是像上面那样，让数据尽量聚到一个reducer里面,因为有时候虽然动态分区不会产生reducer,但是也就意味着最后没有进行文件合并,我们也可以用<code>distribute by rand()</code>这句来保证数据聚类到相同的reducer。</p>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 常用命令 01</title>
    <url>/2015/10/13/Hive-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-01/</url>
    <content><![CDATA[<p>最近在进行数据迁移，把常用的<code>Hive</code>命令整理一下。</p>
<h3 id="导入分区数据"><a href="#导入分区数据" class="headerlink" title="导入分区数据"></a>导入分区数据</h3><p>把一个<code>Hive</code>表中的数据导入到另一个表中，但是这两个表都是有分区的，需要动态导入，假设想把表<code>table_a</code>的数据导入到表<code>table_b</code>。这两个表都是按照时间分区的，例如表A的建表语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_a (</span><br><span class="line">  id int,</span><br><span class="line">  name string comment &#x27;姓名&#x27;,)</span><br><span class="line">comment &#x27;表A&#x27;</span><br><span class="line">PARTITIONED BY (dt string)</span><br><span class="line">ROW format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">lines terminated by &#x27;\n&#x27;</span><br><span class="line">stored as textfile;</span><br></pre></td></tr></table></figure>
<p>现在新建一个表B,建表语句和表A完全一样，把表A的数据导入到表B，可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE TABLE table_b partition(dt)</span><br><span class="line">select * from table_a</span><br></pre></td></tr></table></figure>

<h3 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h3><ul>
<li>登陆Hive</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u$&#123;user_name&#125; /home/q/hive/hive-0.12.0/bin/hive -database database_name</span><br></pre></td></tr></table></figure>

<h3 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h3><ul>
<li>重命名表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name rename to new_table_name</span><br></pre></td></tr></table></figure>

<ul>
<li>重命名分区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name partition(dt=&#x27;20151014&#x27;) rename to partition(dt=&#x27;20151014old&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除&#x2F;添加分区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name drop partition(dt=&#x27;20151014&#x27;);</span><br><span class="line">alter table table_name add if not exists partition(dt=&#x27;20151018&#x27;);</span><br><span class="line">alter table table_name add if not exists partition(dt&lt;&#x27;20151018&#x27;);	# 批量删除分区</span><br></pre></td></tr></table></figure>

<ul>
<li>清空表数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert overwrite table table_name select * from table_name where 1=0;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除指定条件的数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把Hive表中link_end_date字段为&#x27;2099-12-31&#x27;的数据删掉,即只要不等于这个值就再插回源表中</span><br><span class="line">insert overwrite table ap_fuwu_tb_complaint_his</span><br><span class="line">select * from ap_fuwu_tb_complaint_his where</span><br><span class="line">link_end_date&lt;&gt;&#x27;2099-12-31&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将数据插入到指定分区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name add if not exists partition(dt=&#x27;20151021old&#x27;);</span><br><span class="line">insert overwrite table table_name partition(dt=&#x27;20151021old&#x27;)</span><br><span class="line">SELECT * FROM table_name WHERE dt=&#x27;20151021&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果列不等，则把<code>*</code>换成对应的列。</p>
<ul>
<li>重命名列名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name CHANGE old_col_name new_col_name field_type;</span><br><span class="line"></span><br><span class="line"># 表结构列替换,通常用于</span><br><span class="line">alter table table_name replace columns (</span><br><span class="line">  col_name data_type [comment col_comment],</span><br><span class="line">  col_name data_type [comment col_comment],</span><br><span class="line">  col_name data_type [comment col_comment]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>改变列顺序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把old_col_name改名为new_col_name并且把这列放在another_col_name列后面</span><br><span class="line">alter table table_name CHANGE old_col_name new_col_name field_type after another_col_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table new_table like old_table;	# 只复制表结构，不复制数据</span><br><span class="line">create table new_table as select * from old_table;	# 复制数据</span><br></pre></td></tr></table></figure>
<p>**注意:**对于分区表，如果使用<code>create table xxx as select * from xxx</code>这样新表就不是分区表了，分区字段会作为一个字段插入到新表中。<br>所以如果想保证新表也是分区表,需要下面这样,假设分区字段为dt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table new_table like old_table;</span><br><span class="line">insert overwrite table new_table partition(dt) select * from old_table;</span><br></pre></td></tr></table></figure>

<h3 id="展示信息命令"><a href="#展示信息命令" class="headerlink" title="展示信息命令"></a>展示信息命令</h3><ul>
<li>展示建表语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>展示表详情</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>模糊查询</li>
</ul>
<p>使用<code>like</code>可以进行模糊查询使用<code>like</code>可以进行模糊查询,其中<code>_</code>表示单个字符,<code>%</code>表示任意数量的字符.要注意如果是用否定,语法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法类似下面这样</span><br><span class="line">select * from table where NOT &#x27;key&#x27; like &#x27;fff%&#x27;; </span><br></pre></td></tr></table></figure>

<p><strong>RLIKE</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符串a符合java正则表达式b的正则语法则返回true</span><br><span class="line"># 语法:A rlike b</span><br><span class="line">hive&gt; select 1 from tabe_name where &#x27;footbar&#x27; rlike &#x27;^f.*r$’;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>还有个和<code>rlike</code>功能一样的操作:<code>REGEXP</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hive&gt; <span class="keyword">select</span> 1 from table_name <span class="built_in">where</span> <span class="string">&#x27;footbar&#x27;</span> REGEXP <span class="string">&#x27;^f.*r$&#x27;</span>;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><ul>
<li>查看Hive表大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop fs -ls  /user/hive/warehouse/test_table/ds=20151111|awk -F &#x27; &#x27; &#x27;&#123;print $5&#125;&#x27;|awk &#x27;&#123;a+=$1&#125;END&#123;print a/(1024*1024*1024)&#125;&#x27;</span><br><span class="line">hadoop fs -du /user/hive/warehouse/test_table|awk &#x27; &#123; SUM += $1 &#125; END &#123; print SUM/(1024*1024*1024)&#125;&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 正则</title>
    <url>/2016/05/29/Hive-%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<p>分析日志经常要用到正则来提取需要分析的关键信息,其中需要注意的就是,Hive本身史用Java写的，所以HQL里面的正则和Java里面史一样的，但是具体在使用的时候，会碰到很多问题，就是转义的问题，总结了一下在各个语言中使用HQL时正则的不同情况。</p>
<h3 id="Hive-Cli"><a href="#Hive-Cli" class="headerlink" title="Hive Cli"></a>Hive Cli</h3><p>平时使用的时候，很多情况下都是在Hive Cli客户端中使用，这里和正常的正则需要稍微有一些区别,例如匹配数字，正常情况下就<code>\d</code>，但是在Hive Cli中需要注意,应该使用<code>\\d</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">  regexp_extract(content, &#x27;.*id=(\\d*).*&#x27;, 1) as id </span><br><span class="line">from</span><br><span class="line">  test.table_test;</span><br></pre></td></tr></table></figure>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>还有一种更为常见的使用场景，就是在Shell脚本中使用，Shell脚本中又涉及到单引号和双引号的区别,单引号史强引用类型,<code>\</code>不会被转义，但是双引号字符串则会转义，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg_str1=&#x27;.*id=(\\d*).*&#x27;</span><br><span class="line">reg_str2=&quot;.*id=(\\\\d*).*&quot;</span><br><span class="line"></span><br><span class="line">sudo -uhiev_user /usr/dev/hive-1.2.0/bin/hive -e &quot;</span><br><span class="line">select</span><br><span class="line">  regexp_extract(content, &#x27;$&#123;reg_str1&#125;&#x27;, 1) as id1, </span><br><span class="line">  regexp_extract(content, &#x27;$&#123;reg_str2&#125;&#x27;, 1) as id2 </span><br><span class="line">from</span><br><span class="line">  test.table_test;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<p>这两个正则表达式是一样的，其实确认你的HQL正则表达式是否有用，可以先用echo在sudo前面看看，如果输出的史<code>\\d</code>则说明有用</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>有时候需要在Python中执行HQL,好像Hive并不支持Python接口,所以我采取的是在Python中执行Shel命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash_cmd为Shell命令</span></span><br><span class="line">bash_cmd = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">sudo -uhive_user /usr/dev/hive-1.2.0/bin/hive -e &quot;&#123;0&#125;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(sql)	<span class="comment"># sql即为要执行的HQL</span></span><br><span class="line"></span><br><span class="line">hql_process = subprocess.Popen(bash_cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure>
<p>在Python中我定义来一个sql</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">select</span></span><br><span class="line"><span class="string">  regexp_extract(content, &#x27;.*id=(\\\\\\d*).*&#x27;, 1) as id </span></span><br><span class="line"><span class="string">from</span></span><br><span class="line"><span class="string">  test.table_test;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 参数设置</title>
    <url>/2016/02/20/Hive-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Hive参数设置方式"><a href="#Hive参数设置方式" class="headerlink" title="Hive参数设置方式"></a>Hive参数设置方式</h2><p>Hive提供了很多可设置参数，可以通过设置不同的参数来满足不同场景的各种需求，改变Hive有三种方式：</p>
<ol>
<li>修改Hive安装路径下的配置文件，即修改${HIVE_HOME}&#x2F;conf&#x2F;hive-site.xml文件里的配置；</li>
<li>在启动Hive时，在命令行里面设置参数；</li>
<li>在进入Hive的CLI客户端里面进行参数设置。</li>
</ol>
<h3 id="修改配置文件设置参数"><a href="#修改配置文件设置参数" class="headerlink" title="修改配置文件设置参数"></a>修改配置文件设置参数</h3><p>在安装好Hive之后，默认的配置会在${hive_home}&#x2F;conf&#x2F;hive-default.xml文件里面，一般都会对默认的配置做一定的修改，如果要修改默认配置，可以先在相同目录下创建一个<code>hive-site.xml</code>,格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">	    location of default database for the warehouse</span><br><span class="line">	<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有的配置都是以<code>&lt;configuration&gt;&lt;/configuration&gt;</code>标签里面，里面可以有多个<code>&lt;property&gt;&lt;/property&gt;</code>标签，每个<code>&lt;property&gt;&lt;/property&gt;</code>标签里面可以设定我们需要设定的属性值：</p>
<ol>
<li><code>&lt;name&gt;&lt;/name&gt;:</code>要设定的属性的属性名</li>
<li><code>&lt;value&gt;&lt;/value&gt;:</code>设定属性的值</li>
<li><code>&lt;description&gt;&lt;/description&gt;:</code>描述属性的一些介绍性语句，可以不写<br>大部分共同的配置都是写到这里的，如果有必要的话，因为这里面的配置对全局用户都有效，并且一旦设置就永久有效。并且<code>hive-site.xml</code>里的配置会覆盖<code>hive-default.xml</code>里的配置，并且由于Hive是作为Hadoop的客户端启动的，所以Hive同时也会读取Hadoop的配置，同理，Hive的配置会覆盖Hadoop的配置。</li>
</ol>
<h3 id="命令行设置参数"><a href="#命令行设置参数" class="headerlink" title="命令行设置参数"></a>命令行设置参数</h3><p>在命令行启动Hive进入CLI的时候，可以在命令行里面添加<code>--hiveconf param=value</code>来设定参数，例如，在终端里输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hive --hiveconf mapreduce.job.queuename=queue1</span><br></pre></td></tr></table></figure>
<p>这个是设置MapReduce任务的队列，注意这个设置是临时的，一旦你退出了Hive客户端，这个配置就失效了，下次如果想使用这个配置，你必须重新配置。</p>
<h3 id="进入Hive的CLI客户端设置参数"><a href="#进入Hive的CLI客户端设置参数" class="headerlink" title="进入Hive的CLI客户端设置参数"></a>进入Hive的CLI客户端设置参数</h3><p>当我们已经进入了CLI里面，可以使用<code>set</code>关键字来设置参数，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>hive <span class="keyword">set</span> mapreduce.job.queuename<span class="operator">=</span>queue1;</span><br></pre></td></tr></table></figure>
<p>这个和上一种方式差不多，效果也是一样，一旦退出CLI客户端，也会失效，但是和方法二有一个不同的地方是，如果set后面只跟参数名而不带参数值，就可以查看这个参数目前的值，像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>hive <span class="keyword">set</span> mapreduce.job.queuename;</span><br><span class="line">mapreduce.job.queuename<span class="operator">=</span>queue1</span><br></pre></td></tr></table></figure>
<p>如果set后面连参数名都不跟，那么就可以查看整个Hive的所有配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>hive <span class="keyword">set</span>;</span><br><span class="line">datanucleus.autoCreateSchema<span class="operator">=</span><span class="literal">true</span></span><br><span class="line">datanucleus.autoStartMechanismMode<span class="operator">=</span>checked</span><br><span class="line">datanucleus.cache.level2<span class="operator">=</span><span class="literal">false</span></span><br><span class="line">datanucleus.cache.level2.type<span class="operator">=</span><span class="keyword">none</span></span><br><span class="line">datanucleus.connectionPoolingType<span class="operator">=</span>DBCP</span><br><span class="line">datanucleus.identifierFactory<span class="operator">=</span>datanucleus</span><br><span class="line">datanucleus.plugin.pluginRegistryBundleCheck<span class="operator">=</span>LOG</span><br><span class="line">datanucleus.storeManagerType<span class="operator">=</span>rdbms</span><br><span class="line">datanucleus.transactionIsolation<span class="operator">=</span>read<span class="operator">-</span>committed</span><br></pre></td></tr></table></figure>
<p>上面介绍的这三种参数设置方式的优先级类似于编程语言里的变量声明，即本地变量会覆盖全局变量，优先级是依此递增的</p>
<h2 id="常用Hive配置"><a href="#常用Hive配置" class="headerlink" title="常用Hive配置"></a>常用Hive配置</h2><p>注意，这些设置里面没有双引号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置job名</span><br><span class="line"><span class="keyword">set</span> mapred.job.name<span class="operator">=</span>这是一个测试;</span><br><span class="line"># 设置job执行队列名</span><br><span class="line"><span class="keyword">set</span> mapred.job.queue.name<span class="operator">=</span>root.tcop;</span><br><span class="line"># 设定reduce内存大小,单位M</span><br><span class="line"><span class="keyword">set</span> mapreduce.reduce.memory.mb<span class="operator">=</span><span class="number">8048</span>;</span><br><span class="line"><span class="keyword">set</span> mapred.child.reduce.java.opts<span class="operator">=</span><span class="operator">-</span>Xmx8048M;</span><br><span class="line"><span class="keyword">set</span> mapreduce.reduce.java.opts<span class="operator">=</span><span class="operator">-</span>Xmx8048M;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 逻辑运算,函数</title>
    <url>/2015/11/05/Hive-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>Hive自身提供了逻辑运算以及数学上的一些函数,基本和mysql<br>里差不多.简单的不再多说了，只记录一些常用的</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Hive自带的函数非常多,大致分为一下几块介绍,详细信息在<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF">Hive Wiki官网</a></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table>
<thead>
<tr>
<th>返回类型</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bigint</td>
<td>round(double a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>double</td>
<td>round(double a, int d)</td>
<td>小数部分d位之后数字四舍五入</td>
</tr>
<tr>
<td>bigint</td>
<td>floor(double a)</td>
<td>对给定数据进行向下舍入最接近的整数</td>
</tr>
<tr>
<td>bigint</td>
<td>ceil(double a)<br>ceiling(double a)</td>
<td>将参数向上舍入为最接近的整数</td>
</tr>
<tr>
<td>double</td>
<td>rand()<br>rand(int seed)</td>
<td>返回大于或等于0且小于1的平均分布随机数（依重新计算而变）</td>
</tr>
<tr>
<td>double</td>
<td>pow(double a, double p)<br>power(double a, double p)</td>
<td>返回某数的乘幂</td>
</tr>
<tr>
<td>double</td>
<td>sqrt(double a)</td>
<td>返回数值的平方根</td>
</tr>
<tr>
<td>int<br>double</td>
<td>positive(int a)<br>positive(double a)</td>
<td>返回A的值</td>
</tr>
<tr>
<td>int<br>double</td>
<td>negative(int a)<br>negative(double a)</td>
<td>返回A的相反数</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>返回类型</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>from_unixtime(bigint unixtime[, string format])</td>
<td>UNIX_TIMESTAMP参数表示返回一个值’YYYY- MM – DD HH：MM：SS’或YYYYMMDDHHMMSS.uuuuuu格式，这取决于是否是在一个字符串或数字语境中使用的功能。该值表示在当前的时区。</td>
</tr>
<tr>
<td>bigint</td>
<td>unix_timestamp()</td>
<td>如果不带参数的调用，返回一个Unix时间戳（从’1970-01–0100:00:00′到现在的UTC秒数）为无符号整数。</td>
</tr>
<tr>
<td>bigint</td>
<td>unix_timestamp(string date)</td>
<td>指定日期参数调用UNIX_TIMESTAMP（），它返回参数值’1970- 01 – 0100:00:00′到指定日期的秒数。</td>
</tr>
<tr>
<td>bigint</td>
<td>unix_timestamp(string date, string pattern)</td>
<td>指定时间输入格式，返回到1970年秒数：unix_timestamp(’2009-03-20′, ‘yyyy-MM-dd’) &#x3D; 1237532400</td>
</tr>
<tr>
<td>string</td>
<td>to_date(string timestamp)</td>
<td>返回时间中的年月日： to_date(“1970-01-01 00:00:00″) &#x3D; “1970-01-01″</td>
</tr>
<tr>
<td>string</td>
<td>to_dates(string date)</td>
<td>给定一个日期date，返回一个天数（0年以来的天数）</td>
</tr>
<tr>
<td>int</td>
<td>year(string date)</td>
<td>返回指定时间的年份</td>
</tr>
<tr>
<td>int</td>
<td>month(string date)</td>
<td>返回指定时间的月份</td>
</tr>
<tr>
<td>int</td>
<td>day(string date)</td>
<td>dayofmonth(date) 返回指定时间的日期</td>
</tr>
<tr>
<td>int</td>
<td>hour(string date)</td>
<td>返回指定时间的小时，范围为0到23。</td>
</tr>
<tr>
<td>int</td>
<td>minute(string date)</td>
<td>返回指定时间的分钟，范围为0到59。</td>
</tr>
<tr>
<td>int</td>
<td>second(string date)</td>
<td>返回指定时间的秒，范围为0到59。</td>
</tr>
<tr>
<td>int</td>
<td>weekofyear(string date)</td>
<td>返回指定日期所在一年中的星期号，范围为0到53。</td>
</tr>
<tr>
<td>int</td>
<td>datediff(string enddate, string startdate)</td>
<td>两个时间参数的日期之差。</td>
</tr>
<tr>
<td>int</td>
<td>date_add(string startdate, int days)</td>
<td>给定时间，在此基础上加上指定的时间段。</td>
</tr>
<tr>
<td>int</td>
<td>date_sub(string startdate, int days)</td>
<td>给定时间，在此基础上减去指定的时间段。</td>
</tr>
</tbody></table>
<p><strong>NOTE:<strong>所以想把一个</strong>20160302</strong>转换成<strong>2016-03-02</strong>这种时间格式，要么用**strsub()<strong>配合</strong>concat()**来实现，或者就使用<code>from_unixtime(unix_timestamp(create_time, &#39;yyyyMMdd&#39;), &#39;yyyy-MM-dd)</code></p>
<h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><table>
<thead>
<tr>
<th>返回类型</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>length(string A)</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>string</td>
<td>reverse(string A)</td>
<td>返回倒序字符串</td>
</tr>
<tr>
<td>string</td>
<td>concat(string A, string B…)</td>
<td>连接多个字符串，合并为一个字符串，可以接受任意数量的输入字符串</td>
</tr>
<tr>
<td>string</td>
<td>concat_ws(string SEP, string A, string B…)</td>
<td>链接多个字符串，字符串之间以指定的分隔符分开。</td>
</tr>
<tr>
<td>string</td>
<td>substr(string A, int start, int len)<br>substring(string A, int start, int len)</td>
<td>从文本字符串中指定的位置指定长度的字符。</td>
</tr>
<tr>
<td>string</td>
<td>upper(string A)<br>ucase(string A)</td>
<td>将文本字符串转换成字母全部大写形式</td>
</tr>
<tr>
<td>string</td>
<td>lower(string A)<br>lcase(string A)</td>
<td>将文本字符串转换成字母全部小写形式</td>
</tr>
<tr>
<td>string</td>
<td>trim(string A)</td>
<td>删除字符串两端的空格，字符之间的空格保留</td>
</tr>
<tr>
<td>string</td>
<td>ltrim(string A)</td>
<td>删除字符串左边的空格，其他的空格保留</td>
</tr>
<tr>
<td>string</td>
<td>rtrim(string A)</td>
<td>删除字符串右边的空格，其他的空格保留</td>
</tr>
<tr>
<td>string</td>
<td>regexp_replace(string A, string B, string C)</td>
<td>字符串A中的B字符被C字符替代</td>
</tr>
<tr>
<td>string</td>
<td>regexp_extract(string subject, string pattern, int index)</td>
<td>通过下标返回正则表达式指定的部分。需要注意的是：原来的<code>\</code> 转义，这里变成了双斜杠了<code>\\</code>,所以对于<code>[,&#123;</code>这些特殊字符，需要注意使用两个斜杠，包括原来的正则表达式，如果是<code>\d</code>匹配数字，就需要使用<code>\\d</code></td>
</tr>
<tr>
<td>string</td>
<td>parse_url(string urlString, string partToExtract [, string keyToExtract])</td>
<td>返回URL指定的部分。parse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&k2=v2#Ref1%E2%80%B2">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1′</a>, ‘HOST’) 返回：’facebook.com’,key处理指定为host,还可以指定为path,[query,key]</td>
</tr>
<tr>
<td>string</td>
<td>get_json_object(string json_string, string path)</td>
<td>select a.timestamp, get_json_object(a.appevents, ‘$.eventid’), get_json_object(a.appenvets, ‘$.eventname’) from log a;</td>
</tr>
<tr>
<td>string</td>
<td>space(int n)</td>
<td>返回指定数量的空格</td>
</tr>
<tr>
<td>string</td>
<td>repeat(string str, int n)</td>
<td>重复N次字符串</td>
</tr>
<tr>
<td>int</td>
<td>ascii(string str)</td>
<td>返回字符串中首字符的数字值</td>
</tr>
<tr>
<td>string</td>
<td>lpad(string str, int len, string pad)</td>
<td>返回指定长度的字符串，给定字符串长度小于指定长度时，由指定字符从左侧填补。</td>
</tr>
<tr>
<td>string</td>
<td>rpad(string str, int len, string pad)</td>
<td>返回指定长度的字符串，给定字符串长度小于指定长度时，由指定字符从右侧填补。</td>
</tr>
<tr>
<td>array</td>
<td>split(string str, string pat)</td>
<td>将字符串转换为数组。</td>
</tr>
<tr>
<td>int</td>
<td>find_in_set(string str, string strList)</td>
<td>返回字符串str第一次在strlist出现的位置。如果任一参数为NULL,返回NULL；如果第一个参数包含逗号，返回0。</td>
</tr>
<tr>
<td>array&lt;array<string>&gt;</td>
<td>sentences(string str, string lang, string locale)</td>
<td>将字符串中内容按语句分组，每个单词间以逗号分隔，最后返回数组。 例如sentences(‘Hello there! How are you?’) 返回：( (“Hello”, “there”), (“How”, “are”, “you”) )</td>
</tr>
</tbody></table>
<h3 id="内置聚合函数"><a href="#内置聚合函数" class="headerlink" title="内置聚合函数"></a>内置聚合函数</h3><p>还有一些是内置的统计函数,可以免去不少计算的步骤</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bigint</td>
<td>count(*)<br>count(expr)<br>count(DISTINCT expr[, expr_., expr_.])</td>
<td>返回记录条数。</td>
</tr>
<tr>
<td>double</td>
<td>sum(col)<br>sum(DISTINCT col)</td>
<td>求和</td>
</tr>
<tr>
<td>double</td>
<td>avg(col)<br>avg(DISTINCT col)</td>
<td>求平均值</td>
</tr>
<tr>
<td>double</td>
<td>var_pop(col)</td>
<td>返回指定列的方差</td>
</tr>
<tr>
<td>double</td>
<td>var_samp(col)</td>
<td>返回指定列的样本方差</td>
</tr>
<tr>
<td>double</td>
<td>stddev_pop(col)</td>
<td>返回指定列的偏差</td>
</tr>
<tr>
<td>double</td>
<td>stddev_samp(col)</td>
<td>返回指定列的样本偏差</td>
</tr>
<tr>
<td>double</td>
<td>covar_pop(col1, col2)</td>
<td>两列数值协方差</td>
</tr>
<tr>
<td>double</td>
<td>covar_samp(col1, col2)</td>
<td>两列数值样本协方差</td>
</tr>
<tr>
<td>double</td>
<td>corr(col1, col2)</td>
<td>返回两列数值的相关系数</td>
</tr>
<tr>
<td>double</td>
<td>percentile(col, p)</td>
<td>返回数值区域的百分比数值点。0&lt;&#x3D;P&lt;&#x3D;1,否则返回NULL,不支持浮点型数值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>SQL</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA编译报错unescaped  at end of component</title>
    <url>/2017/03/17/IDEA%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99unescaped-at-end-of-component/</url>
    <content><![CDATA[<p>刚接手个项目，从代码仓库里面直接clone下来,在idea里面运行的时候报错，但是直接在命令行用<code>maven</code>打包又没啥问题。所以我猜想这个错误应该只和idea这个ide有关,网上查了一圈发现并没有什么收获,后来参考一个正确的项目的结构配置把问题解决了,在这里记录一下.</p>
<p>问题特征就是几乎每一个类都会报标题那个错误，而且打开几个java文件,发现一片红,但是idea里面的以来显示jar包都导入了,但是就是无法识别,引入不了,直接打包没啥问题，但是想在Idea里面通过Tomcat里面来启动就会报错,最后也是查了很多资料没解决，在同事的帮助下解决了这个问题。</p>
<p>主要分两步</p>
<ul>
<li>项目结构不对</li>
</ul>
<p>每一个Spring工程必须在Idea里面配置正确，不然有些路径的文件或者包可能读取不到，具体的看<code>Project Structure</code>里面的配置,可以找个正确的项目可以运行的参考参考,需要注意的地方是:</p>
<blockquote>
</blockquote>
<p>Modules: 这个地方的模块名和一些Source Roots还有web resource directories看看设置的有没有问题，还有Spring的配置，主要是路径这些配置</p>
<ul>
<li>打包问题</li>
</ul>
<p>在idea里面打包有两个方式，一个是选war包，另一种是选exploded,这个要在<code>Edit Configguration</code>那看,记得要选第二种方式，即exploded,这个方式和第一个方式有啥不同:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># war</span><br><span class="line">需要把这个包拷贝到tomcat服务器上，然后解压</span><br><span class="line"># exploded</span><br><span class="line">不需要拷贝解压，tomcat会直接读取我们项目的target里面的classes文件，做到调试可更新</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中配置MySQL</title>
    <url>/2015/10/06/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AEMySQL/</url>
    <content><![CDATA[<h3 id="首先在终端中安装"><a href="#首先在终端中安装" class="headerlink" title="首先在终端中安装"></a>首先在终端中安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>

<p>安装中途会要求输入密码，直接输入就可以了。<br>等待安装完成就可以登录了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ mysql -uroot -p+yourpassword</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 假设你的密码是<code>123456</code>，那么最后就是<code>-p123456</code>。</p>
<h3 id="在IDEA中配置MySQL"><a href="#在IDEA中配置MySQL" class="headerlink" title="在IDEA中配置MySQL"></a>在IDEA中配置MySQL</h3><p>在<code>View-&gt;Tool Windows-&gt;DataBase</code>，打开数据库配置窗口<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_IDE%E5%92%8CMySQL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE01.png" alt="数据库配置窗口"><br>点<code>+</code>号，<code>Data Source</code>选择<code>MySQL</code>配置添加，填上自己的用户名和密码，注意第一次添加需要下载驱动<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_IDE%E5%92%8CMySQL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE02.png" alt="数据库连接配置">即<code>Driver files</code>里会提示你下载。<br>在<code>0 tables 0 procedures下</code>面有红色的提示，点击<code>download</code>就可以下载了，下载好了，点<code>Test Connection</code><br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_IDE%E5%92%8CMySQL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE03.png" alt="测试数据库连接"><br>出现这个就说明成功了，记得上面没有配置<code>Database</code>。<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_IDE%E5%92%8CMySQL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE04.png" alt="数据库控制台"><br>最终效果就是这样，可以直接写<code>SQL</code>语句，然后执行。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>SQL</tag>
        <tag>IDEA</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive get_json_object用法</title>
    <url>/2015/11/05/Hive-get-json-object%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>数据库中存放的json串,有时候需要对某个元素判断来查询结果,非常笨的一个方法就是直接把查询结果的字符串做模糊查询,即<code>like &#39;%str%&#39;</code>,当一个json串非常长的时候,本来效率就很慢,况且是在hadoop海量数据里查找,其实我们并不需要那些其他的字符串,只是需要某个元素的值而已,这个时候就需要用到Hive的字符函数<code>get_json_object()</code>函数.</p>
<h3 id="get-json-object-函数"><a href="#get-json-object-函数" class="headerlink" title="get_json_object()函数"></a>get_json_object()函数</h3><p>函数用法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_json_object(string json_string, string path)</span><br></pre></td></tr></table></figure>
<p>具体看一个例子,数据库test定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id                  	int                 	自增id</span><br><span class="line">content                	string              	内容	</span><br></pre></td></tr></table></figure>
<p>其中content是个json串,内容如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;person&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>查询一下看看结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> get_json_object(content,<span class="string">&#x27;$.status&#x27;</span>) from <span class="built_in">test</span> <span class="built_in">limit</span> 1;</span><br><span class="line">OK</span><br><span class="line">&#123;<span class="string">&quot;person&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="literal">false</span>&#125;&#125;</span><br><span class="line">Time taken: 0.066 seconds, Fetched: 1 row(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> get_json_object(content,<span class="string">&#x27;$.status.person&#x27;</span>) from <span class="built_in">test</span> <span class="built_in">limit</span> 1;</span><br><span class="line">OK</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="literal">false</span>&#125;</span><br><span class="line">Time taken: 0.081 seconds, Fetched: 1 row(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> get_json_object(content,<span class="string">&#x27;$.status.person.name&#x27;</span>) from <span class="built_in">test</span> <span class="built_in">limit</span> 1;</span><br><span class="line">OK</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">Time taken: 0.077 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<p>**注意:**如果要判断<code>name</code>的值,这个值并不是布尔型,而是一个string,所以需要加上<code>&#39;&#39;</code>,像下面这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>,content from <span class="built_in">test</span> <span class="built_in">where</span> get_json_object(content,<span class="string">&#x27;$.status.person.name&#x27;</span>)=<span class="string">&#x27;false&#x27;</span> <span class="built_in">limit</span> 2;</span><br><span class="line">OK</span><br><span class="line">7	&#123;.status<span class="string">&quot;:&#123;&quot;</span>person<span class="string">&quot;:&#123;&quot;</span>name<span class="string">&quot;:false&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">31	&#123;.status&quot;</span>:&#123;<span class="string">&quot;person&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="literal">false</span>&#125;&#125;&#125;</span><br><span class="line">Time taken: 0.085 seco	nds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hive笔记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>SQL</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>IllegalAccessError HBaseZeroCopyByteString</title>
    <url>/2019/02/22/IllegalAccessError-HBaseZeroCopyByteString/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近有个Flink实时作业写HBase的任务发现丢数据了，Flink平台和HBase运维也无法定位到具体的问题，也没有任何异常日志。没办法只能通过把HBase数据导出到离线Hadoop集群来分析。<br>一开始怀疑MQ没有采集到日志，后来通过把Kafka日志拉取到HDFS查询发现数据是有的，那问题就只可能是在计算过程中丢失了。万幸实时采集的数据都有落HDFS，所以想离线分析一波，首先让运维<br>给HBase打了一个快照，然后给了个MR代码让我自己解析数据结构。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>其实代码很简单，就是解析Cell把值解析出来然后写到HDFS路径上,需要用到的包也不多,pom.xml文件如下:<br>&#96;&#96;结构。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>其实代码很简单，就是解析Cell把值解析出来然后写到HDFS路径上,需要用到的包也不多,pom.xml文件如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hbase.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-protocol<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hbase.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hbase.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hbase.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体的版本根据你的集群而定，然后就是解析程序了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBase2HDFSApp</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(HBase2HDFSApp.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *      * 需要传入的参数：快照名字，解析之后输出路径，快照输入路径，临时路径</span></span><br><span class="line"><span class="comment">     *      * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     *      * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Parameter Errors ! Usage : &lt;snapshot_name&gt; &lt;output_path&gt; &lt;input_path&gt; &lt;tmp_output_path&gt;&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">snapShotName</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Path</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.rootdir&quot;</span>, <span class="string">&quot;hdfs://&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">        configuration.set(<span class="string">&quot;mapreduce.job.queuename&quot;</span>, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;hadoop.tmp.dir&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> HBase2HDFSApp.class.getSimpleName();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(configuration, jobName);</span><br><span class="line">        job.setJarByClass(HBase2HDFSApp.class);</span><br><span class="line">        LOG.info(<span class="string">&quot;start to init&quot;</span>);</span><br><span class="line">        TableMapReduceUtil.initTableSnapshotMapperJob(snapShotName,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Scan</span>(),</span><br><span class="line">                HBase2HDFSMapper.class,</span><br><span class="line">                Text.class,</span><br><span class="line">                NullWritable.class,</span><br><span class="line">                job, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">3</span>]));</span><br><span class="line">        LOG.info(<span class="string">&quot;init success&quot;</span>);</span><br><span class="line">        outputPath.getFileSystem(configuration).delete(outputPath, <span class="literal">true</span>);</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputPath);</span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">        job.setNumReduceTasks(<span class="number">0</span>);<span class="comment">//没有reduce</span></span><br><span class="line">        job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HBase2HDFSMapper</span> <span class="keyword">extends</span> <span class="title class_">TableMapper</span>&lt;Text, NullWritable&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(ImmutableBytesWritable key, Result rs, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">byte</span>[] keyBytes = key.get();</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(keyBytes);</span><br><span class="line">            List&lt;Cell&gt; list = rs.listCells();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                <span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                value.put(<span class="keyword">new</span> <span class="title class_">String</span>(CellUtil.cloneQualifier(cell)), <span class="keyword">new</span> <span class="title class_">String</span>(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(rk + <span class="string">&quot;\t&quot;</span> + value.toJSONString()), NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**NOTE:**需要注意的是<code>&lt;output_path&gt;和&lt;tmp_output_path&gt;</code>根目录要一致,然后就是不能使<code>&lt;input_path&gt;</code>的子目录.<br>编译打包之后提交运行，注意打包需要用到<code>assembly</code>插件,对应的<code>pom.xml</code>配置为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt; &lt;!-- bind to the packaging phase --&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;`配置为:</span><br></pre></td></tr></table></figure>
<p>然后打包之后运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop jar ./target/xxx-1.0.0-SNAPSHOT-jar-with-dependencies.jar com.xxx.HBase2HDFSApp \</span><br><span class="line">&lt;snapshot_name&gt; \</span><br><span class="line">&lt;output_path&gt; \</span><br><span class="line">&lt;input_path&gt; \</span><br><span class="line">&lt;tmp-output_path&gt;</span><br></pre></td></tr></table></figure>
<p>然后就出现了一个经典的错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalAccessError: class com.google.protobuf.HBaseZeroCopyByteString cannot access its superclass com.google.protobuf.LiteralByteString</span><br><span class="line">        at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">        xxxx</span><br></pre></td></tr></table></figure>

<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>google了一下,找到这个问题的解决方法,详细见链接: <a href="http://www.voidcn.com/article/p-hhmhpejc-bh.html">http://www.voidcn.com/article/p-hhmhpejc-bh.html</a>. 大概就是引入了一个优化措施导致的,<br>这个问题的发生是由于优化了<a href="https://issues.apache.org/jira/browse/HBASE-9867">HBASE-9867</a>引起的，无意间引进了一个依赖类加载器。它影响使用-libjars参数和使用 fat jar两种模式的job.<br>fat jar模式Hadoop的一个特殊功能：可以读取操作目录中&#x2F;lib目录下包含的所有库的JAR文件，把运行job依赖的jar放在jar中的lib目录下。</p>
<p>解决方式也比较简单:</p>
<ol>
<li>把缺的这个包拷贝到hadoop lib目录</li>
<li>环境变量中导入这个缺失的包</li>
</ol>
<p>由于我是临时跑一次，而且hadoop环境是公用的，直接破坏了不好，就采用的临时方案.首先定位到<code>com.google.protobuf.HBaseZeroCopyByteString</code>位于<code>hive-server</code>包中，具体对应的jar包是</p>
<blockquote>
<p>hbase-protocol-0.98.21-hadoop2-xxxx.jar</p>
</blockquote>
<p>具体的版本看你们公司集群编译之后对应的包版本即可,然后调整运行命令为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_CLASSPATH=xxxx/hbase-protocol-0.98.21-hadoop2-xxx.jar</span><br><span class="line">hadoop jar ./target/xxx-1.0.0-SNAPSHOT-jar-with-dependencies.jar com.xxx.HBase2HDFSApp \</span><br><span class="line">&lt;snapshot_name&gt; \</span><br><span class="line">&lt;output_path&gt; \</span><br><span class="line">&lt;input_path&gt; \</span><br><span class="line">&lt;tmp-output_path&gt;</span><br></pre></td></tr></table></figure>
<p>然后运行就行了，大工告成。</p>
]]></content>
      <categories>
        <category>数据架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hadoop</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka摸鱼系列01-百万QPS吞吐量</title>
    <url>/2018/08/22/Kafka%E6%91%B8%E9%B1%BC%E7%B3%BB%E5%88%9701-%E7%99%BE%E4%B8%87QPS%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近打算写一下关于<code>Kafka</code>系列的文章，在整个数据体系中,<code>Kafka</code>扮演着一个非常重要的角色-<strong>数据总线</strong>.作为一个数据开发工程师,在数据的采集&#x2F;存储&#x2F;流计算&#x2F;ETL&#x2F;数据仓库&#x2F;数据应用这几个方面,<code>Kafka</code>起到的作用是非常大的,甚至会影响到其他组建或者环节的技术选型.<br>在很久以前,在<code>Kafka</code>还没那么成熟的时候,很多的数据基础组件在设计之初并没有考虑到数据接收&#x2F;数据输出解藕,以及数据容灾式持久化,往往都需要配合第三方或者额外开发其他的组件去保证数据的吞吐量以及可靠性,例如<code>sqoop</code>,<code>canal</code>.不过这个都不是本文的重点,本文的重点在于:为何现在很多公司都把<code>Kafka</code>作为整个数据链路的<strong>数据总线</strong>,这里很关键的一点是–<strong>吞吐量</strong>.</p>
<h2 id="常用MQ介绍"><a href="#常用MQ介绍" class="headerlink" title="常用MQ介绍"></a>常用MQ介绍</h2><p>这里我不会对其他MQ做过多的介绍，但是市面上的主流MQ也必须有个大概的了解，之所以流行开来也是有其独特的优势,<code>Kafka</code>也不例外,先放一张<a href="https://yq.aliyun.com/articles/62834">阿里云栖社区</a>做的MQ对比图:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Kafka%E6%91%B8%E9%B1%BC%E7%B3%BB%E5%88%9701-%E7%99%BE%E4%B8%87QPS%E5%90%9E%E5%90%90%E9%87%8F01.png" alt="业界主流MQ对比"><br>主要看下吞吐量这个地方,除了和<code>RocketMQ</code>领先的不多，基本上是碾压其他的<code>MQ</code>.一般性能好的<code>MQ</code>吞度量能达到几十万这个量级就非常厉害了,但是可以看到用机械磁盘的<code>Kafka</code>单机<code>TPS</code>差不多可以到200w了,那么对于一个集群而言,几百万的<code>TPS</code>完全不在话下.</p>
<p><strong>这就引出了本文要讨论的一个重要问题:<code>Kafka</code>为什么这么快,吞吐量为何这么惊人?</strong></p>
<h2 id="Kafka吞吐量之谜"><a href="#Kafka吞吐量之谜" class="headerlink" title="Kafka吞吐量之谜"></a>Kafka吞吐量之谜</h2><p>这个问题要想回答的好或者说回到的全面，其实并不简单.一个系统设计的这么好,往往是多方面综合考虑的结果,当然在剖析<code>Kafka</code>性能之前，先大概说一下实际使用情况下<code>Kafka</code>性能是否真的如网上说的那么优秀．因为目前BU内部的Kafka是由自己维护,所以规模不是很大,但也支撑了整个BU所有的日常数据业务.</p>
<h3 id="线上规模"><a href="#线上规模" class="headerlink" title="线上规模"></a>线上规模</h3><p>集群| 版本 | CPU | 内存 | 磁盘 | 网卡   | brokers数量<br>—–|—–|——|——|——–|——–<br>1| 0.8.2.1 | 32核| 64G |2T  |    10Gbps | 5<br>2| 1.0.0 | 32核| 64G |2T  |    10Gbps | 5<br>3| 0.10.2.1 | 32核| 128G |2T  |    1Gbps | 3</p>
<p>目前主要数据在<code>0.8.2.1</code>,这个集群使用了大概有3年了,一直很稳定,也承载了几乎所有的数据,可以注意到两个上面的机器其实对配置要求不是很高,但是对磁盘(机械磁盘,T级别)和网卡(万兆)要求会稍微高一些.从这里可以看出,<code>Kafka</code>的性能瓶颈一般在磁盘和网卡.对CPU和内存的要求其实不是很高.实际使用也确实是,最开始本来也是千兆网卡,后来发现<code>brokers</code>节点容易出现网卡被打满,性能上不去的情况.还有就是磁盘有时候会不够用．</p>
<p>下面来说一一介绍一下,为啥<code>Kafka</code>吞吐量能做到这么高.</p>
<h3 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h3><p>单机写入能到百万级别,并且还是廉价的磁盘.要知道读&#x2F;写机械磁盘,寻址操作是一个很耗时的IO操作,这也就是为什么现在的DB或者像ES这样的存储系统都慢慢换成SSD了．<br>那<code>Kafka</code>是怎么做的呢,它在设计之初的一个目标就是:</p>
<blockquote>
<p>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能.</p>
</blockquote>
<p>所以<code>Kafka</code>一开始便被设计成一个日志系统,消息只能<code>append</code>,这使得<code>Kafka</code>非常适合用来作为数据总线,所有的数据根据到来的顺序被顺序序列化到文件末尾,然后消费者也是按顺序消费.<br>实际测试使用中,顺序读写机械磁盘有时候比随机读写内存的吞吐量还要好.当然这个还归功于CPU的工作方式,在加载数据的时候,CPU会预测，连带读取一整块数据,下次读取如果命中,就直接从内存中读,也不用再去加载.</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息的写入主要由<code>producer</code>完成,首先简单说下<code>Kafka</code>的消息结构,每一个主题<code>topic</code>的消息有多个<code>partition</code>组成,每个<code>partition</code>都会有<code>leader</code>,<code>follower</code>.这里强调一下,不管是<code>producer</code>写数据还是<code>consumer</code>读数据,都是跟<code>leader</code>打交到,<code>follower</code>只负责从对应的<code>leader</code>同步数据.<code>follower</code>和<code>leader</code>一起构成了这个<code>partition</code>的<code>ISR</code>(同步复制队列),如果<code>follower</code>复制没有跟上,会被从<code>ISR</code>中剔除.所以只有当<code>leader</code>节点挂掉的时候,<code>ISR</code>中的<code>follower</code>节点才有可能备胎转正,数据的读写有新的<code>leader</code>节点负责.<br>所以说到写数据,就必须要说到<code>Kafka</code>的<code>Ack</code>机制.有时候性能和可靠性本身就是矛盾的,<code>Kafka</code>发送数据光快还不行,还得保证可靠性.<br>Ack机制</p>
<ol>
<li>0:表示producer无需等待leader的确认，</li>
<li>1:代表需要leader确认写入它的本地log并立即确认，</li>
<li>-1:代表所有的备份都完成后确认</li>
</ol>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>中间件</tag>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux chown命令</title>
    <url>/2015/11/25/Linux-chown%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>chown</code>将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 </p>
<p><strong>使用语法</strong></p>
<blockquote>
<p>chown [选项]… [所有者][:[组]] 文件…</p>
</blockquote>
<p>必要参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c	显示更改的部分的信息</span><br><span class="line">-f	忽略错误信息</span><br><span class="line">-h	修复符号链接</span><br><span class="line">-R	处理指定目录以及其子目录下的所有文件</span><br><span class="line">-v	显示详细的处理信息</span><br><span class="line">-deference	作用于符号链接的指向，而不是链接文件本身</span><br></pre></td></tr></table></figure>
<p>常用的操作就是修改某个文件夹及其子文件夹下所有文件,使其权限为某一个组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R <span class="built_in">test</span>:root temp/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 传输文件-nc+pv</title>
    <url>/2018/05/13/Linux-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-nc-pv/</url>
    <content><![CDATA[<p>做数据的写代码多了,会经常碰到传输文件的需求,之前还好，一般是下载文件,直接用python内置的server起个服务就搞定了.但是对于跨机房有防火墙存在的情况，一般数据是单向的，就是假设(A–&gt;B)A作为HTTPServer,B可以下载文件.但是反过来就不好使了，因为防火墙策略没有开,(B–&gt;A)用B作为HTTPServer,A无法访问到服务.所以这个时候,A仍然得作为服务端,主要有两种不同的方式.</p>
<ul>
<li>nc传输文件</li>
</ul>
<p>1.Data Transfer模式:A(sender&#x2F;client)-&gt;B(receiver&#x2F;server)<br>数据Transfer模式简单来说就是在家等着收数据，可以理解为被动模式.所以<code>receiver</code>监听的是本机的端口,然后等着<code>sender</code>会把数据发送到这个地方.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A(sender): tar -zcvf - file/directory | nc &#123;B_IP&#125; 12345</span><br><span class="line">B(receiver): nc -l 12345 | sudo tar -zxvf -</span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong><code>receiver</code>端先启动,然后启动<code>sender</code>发送数据.如果是想<code>B-&gt;A</code>传输,对调一下就行,注意服务的开启顺序。不管是哪种情况，要确保<code>send</code>对<code>receiver</code>的网络是通的，即数据可以发送到接收端。验证方式也比较简单，可以在接收端运行<code>python -m SimpleHTTPServer 12345</code>,然后在发送端执行<code>telnet &#123;B_IP&#125; 12345</code>。</p>
<p>2.Data Take模式:A(sender&#x2F;server)-&gt;B(receiver&#x2F;client)<br>数据的Take模式和Transfer有一点不大一样,可以理解为主动模式.就是你得自己去指定机器上主动取数据.所以<code>sender</code>会把数据发送到本机指定端口,<code>receiver</code>从指定机器以及端口获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A(sender): nc -l 12345 &lt; file/directory</span><br><span class="line">B(receiver): nc &#123;A_IP&#125; 12345 &gt; file/directory</span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong><code>sender</code>端先启动,然后启动<code>receiver</code>接收数据.注意和第一种方式区分</p>
<p>上面两种传输方式虽然有一点不大一样,不过有一个共同点就是:<code>server</code>一定要先启动,然后才是<code>client</code>端才启动.但是不管是哪种方式，只要记住一点,就是<code>client</code>对<code>server</code>提供服务端<code>port</code>一定是通的,比如说本机可以访问服务器指定端口的服务,但是服务器就无法访问本机指定端口服务，所以不管是想从服务器拷贝数据还是发送数据到服务器,服务器只能是<code>server</code>.</p>
<ul>
<li>配合pv使用</li>
</ul>
<p>pv我就不介绍是啥了,这个小工具也非常的好用,因为一般传输大文件的时候，我们希望看到传输进度啊,速度啊之类的,还有一个很重要的功能就是限速,尤其是专线跨机房问题.<br>A:pv -p -r -L 10m heap.bin | nc -l 9099<br>B:nc {A_IP} 9099 &gt; heap.bin<br>常用参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p, --progress           show progress bar</span><br><span class="line">-r, --rate               show data transfer rate counter</span><br><span class="line">-L, --rate-limit RATE    limit transfer to RATE bytes per second</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 作业管理</title>
    <url>/2015/11/26/Linux-%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>经常在服务器上登陆,操作,有些命令一旦执行,就一直在屏幕上输出内容,如果想切换到终端去干其他的事,新手通常是直接<code>Ctrl+c</code>强制删除任务,然后再回来重新执行.其实完全没这个必要,我们可以把任务切换到后台挂起,然后去干我们自己的事情,干完了之后再切回来,继续执行之前没执行完的任务就行了,听上去是不是像操作系统的进程和线程调度,下面是一些常用的Shell作业管理命令.</p>
<h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><ol>
<li><p>将<strong>当前</strong>作业放到后台<strong>暂停</strong>:<code>Ctrl+z</code></p>
</li>
<li><p>观察当前前后台作业状态:<code>jobs</code></p>
<blockquote>
</blockquote>
<p>-l	除了列出作业号之外同时列出PID<br>-r	列出仅在后台运行(run)的作业<br>-s	仅列出暂停的作业</p>
</li>
<li><p>将后台作业拿到前台处理:<code>fg</code></p>
<blockquote>
<p>fg %jobnumber (%可有可无)</p>
</blockquote>
</li>
<li><p>让作业在后台运行:<code>bg</code></p>
<blockquote>
<p>Ctrl+z让当前作业到后台去暂停,bg作业号就可以在后台run</p>
</blockquote>
</li>
<li><p>管理后台作业:<code>kill</code><br>前面讲的都是把作业放到后台,或者切换到前台,要么挂起,要么执行.如果要删除作业或者重启作业,需要给作业发送特定信号<br><code>kill -signal %jobnumber</code></p>
<blockquote>
</blockquote>
<p>-l	列出当前kill能够使用的信号<br>signal	表示给后台作业什么指示,用man 7 signal可知<br>-1	重新读取一次参数的设置文件,类似 reload<br>-2	表示与由键盘输入Ctrl+c同样的作用<br>-9	立刻强制删除一个作业<br>-15	以正常方式终止一项作业,与-9不一样</p>
</li>
</ol>
<h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><p>有些程序没办法通过应用图标运行,只能调用脚本运行,并且一堆输出日志,当你在服务器上使用<code>Vim</code>编辑一个文件时,想去运行一个脚本,可以先保存<code>Vim</code>内容,然后把<code>Vim</code>切换到后台挂起,去执行脚本之后再且回来继续编辑<code>Vim</code>.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 报错cannot open shared object file解决方案.md</title>
    <url>/2016/07/08/Linux-%E6%8A%A5%E9%94%99cannot-open-shared-object-file%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-md/</url>
    <content><![CDATA[<p>在使用Ubuntu安装软件之后，启动软件有时候会出现软件一直在闪，但是最后无法进入软件启动界面，这种时候，需要在终端中运行，这个时候一般会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libgstreamer-0.10.so.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>借助<code>apt-file</code>命令可以查找缺少包所依赖的linux文件, 然后用<code>apt-get install</code>安装所对应的文件</p>
<p>我的系统是<code>Ubuntu 16.04</code>，下面的操作都是在此系统上进行的操作:</p>
<ul>
<li>安装<code>apt-file</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-file -y</span><br><span class="line">sudo apt-file update</span><br></pre></td></tr></table></figure>

<ul>
<li>查找缺失库</li>
</ul>
<p>最开始的报错信息里面有关键字<code>libgstreamer-0.10.so.0</code>，这个时候就需要查找<code>libgstreamer-0.10.so.0</code>所对应的库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ apt-file search libgstreamer-0.10.so.0</span><br><span class="line">libgstreamer0.10-0: /usr/lib/x86_64-linux-gnu/libgstreamer-0.10.so.0</span><br><span class="line">libgstreamer0.10-0: /usr/lib/x86_64-linux-gnu/libgstreamer-0.10.so.0.30.0</span><br></pre></td></tr></table></figure>
<p>通过上面的命令查到对应的库是<code>libgstreamer0.10-0</code>,所以直接安装缺失的库就行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libgstreamer0.10-0 -y</span><br></pre></td></tr></table></figure>
<p>然后再重新运行程序，正常情况下应该没啥问题了，如果提示缺失其他的文件，同样的方式，直到不再报错为止.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 本地和服务器互传文件命令:scp</title>
    <url>/2015/10/27/Linux-%E6%9C%AC%E5%9C%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4-scp/</url>
    <content><![CDATA[<p>在日常工作开发中,都是登陆跳板机然后再登陆开发机或者在线服务器,有时候需要把一个本地文件上传到服务器,例如服务器缺少某个字体,通常是本地机下载字体然后上传到服务器.也有时候需要把服务器上的某个文件拷贝到本地,例如某个日志或者结果等.这个时候<code>scp</code>命令登场了.</p>
<h3 id="scp命令使用"><a href="#scp命令使用" class="headerlink" title="scp命令使用"></a>scp命令使用</h3><h4 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h4><blockquote>
<p>假设你的用户名是zhang.san<br>跳板机地址:redirector.machine.com<br>目标机器地址:target.machine.com<br>本机文件:&#x2F;home&#x2F;zhang.san&#x2F;1.txt<br>目标机器文件:&#x2F;home&#x2F;dev&#x2F;www&#x2F;log&#x2F;test.log</p>
</blockquote>
<p><strong>注意:</strong> 由于是跳板机,所以会有很多人登陆,每个人在跳板机上都有一个以自己名字命名的目录,例如<code>/home/zhang.san/</code></p>
<h4 id="本地上传到服务器"><a href="#本地上传到服务器" class="headerlink" title="本地上传到服务器"></a>本地上传到服务器</h4><ul>
<li>上传文件到跳板机</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  scp 1.txt zhang.san@redirector.machine.com:~</span><br><span class="line">Enter PASSCODE:<span class="string">&quot;此处可能要输入密码&quot;</span></span><br><span class="line">1.txt                                              100%   10     0.0KB/s   00:00    </span><br></pre></td></tr></table></figure>

<ul>
<li>登陆跳板机查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh zhang.san@redirector.machine.com</span><br><span class="line">Enter PASSCODE:<span class="string">&quot;输入密码处&quot;</span></span><br><span class="line">Last login: Tue Oct 27 19:16:47 2015 from 10.86.108.97</span><br><span class="line">[zhang.san@redirector.machine.com ~]$ <span class="built_in">ls</span></span><br><span class="line">1.txt</span><br></pre></td></tr></table></figure>
<p> 再在跳板机上进行同样的操作上传到服务器即可.</p>
<h4 id="服务器下载到本地"><a href="#服务器下载到本地" class="headerlink" title="服务器下载到本地"></a>服务器下载到本地</h4><p>在本地机器上执行下面命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp zhang.san@redirector.machine.com:1.txt ./ </span><br></pre></td></tr></table></figure>
<p>注意这个命令不是在跳板机,而是在本地机器上执行.</p>
<p>其实前面的是比较复杂的，如果单纯的只是想从服务器上上传东西，可以使用一个简单的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 端口号</span><br></pre></td></tr></table></figure>
<p>这个命令可以把执行这个命令的目录变成一个服务器的目录，可以直接用http下载,pythons服务器上一般是安装了的，没有的话就不能这么用了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 标准输出重定向到文件</title>
    <url>/2016/06/26/Linux-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>经常需要把脚本放到后台执行，但是出了问题也不知道错误出在哪，最好是把任务在前端执行输出到终端的标准输出以及标准错误输出都输出到文件，等程序出错了可以知道问题出在哪:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash test.sh &gt; data.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发环境</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Node.js安装</title>
    <url>/2015/09/29/Linux%E4%B8%8BNode-js%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="首先去官网下载Node-js"><a href="#首先去官网下载Node-js" class="headerlink" title="首先去官网下载Node.js"></a>首先去官网下载Node.js</h3><p>我的是<code>Ubuntu 14.04</code>,所以下载的是node-v4.1.1-linux-x64.tar.gz</p>
<h4 id="解压缩："><a href="#解压缩：" class="headerlink" title="解压缩："></a>解压缩：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf node-v4.1.1-linux-x64.tar.gz -C /usr/xxx/</span><br><span class="line">cd /usr/xxx</span><br><span class="line">sudo mv node-v4.1.1-linux-x64 node</span><br><span class="line">export PATH=/usr/xxx/node/bin/:$PATH</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> 记住<code>$PATH</code>前面是冒号，不是分号，之前搞错了，结果环境变量都被搞坏了，害得我又得去重新恢复环境变量，恢复方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_40</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

<h4 id="测试运行："><a href="#测试运行：" class="headerlink" title="测试运行："></a>测试运行：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#--------------------测试----------------------------</span><br><span class="line">#创建nodejs项目目录</span><br><span class="line">mkdir -p /usr/xxx/nodejs/</span><br><span class="line">#创建hello.js文件</span><br><span class="line">vi /usr/xxx/nodejs/hello.js</span><br><span class="line">#内容如下：</span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">http.createServer(function(request, response) &#123;	</span><br><span class="line">    response.writeHead(200, &#123;		</span><br><span class="line">        &quot;Content-Type&quot; : &quot;text/plain&quot; // 输出类型	</span><br><span class="line">    &#125;);	</span><br><span class="line">response.write(&quot;Hello World&quot;);// 页面输出	</span><br><span class="line">response.end();&#125;).listen(8100); // 监听端口号</span><br><span class="line">console.log(&quot;nodejs start listen 8100 port!&quot;);</span><br><span class="line">#后台运行</span><br><span class="line">node /usr/local/nodejs/hello.js &amp;</span><br><span class="line">#浏览器访问</span><br><span class="line">http://localhost:8100/</span><br></pre></td></tr></table></figure>
<p>如果看到浏览器界面输出Hello World!就表示成功了。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Web</tag>
        <tag>开发环境</tag>
        <tag>Node.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux端口被占用解决方案</title>
    <url>/2016/06/26/Linux%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>之前一直使用ss代理上google，但是最近不知道怎么回事儿，本地运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/config.json</span><br></pre></td></tr></table></figure>
<p>报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO: loading config from doc/config.json</span><br><span class="line">2016-06-26 12:34:53 INFO     loading libcrypto from libcrypto.so.1.0.0</span><br><span class="line">2016-06-26 12:34:53 INFO     starting local at 127.0.0.1:1080</span><br><span class="line">2016-06-26 12:34:53 ERROR    [Errno 98] Address already in use</span><br></pre></td></tr></table></figure>
<p>主要是找不到占用这个端口的进程，也不知道怎么把占用端口的进程杀掉,网上查了相关解决方法，总算找到解决方案:<br>首先得找到是哪个进程占用了这个端口,即找出进程的pid:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ netstat -anp | grep 1080             </span><br><span class="line">（并非所有进程都能被检测到，所有非本用户的进程信息将不会显示，如果想看到所有信息，则必须切换到 root 用户）</span><br><span class="line">tcp        0      0 0.0.0.0:1080            0.0.0.0:*               LISTEN      1955/EmbedThunderMa</span><br></pre></td></tr></table></figure>
<p>看到没，那个<code>1955</code>就是罪魁祸首,于是再通过pid查看具体是哪个进程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ps -ef | grep 1955</span><br><span class="line">anonymo+  1955  1871  0 09:47 ?        00:00:18 /opt/xware-desktop/xware/lib/EmbedThunderManager *********</span><br><span class="line">anonymo+  5621  2847  0 10:41 pts/0    00:00:00 grep --color=auto 1955</span><br></pre></td></tr></table></figure>
<p>终于找到原因,原来是前一阵子为了下东西，装了一个Linux版的迅雷，虽然最后还是没法下载，但是这东西有个服务开机自动启动，占用了我的1080端口，导致我想用没法用<br>果断卸载了坑爹的迅雷,然后把这个进程杀了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill -9 1955</span><br></pre></td></tr></table></figure>
<p>然后果然1080端口可以用了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维常用命令备忘录</title>
    <url>/2018/05/24/Linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p>作为一个后端开发,尤其是数据开发,我们很多的服务都是以进程的方式运行在后台.例如Jstorm&#x2F;Kafka&#x2F;ElasticSearch等等,线上报警处理也是一个必备技能了,更多的可能是一些磁盘,内存,CPU指标之类的,有些命令不常用可能会忘记,做个记录方便查找.</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>这个应该是最常见的,磁盘报警是家常便饭了.</p>
<h4 id="df-lh"><a href="#df-lh" class="headerlink" title="df -lh"></a>df -lh</h4><p>查看系统磁盘占用情况,一般磁盘报警了可以先用这个命令看下大概是哪个盘出问题了,找到占用比较大的磁盘有时候需要配合其他命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 到具体的目录下执行</span><br><span class="line"># 1.快速方法</span><br><span class="line">du -sh</span><br><span class="line"># 2.推荐方法(-x 可以过滤掉和一开始文件系统不一样的文件/文件系统)</span><br><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>
<p>这里不推荐第一种方式是因为效率问题，如果碰上是根<code>/</code>目录满了,基本上统计不出来,如果为了快，想配合排序定位问题,还可以配合sort函数使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 倒序排(一般占用大基本上就是看G,很少会到T,毕竟磁盘没那么大,也有例外)</span><br><span class="line">du -h --max-depth=1 | grep [TG] |sort -nr | head</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>这个命令紧跟在上一个命令后面,就是因为很多时候我们需要批量删除满足某些条件的文件,但这些文件可能并不是简单的在一个文件夹下面,类型一样.可能分散在某个目录下面的多级目录,并且类型也很多:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据文件类型来删,比如日志文件 *.log</span><br><span class="line">find . -name &#x27;*.xxx&#x27; -delete</span><br><span class="line"># or</span><br><span class="line">find . -name &#x27;*.xxx&#x27; -exec sudo rm -f &#123;&#125; \;</span><br><span class="line"># 根据时间 -mtime:内容时间 -ctime:状态修改</span><br><span class="line">find . -mtime +10 -a -ctime +10 -delete</span><br><span class="line"># 根据文件大小 &gt;100k &lt;500M</span><br><span class="line">find . -size +100k +size -500M -delete</span><br></pre></td></tr></table></figure>
<p>**NOTE:**find命令<code>-a</code>:与,<code>-or</code>:或,<code>not</code>:否.另外使用删除请慎重,可以先用<code>-print</code>打印一下看看是否满足要求,不然删了不该删的后果可能很严重.</p>
<h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>有时候磁盘满了可能是swap设置的太大,占用的swap又无法释放(内存就算有很大空闲,swap已经使用的可能也不会释放),导致磁盘一直报警,处理这个要稍微麻烦一点儿.首先看下磁盘占用比较大的几个程序,或者说看下有没有比较重要的服务占用着缓存,有的话重启下,先把重要的程序占用的swap释放掉,然后关闭缓存,开启缓存:<br>看一次实际线上问题:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          11855        2366        9146         157         341        9144</span><br><span class="line">Swap:          4095        2600        1495</span><br></pre></td></tr></table></figure>
<p>可以看到内存有很多空闲,但是swap占用了2.6G无法释放，然后统计下是哪些进程在占用着swap:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ for i in $(sudo ls /proc | grep &quot;^[0-9]&quot; | awk &#x27;$0&gt;100&#x27;); do sudo awk &#x27;/Swap:/&#123;a=a+$2&#125;END&#123;print &#x27;&quot;$i&quot;&#x27;,a/1024&quot;M&quot;&#125;&#x27; /proc/$i/smaps;done| sort -k2nr | head</span><br><span class="line">awk: fatal: cannot open file `/proc/10612/smaps&#x27; for reading (No such file or directory)</span><br><span class="line">awk: fatal: cannot open file `/proc/10613/smaps&#x27; for reading (No such file or directory)</span><br><span class="line">awk: fatal: cannot open file `/proc/10614/smaps&#x27; for reading (No such file or directory)</span><br><span class="line">awk: fatal: cannot open file `/proc/10615/smaps&#x27; for reading (No such file or directory)</span><br><span class="line">awk: fatal: cannot open file `/proc/10616/smaps&#x27; for reading (No such file or directory)</span><br><span class="line">20211 466.664M</span><br><span class="line">23994 215.438M</span><br><span class="line">9339 208.672M</span><br><span class="line">9334 167.766M</span><br><span class="line">9340 152.559M</span><br><span class="line">9338 132.375M</span><br><span class="line">20293 88.9883M</span><br><span class="line">9342 86.918M</span><br><span class="line">9335 84.4492M</span><br><span class="line">4323 76.8984M</span><br></pre></td></tr></table></figure>
<p>可以看到进程号和对应的缓存占用大小(如果不想看到错误信息,可以grep -v “No such”过滤掉),看下具体的有没有比较重要的,如果想看具体的程序,后面可以用awk切割出pid,然后配合<code>ps -p xxx</code>看下具体的进程是不是重要的，手动重启下.然后就是比较关键的两个操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭所有缓存</span><br><span class="line">swapoff -a</span><br><span class="line"># 开启所有缓存</span><br><span class="line">swapon -a</span><br></pre></td></tr></table></figure>
<p>这样swap就全部被清空了.</p>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>这个命令可能一般人用的比较少,这个主要是看文件句柄的,有时候一个文件很大，我们直接删了,但是会发现磁盘空间并没有释放.这个时候一般就是还有进程占用着这个文件句柄,所以你可能在目录里面看没有什么文件,但是磁盘就是被占用了.可以这么排查:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看文件为删除状态的文件</span><br><span class="line">lsof | grep deleted</span><br></pre></td></tr></table></figure>
<p>这个命令里面就可以看到是哪个进程持有这个文件的句柄,比如像tomcat,有时候日志打太多了,但是你直接删掉,磁盘根本不会减少,这个时候你可以重启下tomcat,就会发现文件占用的空间又回来了.</p>
<h3 id="cpu-mem"><a href="#cpu-mem" class="headerlink" title="cpu&#x2F;mem"></a>cpu&#x2F;mem</h3><p>这两个一般都是用top命令来看,所以放在一起说了.一般top之后可以看到进程的实时信息,top有一些常用参数命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c top显示带具体进程信息</span><br><span class="line">M 按mem占用排序</span><br><span class="line">P 按cpu占用排序</span><br><span class="line"># 具体线程信息</span><br><span class="line">top -H -p &#123;pid&#125;</span><br></pre></td></tr></table></figure>
<p>具体的进程问题，可能得用具体的方法,这里就不做展开了.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linxu下安装Hexo</title>
    <url>/2015/10/05/Linxu%E4%B8%8B%E5%AE%89%E8%A3%85Hexo/</url>
    <content><![CDATA[<p>为了搭建博客，需要安装hexo，但是在Ubuntu 14.04下怎么都装不上，最后改用了淘宝的源</p>
<p>首先确保你安装了node.js</p>
<h4 id="开始安装："><a href="#开始安装：" class="headerlink" title="开始安装："></a>开始安装：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> 不过这样一直装不上，最后没办法改用了<a href="https://npm.taobao.org/">taobao的npm源</a><br>使用教程也很简单，有介绍：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure>

<p>所以如果安不上，试试上面的命令，然后接着安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g  <span class="comment">#-g表示全局安装, npm默认为当前项目安装</span></span><br><span class="line">cnpm install hexo-cli -g</span><br><span class="line">cnpm install hexo --save</span><br></pre></td></tr></table></figure>

<h4 id="创建Hexo文件夹"><a href="#创建Hexo文件夹" class="headerlink" title="创建Hexo文件夹"></a>创建Hexo文件夹</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</span></span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<p>最后的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hexo  tree -L 2</span><br><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── node_modules</span><br><span class="line">│   ├── hexo</span><br><span class="line">│   ├── hexo-generator-archive</span><br><span class="line">│   ├── hexo-generator-category</span><br><span class="line">│   ├── hexo-generator-index</span><br><span class="line">│   ├── hexo-generator-tag</span><br><span class="line">│   ├── hexo-renderer-ejs</span><br><span class="line">│   ├── hexo-renderer-marked</span><br><span class="line">│   ├── hexo-renderer-stylus</span><br><span class="line">│   └── hexo-server</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   └── _posts</span><br><span class="line">└── themes</span><br><span class="line">    └── landscape</span><br><span class="line"></span><br><span class="line">15 directories, 5 files</span><br></pre></td></tr></table></figure>

<h4 id="启动服务看效果"><a href="#启动服务看效果" class="headerlink" title="启动服务看效果"></a>启动服务看效果</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后访问<code>http://localhost:4000/</code>就可以打开网站了。</p>
<h4 id="将Hexo发布到github上"><a href="#将Hexo发布到github上" class="headerlink" title="将Hexo发布到github上"></a>将<code>Hexo</code>发布到<code>github</code>上</h4><p>这里踩了很多坑，特别注意一下，因为大多数教程都是以2.x.x版本为例的，问题就在这里，3.x.<br>x的版本很不一样。所以很多教程根本不对，先看看我的环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  $  hexo -v</span><br><span class="line">hexo: 3.1.1</span><br><span class="line">os: Linux 3.13.0-32-generic linux x64</span><br><span class="line">http_parser: 2.5.0</span><br><span class="line">node: 4.1.1</span><br><span class="line">v8: 4.5.103.33</span><br><span class="line">uv: 1.7.4</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 46</span><br><span class="line">openssl: 1.0.2d</span><br></pre></td></tr></table></figure>

<p>现在我们来重新看看如何发布一个项目到之前你的<code>github</code>博客仓库里，并且直接在<code>github</code>上显示</p>
<ul>
<li>初始化一个项目</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  hexo init note    <span class="comment"># 初始化一个文件夹</span></span><br><span class="line">➜  <span class="built_in">cd</span> note            <span class="comment"># 进入到note文件夹执行生成命令</span></span><br><span class="line">➜  note  hexo generate</span><br><span class="line">ERROR Local hexo not found <span class="keyword">in</span> ~/docments/note</span><br><span class="line">ERROR Try running: <span class="string">&#x27;npm install hexo --save&#x27;</span></span><br></pre></td></tr></table></figure>

<p>忘了执行install命令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  npm install</span><br><span class="line">npm WARN optional dep failed, continuing fsevents@1.0.0</span><br><span class="line">npm WARN optional dep failed, continuing fsevents@0.3.8</span><br><span class="line"> </span><br><span class="line">&gt; dtrace-provider@0.6.0 install /home/junqiangshen/docments/note/node_modules/hexo/node_modules/bunyan/node_modules/dtrace-provider</span><br><span class="line">&gt; node scripts/install.js</span><br><span class="line"></span><br><span class="line">hexo-renderer-ejs@0.1.0 node_modules/hexo-renderer-ejs</span><br><span class="line">├── lodash@2.4.2</span><br><span class="line">└── ejs@1.0.0</span><br><span class="line"></span><br><span class="line">hexo-generator-index@0.1.3 node_modules/hexo-generator-index</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</span><br><span class="line"></span><br><span class="line">hexo-generator-tag@0.1.2 node_modules/hexo-generator-tag</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</span><br><span class="line"></span><br><span class="line">hexo-generator-category@0.1.3 node_modules/hexo-generator-category</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</span><br><span class="line"></span><br><span class="line">hexo-generator-archive@0.1.3 node_modules/hexo-generator-archive</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</span><br><span class="line"></span><br><span class="line">hexo-renderer-marked@0.2.5 node_modules/hexo-renderer-marked</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">├── marked@0.3.5</span><br><span class="line">├── strip-indent@1.0.1 (get-stdin@4.0.1)</span><br><span class="line">└── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.1, highlight.js@8.8.0)</span><br><span class="line"></span><br><span class="line">hexo-renderer-stylus@0.3.0 node_modules/hexo-renderer-stylus</span><br><span class="line">├── stylus@0.52.4 (css-parse@1.7.0, debug@2.2.0, sax@0.5.8, source-map@0.1.43, mkdirp@0.5.1, glob@3.2.11)</span><br><span class="line">└── nib@1.1.0 (stylus@0.49.3)</span><br><span class="line"></span><br><span class="line">hexo-server@0.1.2 node_modules/hexo-server</span><br><span class="line">├── object-assign@2.1.1</span><br><span class="line">├── open@0.0.5</span><br><span class="line">├── mime@1.3.4</span><br><span class="line">├── bluebird@2.10.1</span><br><span class="line">├── morgan@1.6.1 (basic-auth@1.0.3, on-headers@1.0.0, depd@1.0.1, on-finished@2.3.0, debug@2.2.0)</span><br><span class="line">├── connect@3.4.0 (utils-merge@1.0.0, parseurl@1.3.0, debug@2.2.0, finalhandler@0.4.0)</span><br><span class="line">├── serve-static@1.10.0 (escape-html@1.0.2, parseurl@1.3.0, send@0.13.0)</span><br><span class="line">├── compression@1.5.2 (vary@1.0.1, bytes@2.1.0, on-headers@1.0.0, debug@2.2.0, compressible@2.0.5, accepts@1.2.13)</span><br><span class="line">└── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.3, supports-color@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)</span><br><span class="line"></span><br><span class="line">hexo@3.1.1 node_modules/hexo</span><br><span class="line">├── hexo-front-matter@0.2.2</span><br><span class="line">├── pretty-hrtime@1.0.0</span><br><span class="line">├── abbrev@1.0.7</span><br><span class="line">├── titlecase@1.0.2</span><br><span class="line">├── archy@1.0.0</span><br><span class="line">├── text-table@0.2.0</span><br><span class="line">├── tildify@1.1.1 (os-homedir@1.0.1)</span><br><span class="line">├── strip-indent@1.0.1 (get-stdin@4.0.1)</span><br><span class="line">├── hexo-i18n@0.2.1 (sprintf-js@1.0.3)</span><br><span class="line">├── moment-timezone@0.3.1</span><br><span class="line">├── bluebird@2.10.1</span><br><span class="line">├── minimatch@2.0.10 (brace-expansion@1.1.1)</span><br><span class="line">├── through2@1.1.1 (xtend@4.0.0, readable-stream@1.1.13)</span><br><span class="line">├── swig-extras@0.0.1 (markdown@0.5.0)</span><br><span class="line">├── chalk@1.1.1 (escape-string-regexp@1.0.3, ansi-styles@2.1.0, supports-color@2.0.0, has-ansi@2.0.0, strip-ansi@3.0.0)</span><br><span class="line">├── warehouse@1.0.3 (graceful-fs@4.1.2, cuid@1.2.5, JSONStream@1.0.6)</span><br><span class="line">├── js-yaml@3.4.2 (esprima@2.2.0, argparse@1.0.2)</span><br><span class="line">├── hexo-cli@0.1.8 (minimist@1.2.0)</span><br><span class="line">├── moment@2.10.6</span><br><span class="line">├── nunjucks@1.3.4 (optimist@0.6.1, chokidar@0.12.6)</span><br><span class="line">├── cheerio@0.19.0 (entities@1.1.1, dom-serializer@0.1.0, css-select@1.0.0, htmlparser2@3.8.3)</span><br><span class="line">├── bunyan@1.5.1 (safe-json-stringify@1.0.3, <span class="built_in">mv</span>@2.1.1, dtrace-provider@0.6.0)</span><br><span class="line">├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)</span><br><span class="line">├── hexo-util@0.1.7 (ent@2.2.0, highlight.js@8.8.0)</span><br><span class="line">├── hexo-fs@0.1.4 (escape-string-regexp@1.0.3, graceful-fs@4.1.2, chokidar@1.1.0)</span><br><span class="line">└── lodash@3.10.1</span><br></pre></td></tr></table></figure>

<p>再来执行一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  hexo g            </span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 325 ms</span><br><span class="line">INFO  Generated: js/script.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.pack.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.css</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.css</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-media.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.css</span><br><span class="line">INFO  Generated: fancybox/helpers/fancybox_buttons.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_sprite@2x.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_sprite.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_overlay.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_loading@2x.gif</span><br><span class="line">INFO  Generated: fancybox/fancybox_loading.gif</span><br><span class="line">INFO  Generated: fancybox/blank.gif</span><br><span class="line">INFO  Generated: css/style.css</span><br><span class="line">INFO  Generated: css/images/banner.jpg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.ttf</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.svg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.eot</span><br><span class="line">INFO  Generated: css/fonts/FontAwesome.otf</span><br><span class="line">INFO  Generated: 2015/09/29/hello-world/index.html</span><br><span class="line">INFO  Generated: archives/index.html</span><br><span class="line">INFO  Generated: archives/2015/index.html</span><br><span class="line">INFO  Generated: archives/2015/09/index.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  28 files generated <span class="keyword">in</span> 1.01 s</span><br></pre></td></tr></table></figure>

<p>看一下文件目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  <span class="built_in">ls</span></span><br><span class="line">_config.yml  node_modules  public     <span class="built_in">source</span></span><br><span class="line">db.json      package.json  scaffolds  themes</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件_config.yml</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: LittleQ</span><br><span class="line">subtitle: 笔记分类整理</span><br><span class="line">description: Java Web</span><br><span class="line">author: LittleQ</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Chongqing</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> 主要解释一下这个时区<code>timezone</code>,我选的是重庆，具体想选择可以去这里<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">维基百科时区列表</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line">url: http://sjq597.github.io/ </span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> <code>url</code>就填你的<code>github</code>博客地址就行，其他的不要改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: http://github.com/sjq597/sjq597.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> <code>type</code>填<code>git</code>，不要填<code>github</code>，网上的教程都是填<code>github</code>，但是这是<code>hexo 2.x.x</code>的方法，对于<code>3.x.x</code>的版本，必须填<code>git</code>。<code>repository</code>也不要填<code>ssh</code>地址，要填<code>https</code>地址，并且把<code>https</code>改为<code>http</code>，分支都是<code>master</code>。</p>
<h4 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到<code>github</code></h4><p>发布到<code>github</code>之前还必须要安装一个东西：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  npm install hexo-deployer-git --save</span><br><span class="line">npm WARN optional dep failed, continuing fsevents@1.0.0</span><br><span class="line">hexo-deployer-git@0.0.4 node_modules/hexo-deployer-git</span><br><span class="line">├── moment@2.10.6</span><br><span class="line">├── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.3, supports-color@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)</span><br><span class="line">├── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.1, highlight.js@8.8.0)</span><br><span class="line">├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)</span><br><span class="line">└── hexo-fs@0.1.4 (escape-string-regexp@1.0.3, graceful-fs@4.1.2, bluebird@2.10.1, chokidar@1.1.0)</span><br></pre></td></tr></table></figure>

<p>然后就可已发布了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  hexo d                              </span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span>: sjq597</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">&#x27;https://sjq597@github.com&#x27;</span>: </span><br><span class="line">To http://github.com/sjq597/sjq597.github.io.git</span><br><span class="line"> + 5183f8b...aef1a55 master -&gt; master (forced update)</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from http://github.com/sjq597/sjq597.github.io.git.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li>YAMLException</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FATAL Something\<span class="string">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 13, column 1:</span></span><br><span class="line"><span class="string">    # URL</span></span><br><span class="line"><span class="string">    ^</span></span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> YML语法校验比较严格，冒号后面必须要有个空格，切记。配置文件里所有的修改地方都要记得在冒号后空格一下。</p>
<ul>
<li>Deployer not found: github</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  note  hexo d           </span><br><span class="line">ERROR Deployer not found: github</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 参见前面说的，<code>3.x.x</code>版本需要把<code>type</code>设置为<code>git</code>而不是<code>github</code>,并且仓库地址要写<code>git</code>的<code>https</code>地址，并且要改为<code>http</code>开头。</p>
<p>然后再去访问你在<code>github</code>上的博客地址，就会发现变成了<code>hexo</code>的<code>index.html</code>。</p>
<ul>
<li>Error: watch ENOSPC</li>
</ul>
<p>在终端输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  npm dedupe</span><br></pre></td></tr></table></figure>
<p>如果还不管用,试试下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
        <tag>Hexo</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL:Every derived table must have its own alias</title>
    <url>/2015/11/11/MySQL-Every-derived-table-must-have-its-own-alias/</url>
    <content><![CDATA[<p>在做多表联合查询时，报错：</p>
<blockquote>
<p>Every derived table must have its own alias</p>
</blockquote>
<p>意思就是每个派生出来的表都必须有一个自己的别名，这个错误一般多出现在多表查询的时候。<br>之所以在多表查询的时候会出现这个问题，是因为多表在做联合查询的时候，有嵌套查询。子查询出来的结果是作为一个派生表来进行上一级的查询，所以子查询的结果必须要有一个别名，按照下面类似的改法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name) <span class="keyword">as</span> t2;</span><br></pre></td></tr></table></figure>
<p>也就是为每个子查询一个别名，其实加一个简写，也方便多个表作联合查询条件来作联合。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 创建用户以及附权限</title>
    <url>/2016/04/23/MySQL-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%BB%A5%E5%8F%8A%E9%99%84%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>有时候为了测试，需要单独建一些MySQL用户来限定这部分用户的权限，并且需要限定哪些ip可以访问到我的数据库，具体步骤为,在装有MysQL的机器上执行：</p>
<ol>
<li>创建用户，一般为了避免暴露自己的密码习惯，可以用Linux自带的生成密码命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜✗ md5pass</span><br><span class="line">$1$6Fy9BTnB$Ruw50OR1oiUCwP73abnlD0</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong><code>6Fy9BTnB</code>为用户名，<code>Ruw50OR1oiUCwP73abnlD0</code>为密码<br>然后执行MySQL命令，语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br></pre></td></tr></table></figure>
<p>假设你机器IP为<code>192.168.1.101</code>,则对应的命令为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;6Fy9BTnB&#x27;@&#x27;Ruw50OR1oiUCwP73abnlD0&#x27; IDENTIFIED BY &#x27;192.168.1.101&#x27;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给MySQL用户附权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant 权限1,权限2,...权限n on 数据库名称.表名称 to 用户名@用户地址 identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;grant select,insert,update,delete,create,drop on order.oerder_info to 6Fy9BTnB@192.168.1.101 identified by &#x27;Ruw50OR1oiUCwP73abnlD0&#x27;;</span><br></pre></td></tr></table></figure>
<p>只有来自192.168.1.101的用户6Fy9BTnB才能有对应的访问权限，其他的机器是无法访问的。<br>这里还有个快捷的操作，如果要附所有表的的所有操作权限，不可能一个一个去写，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;grant all privileges on order.oerder_info to 6Fy9BTnB@192.168.1.101 identified by &#x27;Ruw50OR1oiUCwP73abnlD0&#x27;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 按周,月,年统计数据</title>
    <url>/2015/12/07/MySQL-%E6%8C%89%E5%91%A8-%E6%9C%88-%E5%B9%B4%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>通常对于一个标准的时间,例如<code>2015-12-05 12:34:40</code>,如果想获取它的年月日,我们可以采取取字串的形式,即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(create_time,1,10)	# 取2015-12-05</span><br><span class="line">substr(create_time,1,7)		# 取2015-12</span><br><span class="line">substr(create_time,1,4)		# 取2015</span><br></pre></td></tr></table></figure>
<p>也确实,对于一般的需求这么处理也够用了,但是有一个问题,如果要按周来统计,这个取字串就无法做到了,这个时候就需要用到<code>mysql</code>内置函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date_format(date,format)</span><br></pre></td></tr></table></figure>
<p>如果要按星期,天,月份来统计数据,可以这么来写,假设时间字段是<code>create_time</code>.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> date_format(create_time,<span class="string">&#x27;%y%u&#x27;</span>) week,<span class="built_in">count</span>(id) <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> week;		# 按星期统计</span><br><span class="line"><span class="keyword">SELECT</span> date_format(create_time,<span class="string">&#x27;%y%m%d&#x27;</span>) <span class="keyword">day</span>,<span class="built_in">count</span>(id) <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>;		# 按天统计</span><br><span class="line"><span class="keyword">select</span> date_format(create_time,<span class="string">&#x27;%y%m&#x27;</span>) <span class="keyword">month</span>,<span class="built_in">count</span>(id) <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>;	# 按月统计</span><br></pre></td></tr></table></figure>

<p>详细参数:<br>根据<code>format</code>字符串格式化代<code>date</code>的值.具体的格式取值有:</p>
<table>
<thead>
<tr>
<th>format 取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%M</td>
<td>月名字(January…December)</td>
</tr>
<tr>
<td>%W</td>
<td>星期名字(Sunday…Saturday)</td>
</tr>
<tr>
<td>%D</td>
<td>有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）</td>
</tr>
<tr>
<td>%Y</td>
<td>年, 数字,4 位(2013,2014,2015)</td>
</tr>
<tr>
<td>%y</td>
<td>年, 数字, 2 位(13,14,15)</td>
</tr>
<tr>
<td>%a</td>
<td>缩写的星期名字(Sun…Sat)</td>
</tr>
<tr>
<td>%d</td>
<td>月份中的天数, 数字(00…31)</td>
</tr>
<tr>
<td>%e</td>
<td>月份中的天数, 数字(0…31)</td>
</tr>
<tr>
<td>%m</td>
<td>月, 数字(01…12)</td>
</tr>
<tr>
<td>%c</td>
<td>月, 数字(1…12)</td>
</tr>
<tr>
<td>%b</td>
<td>缩写的月份名字(Jan…Dec)</td>
</tr>
<tr>
<td>%j</td>
<td>一年中的天数(001…366)</td>
</tr>
<tr>
<td>%H</td>
<td>小时(00…23)</td>
</tr>
<tr>
<td>%k</td>
<td>小时(0…23)</td>
</tr>
<tr>
<td>%h</td>
<td>小时(01…12)</td>
</tr>
<tr>
<td>%I</td>
<td>小时(01…12)</td>
</tr>
<tr>
<td>%l</td>
<td>小时(1…12)</td>
</tr>
<tr>
<td>%i</td>
<td>分钟, 数字(00…59)</td>
</tr>
<tr>
<td>%r</td>
<td>时间,12 小时(hh:mm:ss [AP]M)</td>
</tr>
<tr>
<td>%T</td>
<td>时间,24 小时(hh:mm:ss)</td>
</tr>
<tr>
<td>%S</td>
<td>秒(00…59)</td>
</tr>
<tr>
<td>%s</td>
<td>秒(00…59)</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM</td>
</tr>
<tr>
<td>%w</td>
<td>一个星期中的天数(0&#x3D;Sunday…6&#x3D;Saturday ）</td>
</tr>
<tr>
<td>%U</td>
<td>星期(0…52), 这里星期天是星期的第一天</td>
</tr>
<tr>
<td>%u</td>
<td>星期(0…52), 这里星期一是星期的第一天</td>
</tr>
<tr>
<td>%%</td>
<td>一个文字“%”。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 表复制操作</title>
    <url>/2015/11/09/MySQL-%E8%A1%A8%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在操作数据库的时候,往往是保留想要修改的库,先建一个一样的来操作,例如我想给一个库加个字段,然后从另一个很复杂的sql语句导入数据,看字段添加是否正确,最好的做法就是自己建一张临时表,把查询结果插到临时表,这样一旦出错,也不会影响到正常数据.下面是一些涉及到表复制和修改的常用命令.</p>
<h3 id="MySql表复制"><a href="#MySql表复制" class="headerlink" title="MySql表复制"></a>MySql表复制</h3><p>这个分为表是存在和不存在两种,具体使用不同的语句.</p>
<h4 id="新表不存在"><a href="#新表不存在" class="headerlink" title="新表不存在"></a>新表不存在</h4><ul>
<li>复制表结构即数据到新表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> new_table</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> old_talbe;</span><br></pre></td></tr></table></figure>
<p> 这种方法会将<code>old_table</code>中所有的内容都拷贝过来,用这种方法需要注意,<code>new_table</code>中没有了<code>old_table</code>中的<code>primary key,Extra,auto_increment</code>等属性,需要自己手动加,具体参看后面的修改表即字段属性.</p>
<ul>
<li>只复制表结构到新表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 第一种方法,和上面类似,只是数据记录为空,即给一个<span class="literal">false</span>条件</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> new_table</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> old_table <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"># 第二种方法</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> new_table <span class="keyword">like</span> old_table;</span><br></pre></td></tr></table></figure>

<h4 id="新表存在"><a href="#新表存在" class="headerlink" title="新表存在"></a>新表存在</h4><ul>
<li>复制旧表数据到新表(假设两个表结构一样)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> new_table</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> old_table;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制旧表数据到新表(假设两个表结构不一样)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> new_table(field1,field2,.....)</span><br><span class="line"><span class="keyword">select</span> field1,field2,field3 <span class="keyword">from</span> old_table;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制全部数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> new_table <span class="keyword">from</span> old_table;</span><br></pre></td></tr></table></figure>

<ul>
<li>只复制表结构到新表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> new_talble <span class="keyword">from</span> old_table <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="MySql修改命令"><a href="#MySql修改命令" class="headerlink" title="MySql修改命令"></a>MySql修改命令</h3><ul>
<li>增加字段</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">column</span> column_type [other];</span><br></pre></td></tr></table></figure>
<p> 例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_info <span class="keyword">add</span> mobile_phone <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>增加索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> index index_name (field1[，field2 …]);</span><br></pre></td></tr></table></figure>
<p> 用法样例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_info <span class="keyword">add</span> index idx_user_no(user_no);</span><br></pre></td></tr></table></figure>

<ul>
<li>加主关键索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">primary</span> key(field);</span><br></pre></td></tr></table></figure>
<p> 用法举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">primary</span> key(id,user_no);</span><br></pre></td></tr></table></figure>

<ul>
<li>加唯一限制条件索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> idx_name(field);</span><br></pre></td></tr></table></figure>
<p> 用法举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_info <span class="keyword">add</span> <span class="keyword">unique</span> idx_user_name(user_name);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> index idx_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改字段名称或类型</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name change old_field_name new_field_name field_type;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除字段</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> field_name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL过滤中文</title>
    <url>/2016/04/23/MySQL%E8%BF%87%E6%BB%A4%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<p>有时候在统计的时候，需要把包含中文的列过滤掉，主要是存在历史脏数据，比如我们的客户端存在新老客户端之分，日志记录不一样，所有有些活动或者名字在pv,uv的时候不一致，例如活动的名字一般就算有英文也不可能全是英文，所以我们在计算的时候，需要把全为英文的过滤掉:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where LENGTH(`col_name`) &lt;&gt; CHARACTER_LENGTH(`col_name`) </span><br></pre></td></tr></table></figure>
<p>这里的<code>col_name</code>是mysql里表的列名</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Permission denied (publickey)</title>
    <url>/2015/11/21/Permission-denied-publickey/</url>
    <content><![CDATA[<p>最近在家里电脑的电脑上<code>git pull</code>的时候，报错。电脑系统是<code>Ubuntu 14.04 64bit</code>，发现项目无法更新，之前都可以把项目拉取下来，现在更新却不行了，具体报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Permission denied (publickey). </span><br><span class="line">fatal: Could not read from remote repository. </span><br><span class="line">Please make sure you have the correct access rights </span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>网上的说法是<code>SSH key</code>的缘故，但是我之前在gitcafe上都可以clone下来，后来也没改东西，突然就没权限了。没办法，把gitcafe上的<code>SSH key</code>删掉了，又重新生成了一遍，传上去，结果还是不行。后来我重新在另一个目录下拉取项目，发现可以，于是突然想到，会不会是目录的权限问题。于是给项目的目录赋上了最高权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给docment目录赋最高权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 docment/</span><br></pre></td></tr></table></figure>
<p>然后重新更新项目，果然好使了。</p>
<p>但是后来电脑又出现了一个问题，突然就又连不上了，最后折腾了好久才搞定，这次是深入搞明白了，为啥会出现这个问题了，其实，说白了就是秘钥不对，但是网上的说法都太模糊，很多人其实都把密钥上传到了网站上，一开始是可以用的，后来确不行了，所以这里面应该不是密钥没上传导致的，而是本地的密钥出了问题，下面来看看具体的问题解决步骤。<br>一般报错信息是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cloning into &#x27;******&#x27;...</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>　　这个时候多半是你的密钥出了问题，而且出现这种问题一般是你使用了多个代码托管账户造成的，这个比较常见，现在很多公司都会搭建自己的代码托管仓库，例如<strong>gitlab</strong>，然后就是大名鼎鼎的<strong>github</strong>,作为程序员这个账户肯定是有的，然后呢，有时候吧，由于国内你懂得一些原因，<strong>github</strong>访问不是很稳定，所以会选择国内的一些代码托管仓库，例如<strong>oschina</strong>或者<strong>gitcafe</strong>。这么多账户一起使用，密钥的问题就来了。再加上我在家里还有个台式机，而且有时候为了能登公司的服务器，还要使用<strong>Window</strong>系统，这样下来，密钥一堆，所以密钥特别乱，慢慢的就产生了这个问题，偶尔就出现了上面这个问题。<br>首先要看看**~&#x2F;.ssh<strong>下面有些啥:一般就是会有一个</strong>id_rsa**,<strong>id_rsa.pub</strong>,<strong>config</strong>这写文件,简单介绍一下这三个文件都是干啥的:<br><strong>id_rsa</strong>是私钥，同理<strong>id_rsa.pub</strong>就是公钥，公钥是要传到服务器上的，每次你连接代码托管服务器，都是用服务器上的公钥去校验你本地的私钥，系统默认会读取你的<strong>～&#x2F;.ssh&#x2F;<strong>目录下的私钥文件，如果读取不到，或者读取到的私钥是错的，就会出现上面的问题，即</strong>Permission denied (publickey).<strong>，<br>这就要说道第三个文件</strong>config</strong>的作用了,先看看他长啥样吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    Hostname github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User github_username </span><br><span class="line"></span><br><span class="line">Host gitcafe.com</span><br><span class="line">    Hostname gitcafe.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa.gitcafe</span><br><span class="line">    User gitcafe_username</span><br></pre></td></tr></table></figure>
<p>看到这个文件我想你们大概应该明白了，</p>
<ol>
<li><code>Host</code>后面的名字相当于一个别名，真正的Host是Hostname的值,也即你可以使用别名来访问你托管代码的网站,</li>
<li><code>IdentityFile</code>就是你访问这个网站是，网站上的公钥会校验你的本地私钥的文件位置，这个填错了就无法正确校验了，所以会出错，</li>
<li><code>User</code>就是你在代码托管网站上的用户名</li>
</ol>
<p>另外说一个调试技巧，就是当你出问题，没权限<code>pull/push</code>代码的时候，如何确定是密钥出问题了呢？可以打开调试模式看看是用哪一个私钥文件在校验</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -vT git@gitcafe.com</span><br><span class="line"></span><br><span class="line">OpenSSH_6.6.1, OpenSSL 1.0.2d 9 Jul 2015</span><br><span class="line">debug1: Reading configuration data /home/zhangsan/.ssh/config</span><br><span class="line">debug1: /home/zhangsan/.ssh/config line 6: Applying options <span class="keyword">for</span> gitcafe.com</span><br><span class="line">debug1: Reading configuration data /etc/ssh/ssh_config</span><br><span class="line">debug1: /etc/ssh/ssh_config line 19: Applying options <span class="keyword">for</span> *</span><br><span class="line">debug1: Connecting to gitcafe.com [124.42.117.218] port 22.</span><br><span class="line">debug1: identity file /home/zhangsan/.ssh/id_rsa.gitcafe <span class="built_in">type</span> 1</span><br><span class="line">debug1: identity file /home/zhangsan/.ssh/id_rsa.gitcafe-cert <span class="built_in">type</span> -1</span><br><span class="line">debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.3</span><br><span class="line">debug1: Host <span class="string">&#x27;gitcafe.com&#x27;</span> is known and matches the RSA host key.</span><br><span class="line">debug1: Found key <span class="keyword">in</span> /home/zhangsan/.ssh/known_hosts:1</span><br><span class="line">debug1: Next authentication method: publickey</span><br><span class="line">debug1: Offering RSA public key: /home/zhangsan/.ssh/id_rsa.gitcafe</span><br><span class="line">debug1: Offering RSA public key: zhang.san@163.com</span><br><span class="line">debug1: Authentications that can <span class="built_in">continue</span>: publickey</span><br><span class="line">debug1: Offering RSA public key: zhang.san@gmail.com</span><br><span class="line">debug1: Server accepts key: pkalg ssh-rsa blen 279</span><br><span class="line">debug1: Authentication succeeded (publickey).</span><br><span class="line">Authenticated to gitcafe.com ([124.42.117.218]:22).</span><br><span class="line">Hi zhangsan! You<span class="string">&#x27;ve successfully authenticated, but GitCafe does not provide shell access.</span></span><br><span class="line"><span class="string">debug1: client_input_channel_req: channel 0 rtype exit-status reply 0</span></span><br><span class="line"><span class="string">debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0</span></span><br><span class="line"><span class="string">debug1: channel 0: free: client-session, nchannels 1</span></span><br><span class="line"><span class="string">Transferred: sent 4632, received 3656 bytes, in 1.0 seconds</span></span><br><span class="line"><span class="string">Bytes per second: sent 4642.3, received 3664.1</span></span><br><span class="line"><span class="string">debug1: Exit status 1</span></span><br></pre></td></tr></table></figure>
<p>这里输出了很多,看第4行，告诉我们加载配置文件的地方就是前面提到的<strong>config</strong>文件，然后第9行，他从配置文件里加载私钥文件，所以你想看你的<strong>git</strong>是加载的哪个文件，看这个就可以了，如果不对，那么按照上面的配置重新配置一下就OK了。</p>
<p><strong>备注：</strong> 注意，如果在使用<code>sudo git ...</code>的时候仍然提示**Permission denied (publickey).**。记得去掉<code>sudo</code>,或者更改对应的私钥文件的权限。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Error running xx: Cannot start process, the working directory /home/xx does not exist</title>
    <url>/2015/11/07/PyCharm:Error-running-xx-Cannot-start-process-the-working-directory-home-xx-does-not-exist/</url>
    <content><![CDATA[<p>用PyCharm 4.5.4写python代码的时候,改了文件夹的名字,再运行脚本,始终运行不起来,一直报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error running xx: Cannot start process, the working directory /home/xx does not exist</span><br></pre></td></tr></table></figure>
<p>看一下项目的配置,具体是工具栏:<code>Run--&gt;Edit Configurations</code><br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/PyCharm%3AError%20running%20Cannot%20start%20process01.png" alt="项目详细配置"><br>看了一下<code>Working directory:</code>以及<code>Script:</code>的内容果然不对,改为对应的脚本以及脚本目录就好了.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MD5校验文件</title>
    <url>/2015/12/18/Python-MD5%E6%A3%80%E9%AA%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>今天看到了一个用Python校验文件md5的代码,但是本人Python不是很熟,所以里面有很多语法看的不是很懂,大概讲讲吧.<br>首先要想校验一个文件的md5值在Linux下很方便,命令行就可以校验:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="built_in">md5sum</span> 订单数据.xls </span><br><span class="line">933ed658af57a9aec4d1ba9800fe5460  订单数据.xls</span><br></pre></td></tr></table></figure>
<p>虽然你也可以调用Python来校验文件的md5,但是这样很不方便,也不能保证windows下也可以运行吧,Python中也md5校验的函数,Python 2.5之后推荐使用<code>hashlib</code>来代替<code>md5</code>模块来做校验.</p>
<h3 id="简单的MD5校验"><a href="#简单的MD5校验" class="headerlink" title="简单的MD5校验"></a>简单的MD5校验</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">md5sum</span>(<span class="params">file_name</span>):</span><br><span class="line">    fp = <span class="built_in">open</span>(file_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    content = fp.read()</span><br><span class="line">    fp.close()</span><br><span class="line">    m = hashlib.md5(content)</span><br><span class="line">    file_md5 = m.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file_md5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> md5sum(<span class="string">&#x27;TCPServer.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> <strong>注意:</strong><code>hashlib.md5()</code>返回的是一个对象,要想得到md5值,还需要调用一下<code>hexdigest()</code>方法.还有一个地方需要注意一下,这个校验方法有个很大的缺陷,由于是要校验文件里面的内容,所以每次是把文件读到内存的,试想一下,如果这个文件很大,先不说慢,更有可能程序就直接卡死了.</p>
<h3 id="改进的MD5校验"><a href="#改进的MD5校验" class="headerlink" title="改进的MD5校验"></a>改进的MD5校验</h3><p>下面的代码确实写的很牛逼,对于我这种刚学Python的渣渣来说,很多地方都看的不太明白,先把程序贴出来,后面有一些程序中不懂的地方的一些详尽的解释.优化之后的代码:</p>
<h4 id="加密字符串"><a href="#加密字符串" class="headerlink" title="加密字符串"></a>加密字符串</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">md5hex</span>(<span class="params">word</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    MD5加密算法,返回32为小写16进制符号</span></span><br><span class="line"><span class="string">    :param word: 需要加密的字符串</span></span><br><span class="line"><span class="string">    :return: 返回32为小写16进制符号</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(word, unicode):</span><br><span class="line">        word = word.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(word, <span class="built_in">str</span>):</span><br><span class="line">        word = <span class="built_in">str</span>(word)</span><br><span class="line"></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(word)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br></pre></td></tr></table></figure>
<p>**解释:**查了一下Python里关于<code>str</code>和<code>unicode</code>的区别,简单来说就是<code>str</code>类似于<code>byte[]</code>,即字节字符串.而<code>unicode</code>类似于<code>char[]</code>.说白了就是Python内部存储用<code>unicode</code>,而在和人交互的时候用<code>str</code>,str是字节串，由unicode经过编码(encode)后的字节组成的,所以它们的关系就是<code>unicode.encode()--&gt;str</code>或者<code>str.decode()--&gt;unicode()</code>.时刻记住:</p>
<blockquote>
<p><strong>unicode</strong>才是真正的字符串.</p>
</blockquote>
<h4 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def md5sum(file_name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据给定文件名计算文件MD5值</span><br><span class="line">    :param file_name: 文件的路径</span><br><span class="line">    :return: 返回文件MD5校验值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def read_chunks(fp):</span><br><span class="line">        fp.seek(0)</span><br><span class="line">        chunk = fp.read(8 * 1024)</span><br><span class="line">        while chunk:</span><br><span class="line">            yield chunk</span><br><span class="line">            chunk = fp.read(8 * 1024)</span><br><span class="line">        else:	# 最后要将游标放回文件开头</span><br><span class="line">            fp.seek(0)</span><br><span class="line"></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    if isinstance(file_name, basestring) \</span><br><span class="line">            and os.path.exists(file_name):</span><br><span class="line">        with open(file_name, &#x27;rb&#x27;) as fp:</span><br><span class="line">            for chunk in read_chunks(fp):</span><br><span class="line">                m.update(chunk)</span><br><span class="line">    elif file_name.__class__.name__ in [&quot;StringIO&quot;, &quot;cStringIO&quot;] \</span><br><span class="line">            or isinstance(file_name, file):</span><br><span class="line">        for chunk in read_chunks(file_name):</span><br><span class="line">            m.update(chunk)</span><br><span class="line">    else:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line"></span><br><span class="line">    return m.hexdigest()</span><br></pre></td></tr></table></figure>
<p>这段程序写的确实很牛逼,我稍微解释一下:</p>
<ol>
<li><code>8~15</code>行:的意思就是每次返回读取的文件的8k的内容,下次从上次读取的地方继续读取,如果读完了,就把游标重新放到文件开头.注意这里面用到了<code>yield</code>,对这个关键字不熟的可以简单把他理解为关键字<code>return</code>.但是它和<code>return</code>不同的地方在于,再次调用函数的时候,上次调用的变量还是有效的,也就是说它不是从文件的开头重新读,而是接着上回读的地方再读8k的内容</li>
<li><code>18</code>行:<code>isinstance(file_name, basestring)</code>这个是判断文件名是不是一个<code>basestring</code>类型,<code>basestring</code>是<code>str</code>和<code>unicode</code>的父类,这个类是个抽象类,不能被实例化,不过可以被用来判断一个对象是不是字符串.<code>with</code>关键字,简单理解为<code>try/catch</code>就可以了,即使发生了异常,文件也可以正常关闭.</li>
<li><code>23</code>行:<code>StringIO</code>和<code>cStringIO</code>与<code>file</code>对象非常像,指内存里的文件,例如上传的文件缓存或者已经打开的文件流,那么就不用打开文件,直接读就行</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个程序其实就是每次读取8k的内容,然后更新已经读取的内容的<code>md5</code>值,核心代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> read_chunks(fp):</span><br><span class="line">	m.update(chunk)</span><br></pre></td></tr></table></figure>
<p>如果不明白<code>update()</code>的用法,可以测试一下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import hashlib</span><br><span class="line">&gt;&gt;&gt; x = hashlib.md5()</span><br><span class="line">&gt;&gt;&gt; x.update(<span class="string">&#x27;hello, &#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; x.update(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; x.hexdigest()</span><br><span class="line"><span class="string">&#x27;fb42758282ecd4646426112d0cbab865&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hashlib.md5(<span class="string">&#x27;hello, python&#x27;</span>).hexdigest()</span><br><span class="line"><span class="string">&#x27;fb42758282ecd4646426112d0cbab865&#x27;</span></span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>所以可以看到,<code>update()</code>方法其实并不会丢弃上一次校验的结果,就是在不停的累加,尤其适合处理大文件.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SQLALchemy理解</title>
    <url>/2016/08/20/Python-SQLALchemy%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>要不是为了用Flask开发系统，要不是涉及到各种表，估计也没人愿意用<code>ORM</code>框架吧，简单的查询估计直接写sql,用<code>MySQLdb</code>了。但是当你的系统大了，功能复杂了，表多了之后，这个东西还是很有必要的。如果你做了一个还算不太复杂的系统，里面各种表，你还手写sql,那我敬你是一条汉子，毕竟我们都喜欢踏实肯干的小伙子啊，请务必把简历发到我们公司HR的邮箱。好了，前面都是扯淡的，现在我要一本正经的说重点了，Flask的ORM框架也不止一个，为啥多说人都推荐用<code>SQLALChemy</code>这个ORM框架呢？其实原因很简单:因为它非常的灵活，这直接导致了它的功能非常的强大，当然，间接导致了这个框架学习成本很高。其实主要是参数很多，很多人不知道什么场景用什么参数，所以才有这篇笔记，我也不知道这些参数都是干啥的，但是作者既然留了这么多参数，必然是有场景需要，不然人家吃饱了撑得？</p>
<h3 id="SQLALChemy用法"><a href="#SQLALChemy用法" class="headerlink" title="SQLALChemy用法"></a>SQLALChemy用法</h3><p>虽然是因为Flask而去用这个框架，但是我这里主要讲<code>SQLALChemy</code>怎么用，并没有涉及到<code>Flask</code>.前面说了一堆，无非就是想告诉你，这个框架真的很牛逼，用的人很多，出了问题你也不是第一个踩坑的，毕竟每个坑下面躺着不少你的前辈，有了问题也好解决。直接说有些空洞，先上个简单的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from sqlalchemy import Integer, ForeignKey, String, Column</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relationship</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">engine = create_engine(&#x27;sqlite:///:memory:&#x27;, echo=False)</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class User(Base):</span><br><span class="line">    __tablename__ = &#x27;user&#x27;</span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    name = Column(String)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name=None):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;&lt;User:id=&#123;0&#125;,name=&#123;1&#125;&gt;&#x27;.format(self.id, self.name)</span><br><span class="line"></span><br><span class="line">    addresses = relationship(&#x27;Address&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Address(Base):</span><br><span class="line">    __tablename__ = &#x27;address&#x27;</span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    email = Column(String)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(&#x27;user.id&#x27;))</span><br><span class="line"></span><br><span class="line">    def __init__(self, email=None, user_id=None):</span><br><span class="line">        self.email = email</span><br><span class="line">        self.user_id = user_id</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;&lt;Address:id=&#123;0&#125;,email=&#123;1&#125;,user_id=&#123;2&#125;&gt;&#x27;.format(self.id, self.email, self.user_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    Base.metadata.create_all(engine)</span><br><span class="line">    Session = sessionmaker(bind=engine)</span><br><span class="line">    session = Session()</span><br><span class="line"></span><br><span class="line">    session.add_all([</span><br><span class="line">        User(name=&#x27;san.zhang&#x27;),</span><br><span class="line">        User(name=&#x27;si.li&#x27;),</span><br><span class="line">        User(name=&#x27;wu.wang&#x27;)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    session.add_all([</span><br><span class="line">        Address(email=&#x27;123@qq.com&#x27;, user_id=1),</span><br><span class="line">        Address(email=&#x27;456@qq.com&#x27;, user_id=2),</span><br><span class="line">        Address(email=&#x27;789@qq.com&#x27;, user_id=2)</span><br><span class="line">    ])</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line">    print &#x27;查询1:%s&#x27; % session.query(User).all()</span><br><span class="line">    print &#x27;查询2:%s&#x27; % session.query(User).filter_by(id=1).first().addresses</span><br><span class="line">    print &#x27;查询3:%s&#x27; % session.query(User).filter_by(id=2).first().addresses</span><br><span class="line">    print &#x27;查询4:%s&#x27; % session.query(User).filter_by(id=3).first().addresses</span><br></pre></td></tr></table></figure>
<p>解释一下:</p>
<ul>
<li>第10行我直接创建了一个内存数据库，这东西用法就是一个数据库链接，用过jdbc的都应该知道我在说什么，不知道的就当你知道了。具体的链接不同数据库不同，我就举个MySQL的例子:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQLALCHEMY_DATABASE_URI = &#x27;mysql://&lt;user_name&gt;:&lt;passward&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>echo</code>:这个参数就是是否打印出执行的sql,其实orm框架到最后也是执行sql(好像是废话哈),所以你如果平时调试的时候想看这个底层执行的sql是不是符合你的逻辑，你可以把这个参数设置成<code>True</code>,这样在控制台就会打印出你每次执行的代码对应的sql</p>
</li>
<li><p>实体类<br>这里创建了两个实体类<code>User</code>,<code>Address</code>,分别对应数据库里面的两个表，这就完成了简单的<code>ORM</code>关系映射，把实体类和表对应起来了,注意这里有个映射关系，一个用户可能对应多个地址,这里还有个很重要的东西<code>relationship(&#39;Address&#39;)</code>.这个东西很复杂，其实<code>SQLALChemy</code>的复杂主要就是体现在这个地方，关系映射这个东西不太好理解，后面会细讲</p>
</li>
<li><p>数据库操作<br>这个其实比较简单了，需要一个操作句柄，<code>session</code>,修改操作只有在<code>session.commit()</code>之后才会真正提交到数据库中，类似与Spring里面的事务管理.</p>
</li>
</ul>
<p>具体使用上就比较简单了，先创建了几个对象，然后调用<code>add_all()</code>把数据写到数据库里面，后面就可以查询了</p>
<h3 id="关系映射relationship"><a href="#关系映射relationship" class="headerlink" title="关系映射relationship"></a>关系映射relationship</h3><p>前面也说了，这个东西复杂主要就是复杂在<code>relationship</code>这个类的使用上，总的来说，关系型数据库当然少不了关系这个桥梁，而ORM框架里面的这个R就显得很重要了，网上的一些教程吧，说的很含糊，我自己学的时候看了很多，那些人以为自己理解了，讲清楚了，但是说出来的话模棱两可，对于新手来说具有很大的迷惑性，我只能自己验证一下:</p>
<h4 id="表关联"><a href="#表关联" class="headerlink" title="表关联"></a>表关联</h4><p>首先强调一点，在实体类里面用<code>relationship()</code>申明的属性并不是这个类对应的数据库里面的真实字段，也就是说上面的<code>User</code>类里面有<code>addresses</code>这个属性，但是数据库表<code>user</code>里面并没有<code>addresses</code>字段，这个只是ORM框架替你做了一个映射，你可以通过<code>User</code>里面的属性拿到和它关联的地址，但是你没办法通过<code>Address</code>类来获取它对应的用户信息，这就是关系映射,看看运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询1:[&lt;User:id=1,name=san.zhang&gt;, &lt;User:id=2,name=si.li&gt;, &lt;User:id=3,name=wu.wang&gt;]</span><br><span class="line">查询2:[&lt;Address:id=1,email=123@qq.com,user_id=1&gt;]</span><br><span class="line">查询3:[&lt;Address:id=2,email=456@qq.com,user_id=2&gt;, &lt;Address:id=3,email=789@qq.com,user_id=2&gt;]</span><br><span class="line">查询4:[]</span><br></pre></td></tr></table></figure>
<p>我这里把输出sql的开关设置成<code>Flase</code>了，所以比较整洁，只有输出结果，如果打开的话，就会有对应的查询语句.</p>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>这个东西比较有意思,我们把<code>User</code>类里面的东西该成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addresses = relationship(&#x27;Address&#x27;, lazy=&#x27;dynamic&#x27;)</span><br></pre></td></tr></table></figure>
<p>我们不仅加了关系映射，还加了一个属性<code>lazy=&#39;dynamic&#39;</code>,这个是个啥意思呢？其实就是延迟加载，想象一个场景，如果一个人对应了1w条地址信息，那么每当我们查一个用户的地址，访问<code>addresses</code>字段时，就会返回那1w条记录，但是正常情况下这1w条记录里面并不都是你要的，如果加上了上面这个属性，意思就是你访问<code>addresses</code>属性不再返回数据了，而是返回一个查询对象，你可以在这个查询对象上应用过滤啊，条件啥的，找到你真正要的那部分数据，这样性能上也会更好，不用每次把所有的数据都返回，具体可以看下面的例子,上面的查询语句输出结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询1:[&lt;User:id=1,name=san.zhang&gt;, &lt;User:id=2,name=si.li&gt;, &lt;User:id=3,name=wu.wang&gt;]</span><br><span class="line">查询2:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id </span><br><span class="line">FROM address </span><br><span class="line">WHERE :param_1 = address.user_id</span><br><span class="line">查询3:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id </span><br><span class="line">FROM address </span><br><span class="line">WHERE :param_1 = address.user_id</span><br><span class="line">查询4:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id </span><br><span class="line">FROM address </span><br><span class="line">WHERE :param_1 = address.user_id AND address.email = :email_1</span><br></pre></td></tr></table></figure>
<p>可以看到，并没有输出我们查询到的结果，而是返回了查处对象，那么如果要获取查询结果怎么办呢？其实也很简单，既然是查询对象，那像上面一样调用<code>first(),all()</code>就可以了，把查询语句改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &#x27;查询1:%s&#x27; % session.query(User).all()</span><br><span class="line">print &#x27;查询2:%s&#x27; % session.query(User).filter_by(id=1).first().addresses.all()</span><br><span class="line">print &#x27;查询3:%s&#x27; % session.query(User).filter_by(id=2).first().addresses.all()</span><br><span class="line">print &#x27;查询4:%s&#x27; % session.query(User).filter_by(id=2).first().addresses.filter_by(email=&#x27;456@qq.com&#x27;).all()</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询1:[&lt;User:id=1,name=san.zhang&gt;, &lt;User:id=2,name=si.li&gt;, &lt;User:id=3,name=wu.wang&gt;]</span><br><span class="line">查询2:[&lt;Address:id=1,email=123@qq.com,user_id=1&gt;]</span><br><span class="line">查询3:[&lt;Address:id=2,email=456@qq.com,user_id=2&gt;, &lt;Address:id=3,email=789@qq.com,user_id=2&gt;]</span><br><span class="line">查询4:[&lt;Address:id=2,email=456@qq.com,user_id=2&gt;]</span><br></pre></td></tr></table></figure>
<p>注意第四个查询语句，我们在获取<code>addresses</code>属性之后调用了过滤函数，最后的结果确实只返回了一个，所以说这个延迟加载的确很方便，可以在查询结果返回前过滤掉不用的数据</p>
<h4 id="反向查询"><a href="#反向查询" class="headerlink" title="反向查询"></a>反向查询</h4><p>我们知道，通过<code>User</code>类可以访问到<code>addresses</code>属性，其实返回的就是<code>Address</code>对象，那么问题来了，如果想通过<code>Address</code>来反查某个地址下面的用户怎么办，当然你可以查询到这些<code>user_id</code>再去<code>user</code>表里面查对应的<code>user</code>信息，但是这样很麻烦，<code>sqlalchemy</code>也提供了一种反查机制,<code>backref</code>参数,类似于在<code>Address</code>中添加了<code>user</code>属性，同样的把<code>User</code>实体类改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addresses = relationship(&#x27;Address&#x27;, backref=db.backref(&#x27;user&#x27;, lazy=&#x27;joined&#x27;), lazy=&#x27;dynamic&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意到最外层的<code>lazy=&#39;dynamic&#39;</code>是针对<code>User</code>查询多个地址时延迟加载策略,<code>db.backref(&#39;user&#39;, lazy=&#39;joined&#39;)</code>这个虽然定义在了<code>User</code>类里面，但是此处的作用是定义一个反向引用关系，这样就可通过<code>Address</code>来访问到对应的<code>User</code>类了，并且里面也定了一个策略<code>lazy=&#39;joined&#39;</code>，这是告诉<code>Address</code>查找对应的<code>User</code>时采用连接查询，如果不加，那就会采用子查询的方式来查询。可以测试一下，需要打开<code>echo=True</code>设置,这里就查一个吧，因为要输出查询语句，所以输出信息有点儿多,假设查询语句为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &#x27;查询1:%s&#x27; % db.session.query(Address).filter_by(id=2).first().user</span><br></pre></td></tr></table></figure>
<p>看看相信的输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-08-20 15:45:29,194 INFO sqlalchemy.engine.base.Engine SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id, user_1.id AS user_1_id, user_1.name AS user_1_name </span><br><span class="line">FROM address LEFT OUTER JOIN user AS user_1 ON user_1.id = address.user_id </span><br><span class="line">WHERE address.id = ?</span><br><span class="line"> LIMIT ? OFFSET ?</span><br><span class="line">2016-08-20 15:45:29,194 INFO sqlalchemy.engine.base.Engine (2, 1, 0)</span><br><span class="line">查询1:&lt;User:id=2,name=si.li&gt;</span><br></pre></td></tr></table></figure>
<p>看到没有，用的是<code>LEFT OUTER JOIN</code>来查询的，那如果去掉<code>lazy=&#39;joined&#39;</code>呢？看看输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-08-20 15:47:33,246 INFO sqlalchemy.engine.base.Engine SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id </span><br><span class="line">FROM address </span><br><span class="line">WHERE address.id = ?</span><br><span class="line"> LIMIT ? OFFSET ?</span><br><span class="line">2016-08-20 15:47:33,246 INFO sqlalchemy.engine.base.Engine (2, 1, 0)</span><br><span class="line">2016-08-20 15:47:33,247 INFO sqlalchemy.engine.base.Engine SELECT user.id AS user_id, user.name AS user_name </span><br><span class="line">FROM user </span><br><span class="line">WHERE user.id = ?</span><br><span class="line">2016-08-20 15:47:33,247 INFO sqlalchemy.engine.base.Engine (2,)</span><br><span class="line">查询1:&lt;User:id=2,name=si.li&gt;</span><br></pre></td></tr></table></figure>
<p>看到没有，这个里面有两个sql,先查<code>address</code>表，可以获取到<code>user_id</code>字段，然后再用这些去<code>user</code>表里面查,所以这里的<code>lazy=&#39;joined&#39;</code>相当于反向查询的惰性加载。<br>还有个奇特的用法，就是自引用，就是类似于无限目录这种机制:</p>
<h5 id="多对对映射"><a href="#多对对映射" class="headerlink" title="多对对映射"></a>多对对映射</h5><p>很多时候用ORM框架就是因为业务结构太复杂，复杂性一般体现在表与表之间很多都是多对多映射，如果两个对象是多对多的话怎么映射这个关系呢？难道是在两个实体类里面都用<code>relationship</code>互相声明吗？当然不用，<code>SQLALChecmy</code>里面提供了一个更简单的方法,中间表关联法,还是以<code>User</code>和<code>Address</code>来说明:<br>新来增加一张中间表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user_address = db.Table(</span><br><span class="line">    &#x27;user_address&#x27;,</span><br><span class="line">    db.Column(&#x27;User&#x27;, db.Integer, db.ForeignKey(&#x27;user.id&#x27;)),</span><br><span class="line">    db.Column(&#x27;Address&#x27;, db.Integer, db.ForeignKey(&#x27;address.id&#x27;))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个就不用实体类了，直接用中间表了,然后修改<code>User</code>表的定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addresses = relationship(&#x27;Address&#x27;, secondary=user_address, backref=db.backref(&#x27;user&#x27;, lazy=&#x27;joined&#x27;),</span><br><span class="line">                         lazy=&#x27;dynamic&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后修改<code>Address</code>实体类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Address(db.Model):</span><br><span class="line">    __tablename__ = &#x27;address&#x27;</span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    email = Column(String)</span><br><span class="line"></span><br><span class="line">    def __init__(self, email=None):</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;&lt;Address:id=&#123;0&#125;,email=&#123;1&#125;&gt;&#x27;.format(self.id, self.email)</span><br></pre></td></tr></table></figure>
<p>去掉了之前在这里面定义的外键<code>user_id</code>，然后我们来测试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    db.create_all()</span><br><span class="line"></span><br><span class="line">    add_list = []</span><br><span class="line">    for item in [&#x27;123@qq.com&#x27;, &#x27;456@qq.com&#x27;, &#x27;789@qq.com&#x27;]:</span><br><span class="line">        address = Address()</span><br><span class="line">        address.email = item</span><br><span class="line"></span><br><span class="line">        add_list.append(address)</span><br><span class="line">        db.session.add(address)</span><br><span class="line"></span><br><span class="line">    user = User()</span><br><span class="line">    user.addresses = add_list[:2]</span><br><span class="line">    db.session.add(user)</span><br><span class="line"></span><br><span class="line">    user = User()</span><br><span class="line">    user.addresses = add_list[1:]</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    print &#x27;查询1:%s&#x27; % User.query.first().addresses.all()</span><br><span class="line">    print &#x27;查询2:%s&#x27; % Address.query.filter_by(email=&#x27;456@qq.com&#x27;).first().user</span><br></pre></td></tr></table></figure>
<p>创建了3个地址，每个用户拥有2个地址，并且这两个用户都有中间的地址，看看查询结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询1:[&lt;Address:id=1,email=123@qq.com&gt;, &lt;Address:id=2,email=456@qq.com&gt;]</span><br><span class="line">查询2:[&lt;User:id=1,name=None&gt;, &lt;User:id=2,name=None&gt;]</span><br></pre></td></tr></table></figure>
<p>可以看到反查，正查都可以差多多对多的结果。</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Socket 文件传输实现</title>
    <url>/2015/12/16/Python-Socket-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>经常需要把文件上传到服务器,最开始是用<code>scp</code>命令具体参见<a href="../../../10/27/Linux-%E6%9C%AC%E5%9C%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4-scp">Linux 本地和服务器互传文件命令:scp</a>,但是公司登陆服务器需要先登陆跳板机,所以需要先把文件scp到跳板机上,然后再scp到服务器上,很麻烦.所以后来想到了用公司的git服务器,先把文件push到git服务器上,然后再在服务器上直接pull下来,用完了再删掉数据commit更新就行了.这样其实也基本满足了需求,但是还是觉得麻烦,特别是每次还需要进行一系列git操作,还要一直留着这个仓库.<br>当然,从服务器上下载需要的文件也很简单,不用scp这么几次,直接在服务器上需要下载文件的目录执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录为服务器根目录,端口为8000</span></span><br><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure>
<p>本地机器执行打开浏览器,输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://server_ip:8000</span><br></pre></td></tr></table></figure>
<p>就可以直接下载了</p>
<p>正好这几天看了一下python的socket,直接写个小型的服务端和客户端,直接传文件即可.</p>
<h3 id="Socket发送消息"><a href="#Socket发送消息" class="headerlink" title="Socket发送消息"></a>Socket发送消息</h3>]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python fetchall()字段特殊字符过滤处理</title>
    <url>/2015/11/01/Python-fetchall-%E5%AD%97%E6%AE%B5%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>最近在做数据仓库的迁移工作,之前数据仓库的数据都是用的shell脚本来抽取,后来换了python脚本.<br>但是在把数据抽取存放到hadoop时,出现了一个问题:<br>由于数据库字段很多,提前也不知道数据库字段会存储什么内容,hive建表是以<code>\t\n</code>做分隔,这就导致了一个问题,如果mysql字段内容里面本身含有<code>\t\n</code>,那么就会出现字段错位情况,并且很头疼的是mysql有100多个字段,也不知道哪个字段会出现这个问题.<br>shell脚本里的做法是在需要抽取的字段上用mysql的replace函数对字段进行替换,例如,假设mysql里的字段是<code>column1 varchar(2000)</code>,那么很可能就会出现有特殊字符的情况,在查询的sql语句里加上</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> replace(replace(replace(column1,<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>之前一直是这么干的,但是这样写sql特别长,特别是有100多个字段,也不知道哪个有特殊字符,只要都加上.<br>所以在python中对字段不加处理,最终导致hive表字段对应出现偏差,所以在python里从mysql查询到的字段在写到文件之前需要对每个字段进行过滤处理</p>
<p>看个例子,我就以mysql测试为例,首先建一张测试表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `filter_fields` (</span><br><span class="line">  `field1` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `field2` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `field3` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `field4` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `field5` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `field6` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>有六个字段,都是<code>varchar</code>类型,插入新数据可以在里面插入特殊字符.简单插入条数据测试看看:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> filter_fields(field1,field2,field3,field4,field5,field6) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;test01&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>,<span class="string">&#x27;test03&#x27;</span>,<span class="string">&#x27;test04&#x27;</span>,<span class="string">&#x27;test05&#x27;</span>,<span class="string">&#x27;test06&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> filter_fields(field1,field2,field3,field4,field5,field6) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;test11\ntest11&#x27;</span>,<span class="string">&#x27;test12\n\n&#x27;</span>,<span class="string">&#x27;test13&#x27;</span>,<span class="string">&#x27;test14&#x27;</span>,<span class="string">&#x27;test15&#x27;</span>,<span class="string">&#x27;test16&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> filter_fields(field1,field2,field3,field4,field5,field6) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;test21\ttest21&#x27;</span>,<span class="string">&#x27;test22\ttest22\ttest22&#x27;</span>,<span class="string">&#x27;test23\t\t\t&#x27;</span>,<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;test5&#x27;</span>,<span class="string">&#x27;test6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> filter_fields(field1,field2,field3,field4,field5,field6) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;test21\rest21&#x27;</span>,<span class="string">&#x27;test22\r\rest22\r\rest22&#x27;</span>,<span class="string">&#x27;test23\r\r\r&#x27;</span>,<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;test5&#x27;</span>,<span class="string">&#x27;test6&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>其中数据里插入的特殊字符,可能连在一起,也有不连在一起的.</p>
<p>python测试代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">db_host = <span class="string">&#x27;127.0.0.1&#x27;</span>   <span class="comment"># 数据库地址</span></span><br><span class="line">db_port = <span class="number">3306</span>          <span class="comment"># 数据库端口</span></span><br><span class="line">db_user = <span class="string">&#x27;root&#x27;</span>        <span class="comment"># mysql用户名</span></span><br><span class="line">db_pwd = <span class="string">&#x27;yourpassword&#x27;</span> <span class="comment"># mysql用户密码,换成你的密码</span></span><br><span class="line">db_name = <span class="string">&#x27;test&#x27;</span>        <span class="comment"># 数据库名</span></span><br><span class="line">db_table = <span class="string">&#x27;filter_fields&#x27;</span>  <span class="comment"># 数据库表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤sql字段结果中的\t\n</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_data</span>(<span class="params">table_name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host=db_host, port = db_port, user=db_user,</span><br><span class="line">                               passwd = db_pwd, db = db_name, charset = <span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;数据库连接异常&#x27;</span></span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sql = <span class="string">&#x27;select * from %s;&#x27;</span>%(table_name)</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        rows = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;====字段未过滤查询结果====&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            <span class="built_in">print</span> row</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;====字段过滤之后结果====&#x27;</span></span><br><span class="line">        rows_list = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            row_list = []</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> row:</span><br><span class="line">                row_list.append(column.replace(<span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            rows_list.append(row_list)</span><br><span class="line">            <span class="built_in">print</span> rows_list[-<span class="number">1</span>]		<span class="comment"># [-1]表示列表最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> rows_list</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;执行sql语句失败&#x27;</span></span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.close()</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;begin:&#x27;</span></span><br><span class="line">    rows = extract_data(db_table)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>看看输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====字段未过滤查询结果====</span><br><span class="line">(u&#x27;test01&#x27;, u&#x27;test02&#x27;, u&#x27;test03&#x27;, u&#x27;test04&#x27;, u&#x27;test05&#x27;, u&#x27;test06&#x27;)</span><br><span class="line">(u&#x27;test11\ntest11&#x27;, u&#x27;test12\n\n&#x27;, u&#x27;test13&#x27;, u&#x27;test14&#x27;, u&#x27;test15&#x27;, u&#x27;test16&#x27;)</span><br><span class="line">(u&#x27;test21\ttest21&#x27;, u&#x27;test22\ttest22\ttest22&#x27;, u&#x27;test23\t\t\t&#x27;, u&#x27;test4&#x27;, u&#x27;test5&#x27;, u&#x27;test6&#x27;)</span><br><span class="line">(u&#x27;test21\rest21&#x27;, u&#x27;test22\r\rest22\r\rest22&#x27;, u&#x27;test23\r\r\r&#x27;, u&#x27;test4&#x27;, u&#x27;test5&#x27;, u&#x27;test6&#x27;)</span><br><span class="line">====字段过滤之后结果====</span><br><span class="line">[u&#x27;test01&#x27;, u&#x27;test02&#x27;, u&#x27;test03&#x27;, u&#x27;test04&#x27;, u&#x27;test05&#x27;, u&#x27;test06&#x27;]</span><br><span class="line">[u&#x27;test11test11&#x27;, u&#x27;test12&#x27;, u&#x27;test13&#x27;, u&#x27;test14&#x27;, u&#x27;test15&#x27;, u&#x27;test16&#x27;]</span><br><span class="line">[u&#x27;test21test21&#x27;, u&#x27;test22test22test22&#x27;, u&#x27;test23&#x27;, u&#x27;test4&#x27;, u&#x27;test5&#x27;, u&#x27;test6&#x27;]</span><br><span class="line">[u&#x27;test21est21&#x27;, u&#x27;test22est22est22&#x27;, u&#x27;test23&#x27;, u&#x27;test4&#x27;, u&#x27;test5&#x27;, u&#x27;test6&#x27;]</span><br></pre></td></tr></table></figure>
<p>可以看到,制表符,换行符,回车都被过滤了.<br>**建议:**最后说点题外话,不要小视<code>\r</code>,回车符.很多人以为回车符就是换行符,其实不是的,<code>\r</code>表示回车符,<code>\n</code>表示新行.之前代码里其实是过滤掉了<code>\t\n</code>的,但是抽取的数据还是不对,后来看了源码之后才发现,原来是没有过滤<code>\r</code>,就这个不同导致了很多数据抽取不对.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python yield剖析</title>
    <url>/2015/12/20/Python-yield%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>首先,这个东西在其他的面向对象的语言里好像没有,所以第一次碰到难免会有些不好理解,网上看到的教程,做个笔记整理以后不懂再来看看.<br>要讲<code>yield</code>就必须先讲讲Python中的迭代器(iterator)和生成器(generator)</p>
<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h3><p>在Python中,for循环比其他的语言中的都要强大,可以用来遍历Python中的任何类型,包括列表,元祖等,其实根本的判断原则就是:</p>
<blockquote>
<p>for 循环可以用于任何 <strong>可迭代对象</strong></p>
</blockquote>
<p>这个含义就是迭代器,迭代器是一个实现了迭代器协议的对象,Python中的迭代器协议规定了必须有<code>next()</code>方法,调用这个方法会前进到下一个结果,当迭代器到达末尾的时候,会触发<code>StopIteration</code>.具有这些特性的对象在Python中都可以用for循环或其他遍历工具迭代,迭代的时候,每次都会调用<code>next()</code>方法,并且一旦捕捉到<code>StopIteration</code>异常就会停止迭代.<br>使用迭代器除了在写代码的时候看上去更简洁,优雅,更大的一个好处就是:每次只从对象中读取一条数据,不会造成过大的开销.<br>举个读文件的例子,一般我们会经常用到逐行读取一个文件的内容,利用<code>readlines()</code>方法,可以这么写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).readlines():</span><br><span class="line">	<span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>
<p>看上去代码确实很优雅,简洁,但其实这并不是最好的方法,因为这其实也是一次把文件加载到了内存,然后再逐行遍历打印的,内存卡销很大,碰上一个很大的文件,程序有可能会崩溃.<br>这个时候我们可以利用<code>file</code>迭代器,优化之后的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>
<p>虽然代码改动很小,甚至还去掉了一些代码,但是这个是运行速度最快的读文件的一种方法,没有显示的去读文件,而是利用迭代器每次读取下一行.</p>
<h3 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h3><p>生成器函数在Python中与迭代器协议的概念联系在一起.简而言之,包含<code>yield</code>语句的函数会被特地编译成生成器.于是当我们调用这类函数的时候,会返回一个生成器对象,这个对象支持迭代器接口.而且就算函数有个<code>return</code>,它的作用也是用来<code>yield</code>产生值的.也就是不像一般的函数会生成值后退出,生成器函数在生成值后会自动挂起并暂停它们的执行状态,本地变量会保存状态信息,当函数恢复时将再度有效:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i **<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span> i, <span class="string">&#x27;:&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>:<span class="number">4</span>:<span class="number">9</span>:<span class="number">16</span>:</span><br></pre></td></tr></table></figure>
<p>这么看好像也不太容易懂,我们用迭代器的<code>next()</code>方法来看看具体的运行原理:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = g(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.<span class="built_in">next</span>()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  StopIteration</span><br></pre></td></tr></table></figure>
<p>在运行完5次<code>next()</code>之后，生成器抛出了一个<code>StopIteration</code>异常，迭代终止。再来看一个<code>yield</code>的例子，用生成器生成一个<code>Fibonacci</code>数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line"><span class="meta">... </span>    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &lt;= <span class="built_in">max</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> b</span><br><span class="line"><span class="meta">... </span>            a, b = b, a + b</span><br><span class="line"><span class="meta">... </span>            n += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> n,</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p> **解释:**在<code>for</code>循环执行时，每次循环都会执行<code>fab</code>函数内部的代码，执行到<code>yield b</code>时，<code>fab</code>函数就返回一个迭代值，下次迭代时，代码从<code>yield b</code>的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到<code>yield</code>.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python file() argument 1 must be encoded string without NULL bytes, not str</title>
    <url>/2015/12/17/Python-file-argument-1-must-be-encoded-string-without-NULL-bytes-not-str/</url>
    <content><![CDATA[<p>心血来潮想写个<code>tcp</code>的服务端和客户端来向服务器传文件，其中为了让服务器在我正式传文件之前知道我所要传文件的详细信息，我用了<code>struct.pack()</code>函数，给文件名留了256个字节的内容。<br>这个时候问题就来了，一般我传的文件名称并没有那么长，但是这样名字是可以传过去，但是每次一调用<code>fp = open(file_path, &#39;wb&#39;)</code>就报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 2.7 TypeError: file() argument 1 must be encoded string without NULL bytes, not str</span><br></pre></td></tr></table></figure>
<p>打印出来确实没有问题，是我的文件名，那到底是哪里出问题了？<br>仔细看报错信息,大概明白了，原来这里有个坑，Python是用C写的，所以Python里的字符串和C里面的<code>char[]</code>数组一样，是以<code>\0</code>结尾的，所以当你的路径里含有这些空值的时候，打开会报错，可以验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repr(file_path)</span><br><span class="line">Python/socket/udp/Django-1.8.5.tar.gz\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<p>看到没有，果然有很多这种值，原来在调用<code>struct.pack()</code>函数的时候，不足的地方会填上这些空的东西，<code>print</code>是不会显示的，但是在打开文件的时候就悲剧了。<br>解决办法：<br>直接把这些空的去掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_path.strip(&#x27;\0&#x27;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数及函数参数</title>
    <url>/2015/10/10/Python-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>方法或者说函数的使用，这个和其他编程语言<code>Java/C++</code>没什么区别，使用正确的方法名加参数就可以，<code>python</code>还有一个比较人性化的地方：在交互命令行下通过<code>help(functionName)</code>可以查看指定函数的使用帮助。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">help</span>(range)</span><br></pre></td></tr></table></figure>
<p>会出现如下内容，按<code>q</code>退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Help on built-in function range in module __builtin__:</span><br><span class="line"></span><br><span class="line">range(...)</span><br><span class="line">    range(stop) -&gt; list of integers</span><br><span class="line">    range(start, stop[, step]) -&gt; list of integers</span><br><span class="line">    </span><br><span class="line">    Return a list containing an arithmetic progression of integers.</span><br><span class="line">    range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.</span><br><span class="line">    When step is given, it specifies the increment (or decrement).</span><br><span class="line">    For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!</span><br><span class="line">    These are exactly the valid indices for a list of 4 elements.</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>定义函数<br>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。<br>我们以自定义一个求绝对值的<code>my_abs</code>函数为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>空函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> <code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。<br> <code>pass</code>还可以用在其他语句里，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> 缺少了<code>pass</code>，代码运行就会有语法错误。</p>
</li>
<li><p>参数检查<br>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: my_abs() takes exactly 1 argument (2 given)</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 但是如果参数类型不对，Python解释器就无法帮我们检查。试试<code>my_abs</code>和内置函数<code>abs</code>的差别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line">&gt;&gt;&gt; abs(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> abs(): <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>my_abs</code>没有参数检查，所以，这个函数定义不够完善。</p>
<p> 让我们修改一下<code>my_abs</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance</code>实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p> 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 3, <span class="keyword">in</span> my_abs</span><br><span class="line">TypeError: bad operand <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p> 错误和异常处理将在后续讲到，此处只需要大概知道这个可以抛出一个异常就行了。</p>
<ul>
<li><p>返回多个值<br>一般像<code>Java/C++</code>这样的语言，要想函数返回多个值，通常有两种方式：第一种，如果返回值的类型一样，那么一般就是返回一个列表或者数组对象，然后要用就去列表里取；第二种，返回值类型不一样，这种情况通常是定义一个结构体或者类来接收。但是对于Python，就不用这么麻烦了，看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>
<p> 在命令式交互行里看看返回值，<code>x</code>和<code>y</code>也可以直接单独使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> x, y</span><br><span class="line">151.961524227 70.0</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong>虽然可以这么用，但是具体中间的过程还必须了解，其实返回值还是单一值，看下面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> r</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure>
<p> 可以看到，返回值是一个<code>tuple</code>！，但是<code>python</code>的语法上返回一个<code>tuple</code>可以省略括号，同时多个变量又可以同事接收一个<code>tuple</code>，即相当于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x,y = r</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数<br><code>C++</code>里函数可以设置缺省参数，<code>Java</code>不可以，只能通过重载的方式来实现，<code>python</code>里也可以设置默认参数,最大的好处就是降低函数难度，函数的定义只有一个，<code>并且python是动态语言，在同一名称空间里不能有想多名称的函数，如果出现了，那么后出现的会覆盖前面的函数</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p> 看看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5,3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 必选参数在前，默认参数在后，否则Python的解释器会报错。<br> <strong>建议：</strong>*当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ul>
<p> 默认参数也有坑，看看下面的代码，先定义一个<code>list</code>，添加一个<code>end</code>再返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<p> 看看调用结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p> 这里需要解释一下，<code>Python</code>函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>。此时<code>L</code>指向<code>[]</code>。所以如果<code>L</code>中的内容改变了，下次调用引用的内容也就不再是<code>[]</code>了。所以要牢记一点<code>定义默认参数必须指向不可变对象！</code>。具体想深入了解可以看看<a href="../Python-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E9%99%B7%E9%98%B1/index.html">Python 默认参数陷阱</a></p>
<ul>
<li><p>可变参数<br>第一种方法，传入的参数为一个<code>list</code>或者<code>tuple</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p> 调用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line">84</span><br></pre></td></tr></table></figure>
<p> 第二种方式，直接传入多个参数，函数内部会自动用一个<code>tuple</code>接收。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p> 调用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p> 这个时候如果还想把一个<code>list</code>或者<code>tuple</code>里的数据传进去，可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数<br>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw</span><br></pre></td></tr></table></figure>
<p> 调用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(<span class="string">&#x27;Michael&#x27;</span>, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; person(<span class="string">&#x27;Bob&#x27;</span>, 35, city=<span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">name: Bob age: 35 other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; person(<span class="string">&#x27;Adam&#x27;</span>, 45, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">name: Adam age: 45 other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数组合<br>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</p>
</li>
<li><p>递归函数<br>基本的也没什么可讲的，和<code>Java/C++</code>里一样，就是调用本身的一种。这里重点介绍一下<code>尾递归</code>优化。事实上尾递归和循环效果是一样的，很显然的一个优点那就是可以防止递归调用栈溢出。<br><strong>定义：</strong>在函数返回的时候调用自身，并且，<code>return语句不能包含表达式</code>。编译器或者解释器可以对其做优化，无论调用多少次，只占用一个栈帧，不会出现溢出的情况。<br>举个简单的例子，以阶乘函数为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p> 如果传入的n很大，就可能会溢出，这是由于<code>return n * fact(n - 1)</code>引入了乘法表达式，就不是尾递归了。把代码改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>
<p> 但是一般不要用，有两点原因：1.python不支持尾递归优化；2.这样优化的代码可读性和逻辑性没有之前单纯的递归清晰。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 包 模块之间引用</title>
    <url>/2016/02/20/Python-%E5%8C%85-%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>Python在涉及到跨包的模块引用的时候，并不像Java这种语言那样，可以做到自动查找包路径。在网上也看到各种说法，有些还是不行，所以打算亲自实验一番。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>实验环境：</p>
<blockquote>
</blockquote>
<p>OS：Ubuntu<br>Python: Python 2.7.10+<br>IDE:PyCharm</p>
<p>实验之前还要说一下，Python里面，必须在每个文件夹下面建一个<code>__init__.py</code>，这个文件是空的，但是必须要有这个文件，Python才会把这个文件夹视为一个<code>Python Package</code>，包里面的文件就可以称为模块。<br>首先看看测试工程的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  package_ref  tree</span><br><span class="line">.</span><br><span class="line">├── module1</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── m11.py</span><br><span class="line">│   ├── m12.py</span><br><span class="line">│   └── module11</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── m1_m11.py</span><br><span class="line">├── module2</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── m21.py</span><br><span class="line">├── module3</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── m31.py</span><br><span class="line">└── m.py</span><br></pre></td></tr></table></figure>
<p>具体的引用关系为：  </p>
<ol>
<li>m21.py引用了m11,m12中的函数  </li>
<li>m31引用了m1_11中的函数  </li>
<li>m.py引用了m11,m12中的函数</li>
</ol>
<h3 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h3><ul>
<li>m11.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m11 func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m11 func2&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>m12.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m12 func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m12 func2&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>m1_m11.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m1_m11 func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m1_m11 func2&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>m21.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> m11, m12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    m11.func1()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m21 func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    m12.func2()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m21 func2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure></li>
<li>m31.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> module1.module11 <span class="keyword">import</span> m1_m11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    m1_m11.func1()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m31 func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    m1_m11.func2()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m31 func2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure></li>
<li>m.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> m11, m12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    m11.func1()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    m12.func2()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;m func2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>在PyCharm里执行，全部都可以正确执行,进入<code>package_ref</code>根目录，终端中执行<code>python m.py</code>,也没有问题。<br>进入<code>module2</code>目录，执行<code>python m21.py</code>，报错：</p>
<blockquote>
</blockquote>
<p>Traceback (most recent call last):<br>  File “module2&#x2F;m21.py”, line 3, in <module><br>    from module1 import m11, m12<br>ImportError: No module named module1</p>
<p>进入module3也是同样的错误。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在报错的文件中，引入本地包里面的模块之前，头部加上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;..&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其他地方不用改变，测试之后在pyCharm和终端中执行都没有问题。</p>
<p>**备注:**详细的工程在github上也有，git地址为<a href="https://github.com/sjq597/python_package_ref">python-package_ref</a></p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 写csv文件Excel打开乱码解决方案</title>
    <url>/2016/04/24/Python-%E5%86%99csv%E6%96%87%E4%BB%B6Excel%E6%89%93%E5%BC%80%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>最近为公司开发了一套邮件日报程序，邮件一般就是表格，图片，然后就是附件。附件一般都是默认写到txt文件里，但是PM希望邮件里的附件能直接用Excel这种软件打开，最开始想保存为Excel，但是一想Excel的文件体积会多出好多倍，csv文件默认也是使用Excel打开的，但是根本还是文本文件，体积小，保存也方便，于是最终决定使用csv模块来保存文件。</p>
<h3 id="Python写csv文件"><a href="#Python写csv文件" class="headerlink" title="Python写csv文件"></a>Python写csv文件</h3><p>Python提供了内置模块读写csv文件，这里我只用到了写，读这里就不做介绍了，也不难,主要是解决乱码问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def save2csv(file_name=None, header=None, data=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    保存成CSV格式文件,方便Excel直接打开</span><br><span class="line">    :param file_name: 保存的文件名</span><br><span class="line">    :param header: 表头,每一列的名字</span><br><span class="line">    :param data: 具体填充数据</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if file_name is None or isinstance(file_name, basestring) is False:</span><br><span class="line">        raise Exception(&#x27;保存CSV文件名不能为空,并且必须为字符串类型&#x27;)</span><br><span class="line"></span><br><span class="line">    if file_name.endswith(&#x27;.csv&#x27;) is False:</span><br><span class="line">        file_name += &#x27;.csv&#x27;</span><br><span class="line"></span><br><span class="line">    file_obj = open(file_name, &#x27;wb&#x27;)</span><br><span class="line">    file_obj.write(codecs.BOM_UTF8)     # 防止乱码</span><br><span class="line">    writer = csv.writer(file_obj)</span><br><span class="line"></span><br><span class="line">    if data is None or isinstance(data, (tuple, list)) is False:</span><br><span class="line">        raise Exception(&#x27;保存CSV文件失败,数据为空或者不是数据类型&#x27;)</span><br><span class="line"></span><br><span class="line">    if header is not None and isinstance(header, (tuple, list)) is True:</span><br><span class="line">        writer.writerow(header)</span><br><span class="line"></span><br><span class="line">    for row in data:</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure>
<p>**注意:**有三句话就是为了防止乱码的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_obj = open(file_name, &#x27;wb&#x27;)</span><br><span class="line">file_obj.write(codecs.BOM_UTF8)     # 防止乱码</span><br><span class="line">writer = csv.writer(file_obj)</span><br></pre></td></tr></table></figure>
<p>在文件头部写入<code>codecs.BOM_UTF8</code>就能防止乱码了,文件都是utf-8编码格式的。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多线程</title>
    <url>/2016/06/18/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="全局解释器锁"><a href="#全局解释器锁" class="headerlink" title="全局解释器锁"></a>全局解释器锁</h3><p>谈到Python多线程,不得不先说一下全局解释器锁(GIL),Python代码的执行由Python虚拟机(也叫解释器主循环)来控制,虽然有多个进程,但是某一个时刻只会有一个线程在执行,对Python虚拟机的访问由全局解释器锁(global interpreter lock,GIL)来控制,正是由于有GIL,同一时刻只会有一个线程在运行,具体的执行步骤为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 设置GIL</span><br><span class="line">2. 切换到一个线程去运行</span><br><span class="line">3. 运行</span><br><span class="line">   a. 运行指定字节码的指令,或者</span><br><span class="line">   b. 线程主动让出控制</span><br><span class="line">4. 把线程设置为睡眠状态</span><br><span class="line">5. 解锁GIL</span><br><span class="line">6. 重复以上所有步骤</span><br></pre></td></tr></table></figure>
<p>所以在调用外部代码的时候,GIL会被锁定,直到调用函数结束为止，看到这里,你可能会觉得Python程序的效率会非常低,毕竟我们的程序会去访问数据库,外部接口,加载本地文件,如果是这样,那我们的程序基本上无时无刻都是卡在那等着。其实你完全不用担心,所有面向I&#x2F;O的(即调用内建的操作系统C代码)的程序,GIL会在这个I&#x2F;O调用之前被释放,这样其他程序是可以在等待I&#x2F;O的时候执行的。不过如果一个程序并没有很多I&#x2F;O操作,那他只要运行,就一直占用CPU,多线程只对那些I&#x2F;O密集的程序更有好处。</p>
<h3 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h3><p>其实还有一个模块叫<code>thread</code>,但是这个模块使用特别麻烦,官方不建议使用,其中对于锁的操作特别麻烦,而且还有个很大的问题,一旦主进程退出,不管子线程运行完没有都会被强制结束。所以我也不介绍这个模块怎么用了，我们直接看<code>threading</code>模块的使用。</p>
<h4 id="传入可调用函数"><a href="#传入可调用函数" class="headerlink" title="传入可调用函数"></a>传入可调用函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import threading</span><br><span class="line">from time import sleep, ctime</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">loops = [4, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loop(n_loop, n_sec):</span><br><span class="line">    print &#x27;开始线程&#x27;, n_loop, &#x27;于&#x27;, ctime()</span><br><span class="line">    sleep(n_sec)</span><br><span class="line">    print &#x27;loop函数&#x27;, n_loop, &#x27;完成于&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print &#x27;开始主线程：&#x27;, ctime()</span><br><span class="line">    threads = []        # 一个用于储存线程对象的列表</span><br><span class="line">    n_loops = range(len(loops))</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        t = threading.Thread(target=loop, args=(i, loops[i]))   # 每次循环创建一个Thread的实例</span><br><span class="line">        threads.append(t)   # 将新创建的对象放到一个列表中</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].start()  # 每次循环运行一个线程</span><br><span class="line"></span><br><span class="line">    or i in n_loops:</span><br><span class="line">        threads[i].join()   # 等待子线程的完成</span><br><span class="line"></span><br><span class="line">    print &#x27;主线程完成：&#x27;, ctime()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始主线程： Sat Jun 18 19:47:40 2016</span><br><span class="line">开始线程 开始线程0 于  Sat Jun 18 19:47:40 20161</span><br><span class="line"> 于 Sat Jun 18 19:47:40 2016</span><br><span class="line">loop函数 1 完成于 Sat Jun 18 19:47:42 2016</span><br><span class="line">loop函数 0 完成于 Sat Jun 18 19:47:44 2016</span><br><span class="line">主线程完成： Sat Jun 18 19:47:44 2016</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>一旦调用<code>start()</code>方法被调用的函数就开始执行了,如果你在主函数里面还要做其他操作，并且这个操作与子线程的执行无关，你完全不用调用<code>join()</code>，可以去做其他操作。调用<code>join()</code>会一直等待子线程执行完毕返回然后再执行后面的步骤。<br>**注意:**这个输出并不是连串的,因为我的CPU是多核的，所以日志看上去有点儿不太正常。<code>target</code>一个可调用对象，这里我们传入了一个函数;<code>args</code>是一个元祖，均以位置参数的方式传递给被调用对象。</p>
<h4 id="传入可调用类"><a href="#传入可调用类" class="headerlink" title="传入可调用类"></a>传入可调用类</h4><p>我们也可以传入一个可调用类给<code>Thread</code>实例，不过类必须要实现<code>__call()__</code>方法，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import threading</span><br><span class="line">from time import sleep, ctime</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">loops = [4, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loop(n_loop, n_sec):</span><br><span class="line">    print &#x27;开始线程&#x27;, n_loop, &#x27;于&#x27;, ctime()</span><br><span class="line">    sleep(n_sec)</span><br><span class="line">    print &#x27;loop函数&#x27;, n_loop, &#x27;完成于&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ThreadFunc(object):</span><br><span class="line">    def __init__(self, func, args):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    def __call__(self):  # 关键是要实现这个方法</span><br><span class="line">        apply(self.func, self.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print &#x27;开始主线程：&#x27;, ctime()</span><br><span class="line">    threads = []  # 一个用于储存线程对象的列表</span><br><span class="line">    n_loops = range(len(loops))</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        t = threading.Thread(target=ThreadFunc(func=loop, args=(i, loops[i])), )  # 每次循环创建一个Thread的实例，目标是一个类</span><br><span class="line">        threads.append(t)  # 将新创建的对象放到一个列表中</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].start()  # 每次循环运行一个线程</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].join()  # 等待子线程的完成</span><br><span class="line"></span><br><span class="line">    print &#x27;主线程完成：&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>函数的执行结果和上面是一样的，这里我就不再贴运行结果了。</p>
<h4 id="创建Thread子类"><a href="#创建Thread子类" class="headerlink" title="创建Thread子类"></a>创建Thread子类</h4><p>这种方式比较灵活，更加通用，只用在内部冲洗run方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import threading</span><br><span class="line">from time import sleep, ctime</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">loops = [4, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loop(n_loop, n_sec):</span><br><span class="line">    print &#x27;开始线程&#x27;, n_loop, &#x27;于&#x27;, ctime()</span><br><span class="line">    sleep(n_sec)</span><br><span class="line">    print &#x27;loop函数&#x27;, n_loop, &#x27;完成于&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def __init__(self, func, args):</span><br><span class="line">        threading.Thread.__init__(self)  # 调用父类的构造函数</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        apply(self.func, self.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print &#x27;开始主线程：&#x27;, ctime()</span><br><span class="line">    threads = []  # 一个用于储存线程对象的列表</span><br><span class="line">    n_loops = range(len(loops))</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        t = MyThread(func=loop, args=(i, loops[i]))  # 使用我们自己的类来新建对象</span><br><span class="line">        threads.append(t)  # 将新创建的对象放到一个列表中</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].start()  # 每次循环运行一个线程</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].join()  # 等待子线程的完成</span><br><span class="line"></span><br><span class="line">    print &#x27;主线程完成：&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>调用子类<code>MyThread</code>的<code>start()</code>方法即可，同样<code>join()</code>用于等待自线程执行完。这种方式相比上面的两种方式好处在哪？想象一下，我们的函数执行如果返回的是一个二维数组，如果仅仅有<code>start(),join()</code>这样的方法，我们怎么获取最后我们执行的返回值呢？如果是子类，我们完全可以在调用<code>run()</code>方法里面把这个结果保存下来，然后最后调用子类的实例去获取这个变量就行了,像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import threading</span><br><span class="line">from time import sleep, ctime</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">loops = [4, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loop(n_loop, n_sec):</span><br><span class="line">    return n_loop + n_sec  # 返回两个参数的和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def __init__(self, func, args):</span><br><span class="line">        threading.Thread.__init__(self)  # 调用父类的构造函数</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        self.result = None</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.result = apply(self.func, self.args)  # 调用函数的结果作为一个属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print &#x27;开始主线程：&#x27;, ctime()</span><br><span class="line">    threads = []  # 一个用于储存线程对象的列表</span><br><span class="line">    n_loops = range(len(loops))</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        t = MyThread(func=loop, args=(i, loops[i]))  # 使用我们自己的类来新建对象</span><br><span class="line">        threads.append(t)  # 将新创建的对象放到一个列表中</span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].start()  # 每次循环运行一个线程</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        threads[i].join()  # 等待子线程的完成</span><br><span class="line"></span><br><span class="line">    for i in n_loops:</span><br><span class="line">        print &#x27;执行结果为：&#x27;, threads[i].result  # 打印该对象的属性</span><br><span class="line"></span><br><span class="line">    print &#x27;主线程完成：&#x27;, ctime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始主线程： Sat Jun 18 20:11:51 2016</span><br><span class="line">执行结果为： 4</span><br><span class="line">执行结果为： 3</span><br><span class="line">主线程完成： Sat Jun 18 20:11:51 2016</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="Python进程池"><a href="#Python进程池" class="headerlink" title="Python进程池"></a>Python进程池</h3><p>实际在项目中，我们可能会碰到这样的问题，有一个MySQL的表分库分表了，总数大概有1000张，我们想看看每天的数据量有多大，由于这个是线上的库，我们不能开太多的连接，如果把数据库搞挂了不好，但是一个一个去算又太慢，所以需要控制连接的数量，太大太小都不好，这个时候可以使用进程池，控制并发的数量。</p>
<h4 id="进程池-非阻塞"><a href="#进程池-非阻塞" class="headerlink" title="进程池(非阻塞)"></a>进程池(非阻塞)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">from multiprocessing import freeze_support, Pool</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print &#x27;time start:%s&#x27; % time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    return i + 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Bar(arg):</span><br><span class="line">    print &#x27;time  done:%s %s&#x27; % (time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;), arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    freeze_support()</span><br><span class="line">    pool = Pool(3)  # 线程池中的同时执行的进程数为3</span><br><span class="line"></span><br><span class="line">    for i in range(4):</span><br><span class="line">        pool.apply_async(func=Foo, args=(i,), callback=Bar)  # 线程池中的同时执行的进程数为3，当一个进程执行完毕后，如果还有新进程等待执行，则会将其添加进去</span><br><span class="line"></span><br><span class="line">    print(&#x27;end&#x27;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">time start:2016-06-19 18:08:12</span><br><span class="line">time  done:2016-06-19 18:08:12 100</span><br><span class="line">time start:2016-06-19 18:08:12</span><br><span class="line">time  done:2016-06-19 18:08:12 101</span><br><span class="line">time start:2016-06-19 18:08:12</span><br><span class="line">time  done:2016-06-19 18:08:12 102</span><br><span class="line">time start:2016-06-19 18:08:14</span><br><span class="line">time  done:2016-06-19 18:08:14 103</span><br></pre></td></tr></table></figure>
<p>进程池的大小为3，很明显可以看到，前三个函数的开始时间都是一样的，并且都是不等<code>Foo</code>函数执行完就掉用<code>Bar</code>函数</p>
<ul>
<li><code>apply_async(func[, args[, kwds[, callback]]])</code>它是<strong>非阻塞</strong>，<code>apply(func[, args[, kwds]])</code>是<strong>阻塞</strong>的.</li>
<li><code>close()</code>关闭pool,使其不再接受新的任务</li>
<li><code>join()</code> 主进程阻塞，等待子进程退出，必须在<code>close()</code>和<code>terminate()</code>之后调用</li>
</ul>
<h4 id="进程池-阻塞"><a href="#进程池-阻塞" class="headerlink" title="进程池(阻塞)"></a>进程池(阻塞)</h4><p>和上面的代码差不多，只是把对应部分改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">from multiprocessing import freeze_support, Pool</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print &#x27;time start:%s&#x27; % time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    return i + 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Bar(arg):</span><br><span class="line">    print &#x27;time  done:%s %s&#x27; % (time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;), arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    freeze_support()</span><br><span class="line">    pool = Pool(3)  # 线程池中的同时执行的进程数为3</span><br><span class="line"></span><br><span class="line">    for i in range(4):</span><br><span class="line">        pool.apply(func=Foo, args=(i,))</span><br><span class="line"></span><br><span class="line">    print(&#x27;end&#x27;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span><br></pre></td></tr></table></figure>
<p>执行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time start:2016-06-19 18:14:00</span><br><span class="line">time start:2016-06-19 18:14:02</span><br><span class="line">time start:2016-06-19 18:14:04</span><br><span class="line">time start:2016-06-19 18:14:06</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="进程池-关注返回结果"><a href="#进程池-关注返回结果" class="headerlink" title="进程池(关注返回结果)"></a>进程池(关注返回结果)</h4><p>多半情况下我们还是要关注函数的执行返回结果，并不能完全想像上面那样阻塞运行或者非阻塞等函未执行完就调用回调函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import multiprocess</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func(msg):</span><br><span class="line">    print &#x27;time start:%s&#x27; % time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print &#x27;time   end:%s&#x27; % time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    return &#x27;done&#x27; + msg</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = multiprocess.Pool(2)</span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    for i in range(3):</span><br><span class="line">        msg = &#x27;hello %s&#x27; % i</span><br><span class="line">        result.append(pool.apply_async(func=func, args=(msg,)))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    for res in result:</span><br><span class="line">        print &#x27;***: %s&#x27; % res.get()</span><br><span class="line"></span><br><span class="line">    print &#x27;end&#x27;</span><br></pre></td></tr></table></figure>
<p>执行看一下返回结果是啥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time start:2016-06-19 18:43:22</span><br><span class="line">time start:2016-06-19 18:43:22</span><br><span class="line">time   end:2016-06-19 18:43:24</span><br><span class="line">time start:2016-06-19 18:43:24</span><br><span class="line">time   end:2016-06-19 18:43:24</span><br><span class="line">time   end:2016-06-19 18:43:26</span><br><span class="line">***: done hello 0</span><br><span class="line">***: done hello 1</span><br><span class="line">***: done hello 2</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可以看到，我们可以使用<code>get()</code>方法获取被调用函数的返回值</p>
<h4 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h4><p>还有一种方式，可以使用<code>pool.map()</code>，以我们最开始的例子为例，我们要查询1000张表，可以把参数放在一个可迭代对象里，使用pool.map()找依次多个处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def m1(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    i_list = range(8)</span><br><span class="line">    result = pool.map(m1, i_list)</span><br><span class="line"></span><br><span class="line">    print sum(result)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>集合,循环控制</title>
    <url>/2015/10/09/Python-%E9%9B%86%E5%90%88,%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="python常用结构"><a href="#python常用结构" class="headerlink" title="python常用结构"></a>python常用结构</h3><p><code>python</code>常用结构有集合以及循环，另外集合包括列表和集合两大类。</p>
<h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><ul>
<li>有序列表list<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; listTest = [<span class="string">&#x27;ha&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;yes&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <code>len()</code>获取<code>list</code>元素个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(listTest)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p> 可以用索引来访问每一个元素，<code>0</code>表示第一个，<code>-1</code>还可以表示最后一个，即倒数第一个，依此类推<code>-2</code>表示倒数第二个，超过了也会报越界错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; listTest[0]</span><br><span class="line"><span class="string">&#x27;ha&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest[1]</span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">&gt;&gt;&gt; listTest[-1]</span><br><span class="line"><span class="string">&#x27;yes&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest[-2]</span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 也可以把元素插入到指定的位置，比如索引号为<code>1</code>的位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; listTest.insert(1,<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> 删除末尾元素，用<code>pop()</code>方法，添加到末尾用<code>append()</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; listTest.pop()</span><br><span class="line"><span class="string">&#x27;yes&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> 删除指定位置的元素，用<code>pop(i)</code>方法,其中<code>i</code>是索引位置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; listTest.pop(1)</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> 把某个元素替换，直接赋值即可,并且类型也可以不同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; listTest[1] = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;debug&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; listTest[1] = 123</span><br><span class="line">&gt;&gt;&gt; listTest</span><br><span class="line">[<span class="string">&#x27;ha&#x27;</span>, 123]</span><br></pre></td></tr></table></figure>

<p> <code>list</code>也可以嵌套:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, [<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>], <span class="string">&#x27;scheme&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; s[1]</span><br><span class="line"><span class="string">&#x27;java&#x27;</span></span><br><span class="line">&gt;&gt;&gt; s[2]</span><br><span class="line">[<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; s[2][1]</span><br><span class="line"><span class="string">&#x27;php&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 空的<code>list</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; len(L)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<ul>
<li>不可变列表tuple<br>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">(<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; classmates[1]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>
 <strong>注意：</strong>由于<code>tuple</code>不可变，所以代码更安全，如果可能，能用<code>tuple</code>代替<code>list</code>就尽量用<code>tuple</code>。<br> <code>tuple的陷阱：</code>当你定义一个<code>tuple</code>时，在定义的时候，<code>tuple</code>的元素就必须被确定下来，比如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure>
 如果要定义一个空的<code>tuple</code>，可以写成()：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
 但是，要定义一个只有1个元素的<code>tuple</code>，如果你这么定义：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
 定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</li>
</ul>
<p> 所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>
<p> <code>Python</code>在显示只有1个元素的<code>tuple</code>时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。<br> 最后来看一个<code>可变的</code>tuple：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">&gt;&gt;&gt; t[2][1] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong><code>tuple</code>所谓的<code>不变</code>是说，<code>tuple</code>的每个元素，指向永远不变。</p>
<ul>
<li>Map<br><code>Python</code>内置了字典：<code>dict</code>的支持，<code>dict</code>全称<code>dictionary</code>，在<code>Java/C++</code>中也称为<code>Map</code>，使用键-值（<code>key-value</code>）存储，具有极快的查找速度。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;<span class="string">&#x27;Michael&#x27;</span>: 95, <span class="string">&#x27;Bob&#x27;</span>: 75, <span class="string">&#x27;Tracy&#x27;</span>: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line">95</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 把数据放入<code>dict</code>的方法，除了初始化时指定外，还可以通过<code>key</code>放入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d[<span class="string">&#x27;Adam&#x27;</span>] = 67</span><br><span class="line">&gt;&gt;&gt; d[<span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">67</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong>如果key不存在，dict就会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d[<span class="string">&#x27;Thomas&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;Thomas&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p> 或者通过<code>dict</code>提供的<code>get</code>方法，如果<code>key</code>不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(<span class="string">&#x27;Thomas&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; d.get(<span class="string">&#x27;Thomas&#x27;</span>, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p> 删除<code>dict</code>里的元素，用<code>pop(key)</code>方法，对应的<code>value</code>也会从<code>dict</code>中删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;<span class="string">&#x27;Michael&#x27;</span>: 95, <span class="string">&#x27;Tracy&#x27;</span>: 85&#125;</span><br></pre></td></tr></table></figure>
<p> 正确使用<code>dict</code>非常重要，需要牢记的第一条就是<code>dict</code>的<code>key</code>必须是不可变对象。</p>
<ul>
<li>set集合<br><code>set</code>和<code>dict</code>类似，也是一组<code>key</code>的集合，但不存储<code>value</code>。由于<code>key</code>不能重复，所以，在<code>set</code>中，没有重复的<code>key</code>。<br>要创建一个<code>set</code>，需要提供一个<code>list</code>作为输入集合：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = <span class="built_in">set</span>([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line"><span class="built_in">set</span>([1, 2, 3])</span><br></pre></td></tr></table></figure>
 <code>set</code>会自动过滤重复元素，<code>add(key)</code>添加元素，可以重复添加，但是没有效果。<code>remove(key)</code>删除元素。对于两个集合，还可以通过<code>&amp;</code>取集合的交集，<code>|</code>取集合的并集。</li>
</ul>
<h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><ul>
<li><p>条件判断<br>之前学过<code>Java/C++</code>可能会不太习惯这种方式，先看看<code>python</code>的条件判断代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;your age is&#x27;</span>, age</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;adult&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 根据<code>Python</code>的缩进规则，缩进的代码块就相当于<code>Java/C++</code>里大括号的内容。即<code>if</code>为<code>True</code>,执行代码块内容，加<code>else</code>，<code>elif</code>同理，注意不要漏掉<code>:</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> <code>if</code>还可以简写，下面这个和<code>Java/C++</code>有很大的不同，<code>python</code>对类型的判断很宽松，只要<code>x</code>是非零数值、非空字符串、非空<code>list</code>等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;True&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>循环控制<br>循环和<code>Java/C++</code>就很像了，也是有两种:<code>for</code>循环和<code>while</code>循环。<br><code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进代码块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="built_in">print</span> name</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <code>while</code>循环,只要条件满足，就不断循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 参数解析</title>
    <url>/2016/06/29/Python-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>有时需要用到外部传入的参数，虽然简单的使用<code>*arg</code>数组可以获取到每个参数的值，但是有一个局限性就是参数必须按顺序传入，不能多也不能少。<br>但是考虑到有时候我们需要制定特定的参数的值，参数的个数，顺序都是不定的，这个时候单纯的靠<code>*args</code>显然无法满足我们的需求,这个时候就轮到<code>argparse</code>模块上场了，基本上一般的参数解析都可以胜任，下面看看怎么用：</p>
<h3 id="参数的几种解析方式"><a href="#参数的几种解析方式" class="headerlink" title="参数的几种解析方式"></a>参数的几种解析方式</h3><p>主要有四种方式，简单介绍一下,先介绍一下最简单的按顺序解析不带<code>key</code>指定参数形式:</p>
<h4 id="不带key按顺序解析"><a href="#不带key按顺序解析" class="headerlink" title="不带key按顺序解析"></a>不带key按顺序解析</h4><p>这种方式可以获取脚本运行时后面的所有参数，但是顺序由输入的顺序决定的，<br>先看看测试代码,假设文件名叫<code>args.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv:</span><br><span class="line">        <span class="built_in">print</span> arg</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>来一段测试代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python args.py 12 34 56 78                                                                                                </span><br><span class="line">args.py</span><br><span class="line">12</span><br><span class="line">34</span><br><span class="line">56</span><br><span class="line">78</span><br></pre></td></tr></table></figure>
<p>第一个参数就是python脚本的名字,后面四个就是四个参数了.但这个有时候我们希望我们传入参数的顺序可以是随意的，只要我们指定每个参数的<code>key</code>,程序就能解析到对应的参数值，那应该怎么做呢？下面介绍一下带<code>key</code>的参数解析。</p>
<h4 id="不带-参数"><a href="#不带-参数" class="headerlink" title="不带-参数"></a>不带<code>-</code>参数</h4><p>新建一个脚本<code>arg_demo.py</code>,然后输入以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parse = argparse.ArgumentParser()</span><br><span class="line">    parse.add_argument(&#x27;a&#x27;, help=&#x27;必填参数&#x27;)</span><br><span class="line">    args = parse.parse_args()</span><br><span class="line">    </span><br><span class="line">    print args.a  </span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>终端运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py                    </span><br><span class="line">usage: arg_demo.py [-h] a</span><br><span class="line">arg_demo.py: error: too few arguments</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py 我是参数           </span><br><span class="line">我是参数</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py 我是参数1 我是参数2</span><br><span class="line">usage: arg_demo.py [-h] a</span><br><span class="line">arg_demo.py: error: unrecognized arguments: 我是参数2</span><br><span class="line">➜  parameter git:(python-note) ✗ </span><br></pre></td></tr></table></figure>
<p>可以看出不带<code>-</code>的参数在调用脚本时必须输入值，并且输入的顺序必须和程序定义的一直，而且个数也得一致</p>
<h4 id="带-的参数"><a href="#带-的参数" class="headerlink" title="带-的参数"></a>带<code>-</code>的参数</h4><p>同样的文件，改动以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parse = argparse.ArgumentParser()</span><br><span class="line">    parse.add_argument(&#x27;-a&#x27;)</span><br><span class="line">    args = parse.parse_args()</span><br><span class="line"></span><br><span class="line">    print args.a</span><br></pre></td></tr></table></figure>
<p>同样，我们在终端中输入不同值运行一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py                          </span><br><span class="line">None</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py 我是参数                 </span><br><span class="line">usage: arg_demo.py [-h] [-a A]</span><br><span class="line">arg_demo.py: error: unrecognized arguments: 我是参数</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py -a 我是参数              </span><br><span class="line">我是参数</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py -a我是参数 </span><br><span class="line">我是参数</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py -a 我是参数1 -a 我是参数2</span><br><span class="line">我是参数2</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py -a 我是参数2 -a 我是参数1 </span><br><span class="line">我是参数1</span><br></pre></td></tr></table></figure>
<p>可以看出，带<code>-</code>的参数,可以输入也可以不输入，但是不能输入的时候不指定key,并且输入的key可以和参数分开或者连在一起，多次对一个key输入值，后面的会覆盖前面的输入。</p>
<h4 id="带-参数"><a href="#带-参数" class="headerlink" title="带--参数"></a>带<code>--</code>参数</h4><p><code>-</code>参数还可以指定<code>shorname</code>,即<code>--shortname</code>这种格式，表示变量的别名，改动一下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parse = argparse.ArgumentParser()</span><br><span class="line">    parse.add_argument(&#x27;-a&#x27;, &#x27;--another_name&#x27;, default=&#x27;我是默认参数&#x27;)</span><br><span class="line">    args = parse.parse_args()</span><br><span class="line"></span><br><span class="line">    print args.another_name</span><br></pre></td></tr></table></figure>
<p>同理在终端中运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py                          </span><br><span class="line">我是默认参数</span><br><span class="line">➜  parameter git:(python-note) ✗ python arg_demo.py -a输入参数</span><br><span class="line">输入参数</span><br></pre></td></tr></table></figure>
<p>可以看到如果不输入就输入默认值，输入了我们引用别名<code>another_name</code>也可以输出<code>-a</code>的值</p>
<h3 id="解析参数的其他属性"><a href="#解析参数的其他属性" class="headerlink" title="解析参数的其他属性"></a>解析参数的其他属性</h3><p><code>argparse</code>还有很多可选参数，用来设置我们解析参数的具体操作，例如:</p>
<ul>
<li><p>dest<br>这个参数表示绑定参数在程序中对应的变量名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_argument(&quot;a&quot;,dest=&#x27;code_name&#x27;)</span><br></pre></td></tr></table></figure>
<p>表示<code>a</code>参数直接绑定到程序中的变量值<code>code_name</code></p>
</li>
<li><p>default<br>为参数提供默认值，如果没有输入这个参数，就用默认值代替,注意不带<code>-</code>的参数不能制定默认值，因为不带<code>-</code>必须输入参数值，也就没有不输入而采用默认值的场景</p>
</li>
<li><p>help<br>参数的帮助文档，一般用来告诉用户这个参数是什么意思，起提示和指导作用</p>
</li>
<li><p>type<br>为参数指定一个类型，一般不指定的时候，默认会把输入的参数解析成字符串类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_argument(&quot;c&quot;, type=int)</span><br></pre></td></tr></table></figure>
</li>
<li><p>action<br>指对参数的具体操作</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>store</td>
<td>默认就是这个模式，存储值到制定变量</td>
</tr>
<tr>
<td>store_const</td>
<td>存储值在参数的const部分指定，多用于实现非布尔的命令行flag</td>
</tr>
<tr>
<td>store_true&#x2F;store_falst</td>
<td>布尔开关，store_true默认为False,输入则为True,store_false则相反</td>
</tr>
<tr>
<td>append</td>
<td>存储值到列表，该参数可以重复使用</td>
</tr>
<tr>
<td>append_const</td>
<td>存储值到列表，存储值在参数的const部分指定</td>
</tr>
<tr>
<td>count</td>
<td>统计参数简写输入的个数</td>
</tr>
<tr>
<td>version</td>
<td>输出版本信息然后退出</td>
</tr>
</tbody></table>
<ul>
<li><p>const<br>配合<code>action＝&quot;store_const|append_const&quot;</code>使用,默认值</p>
</li>
<li><p>choices<br>输入值的范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_argument(&quot;--gb&quot;, choices=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 0])</span><br></pre></td></tr></table></figure>
</li>
<li><p>required<br>默认为<code>False</code>，若为<code>True</code>，则必须输入该参数.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式笔记</title>
    <url>/2016/07/10/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>总结一下在工作中常用到的关于Python正则的一些用法,主要无非就是匹配提取置顶信息，或者替换指定信息,不过都是<code>re</code>模块的用法</p>
<h3 id="查找匹配"><a href="#查找匹配" class="headerlink" title="查找匹配"></a>查找匹配</h3><p>查找和匹配主要就是<code>re.search()</code>以及<code>re.match()</code></p>
<ul>
<li>match:从字符串的开始处匹配,匹配成功会返回<code>match object</code>,如果匹配不上返回None</li>
<li>search:只要又字串符合就匹配成功，返回<code>match object</code>,如果没有一个子串满足匹配则返回None</li>
<li>findall: 如果能匹配，返回所有的匹配结果list</li>
</ul>
<p>下面会以代码介绍一下如何使用以及提取出匹配到的内容:</p>
<h4 id="match-search"><a href="#match-search" class="headerlink" title="match,search"></a>match,search</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    str1 = &#x27;hello world, test test Test&#x27;</span><br><span class="line">    if not re.match(&#x27;world&#x27;, str1):</span><br><span class="line">        print &#x27;1:not match&#x27;</span><br><span class="line">    print &#x27;2:&#x27;, re.match(&#x27;hello&#x27;, str1).group()</span><br><span class="line">    print &#x27;3:&#x27;, re.match(&#x27;.*test&#x27;, str1).group()</span><br><span class="line">    print &#x27;4:&#x27;, re.match(&#x27;.*test&#x27;, str1, re.I).group()</span><br><span class="line">    print &#x27;5:&#x27;, re.search(&#x27;test&#x27;, str1, re.I).group()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:not match</span><br><span class="line">2: hello</span><br><span class="line">3: hello world, test test</span><br><span class="line">4: hello world, test test Test</span><br><span class="line">5: test</span><br></pre></td></tr></table></figure>
<ul>
<li>1, 2 说明<code>match()</code>只会从开头开始匹配,如果不是在开头则无法匹配</li>
<li>2, 3 说明如果要匹配的内容不是在字符串的开头，那么需要加<code>.*</code>或者类似的通配符</li>
<li>3, 4 说明<code>re.I</code>表示的是忽略大小写，</li>
<li>4, 5 可以看到<code>search()</code>函数则是在整个字符串里面去查找给定的模式，没有位置限制,但是只会匹配第一个，就算后面还有也不会输出来,所以只输出了一个<strong>test</strong>,后面的<strong>Test</strong>也没有输出来。</li>
</ul>
<h4 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h4><p>如果想获取指定内容应该怎么做呢？这里介绍一下正则里面的<code>()</code>,用括号匹配出来的内容可以通过<code>groups()</code>提取，看下面的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    str1 = &#x27;sfasfasfsfaname=hello phone=234123423 mail=23423@qq.com,hslfas7&#x27;</span><br><span class="line"></span><br><span class="line">    result = re.match(r&#x27;.*name=(\w*).*phone=(\d*) mail=(\d*@\w*.com).*&#x27;, str1, re.I)</span><br><span class="line"></span><br><span class="line">    if result is not None:</span><br><span class="line">        print result.groups()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#x27;hello&#x27;, &#x27;234123423&#x27;, &#x27;23423@qq.com&#x27;)</span><br></pre></td></tr></table></figure>
<p>可以看到，匹配结果被保存到了一个tuple里面，只要遍历这个tuple或者访问指定顺序的下标就可以获取相应的匹配结果了.<br>前面也说了，用<code>search()</code>匹配只会输出第一个匹配结果，而且上面的<code>match()</code>如果换成<code>search()</code>，调用<code>groups()</code>返回的结果和使用<code>match()</code>的结果是一样的,因为对于这个正则表达式来说，上面的匹配结果是第一个也是唯一一个。如果想返回字符串中所有出现的<strong>as</strong>应该怎么做呢？这个时候就需要用<code>findall()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    str1 = &#x27;sfasfasfsfaname=hello phone=234123423 mail=23423@qq.com,hslfas7&#x27;</span><br><span class="line"></span><br><span class="line">    result1 = re.findall(r&#x27;name=(\w*).*phone=(\d*) mail=(\d*@\w*.com)&#x27;, str1, re.I)</span><br><span class="line">    result2 = re.findall(r&#x27;as&#x27;, str1, re.I)</span><br><span class="line">    print result1</span><br><span class="line">    print result2</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(&#x27;hello&#x27;, &#x27;234123423&#x27;, &#x27;23423@qq.com&#x27;)]</span><br><span class="line">[&#x27;as&#x27;, &#x27;as&#x27;, &#x27;as&#x27;]</span><br></pre></td></tr></table></figure>
<p>可以看到<code>findall()</code>函数返回的是一个list，返回所有匹配的结果，如果正则里面有<code>()</code>提取内容，这写内容也会出现在里面，单独保存在一个tuple中.</p>
<h3 id="正则分割"><a href="#正则分割" class="headerlink" title="正则分割"></a>正则分割</h3><p>在Python中，如果想对一个字符串进行分割的话，只需要调用str的split方法就可以实现，但是这个split只能根据某个字符来进行分割的操作，如果要同时指定多个字符来进行分割的话，它就无法实现了。<br>好在re模块也提供了split这个方法来对字符串进行分割，而且这个方法更加强大，可以同时根据多个字符进行分割的操作，下面来看分别看一下str的split和re的split有什么不同的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    str1 = &#x27;helloword,i;am\nalex&#x27;</span><br><span class="line">    str2 = str1.split(&#x27;,&#x27;)</span><br><span class="line">    print str2</span><br><span class="line"></span><br><span class="line">    str3 = re.split(&#x27;[,|;|\n]&#x27;, str1)</span><br><span class="line">    print str3</span><br></pre></td></tr></table></figure>
<p>看看输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;helloword&#x27;, &#x27;i;am\nalex&#x27;]</span><br><span class="line">[&#x27;helloword&#x27;, &#x27;i&#x27;, &#x27;am&#x27;, &#x27;alex&#x27;]</span><br></pre></td></tr></table></figure>
<p>这里就可以看到差别是啥了，正则分割确实功能更加强大也更加灵活，可以用正则模式分割一个字符串</p>
<h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><p>讲到正则分割，当然少不了正则<code>replace()</code>，同理字符串也有替换方法，但是只能替换指定的内容，如果想达到模糊替换，只能用正则，不过正则里面的替换方法不叫<code>replace</code>，叫<code>sub()</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;anonymous&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    str1 = &#x27;Hello 111 is 222&#x27;</span><br><span class="line">    str2 = re.sub(r&#x27;\d+&#x27;, &#x27;333&#x27;, str1)</span><br><span class="line">    print str2</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello 333 is 333</span><br></pre></td></tr></table></figure>

<h3 id="正则查询表"><a href="#正则查询表" class="headerlink" title="正则查询表"></a>正则查询表</h3><p>平时记住一些常见的的正则用法，有些不太常用需要自己网上去查，这里整理记在一个表里，免得以后上网查:</p>
<p>正则速查表</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，<code>n</code>匹配字符<code>n</code>。<code>\n</code>匹配一个换行符。串行<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code>。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，<code>^</code>也匹配<code>\n</code>或<code>\r</code>之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，<code>$</code>也匹配<code>\n</code>或<code>\r</code>之前的位置。</td>
</tr>
</tbody></table>
<ul>
<li>|匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配<code>z</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code>。</li>
</ul>
<ul>
<li>|匹配前面的子表达式一次或多次。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code>。<br>? |匹配前面的子表达式零次或一次。例如，<code>do(es)?</code>可以匹配<code>does</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code>。<br>{n} |<code>n</code>是一个非负整数。匹配确定的<code>n</code>次。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code>。<br>{n,} |<code>n</code>是一个非负整数。至少匹配<code>n</code>次。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有o。<code>o&#123;1,&#125;</code>等价于<code>o+</code>。<code>o&#123;0,&#125;</code>则等价于<code>o*</code>。<br>{n,m} |<code>m</code>和<code>n</code>均为非负整数，其中<code>n&lt;=m</code>。最少匹配<code>n</code>次且最多匹配<code>m</code>次。例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个o。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。请注意在逗号和两个数之间不能有空格。<br>? |当该字符紧跟在任何一个其他限制符<code>(*,+,?,&#123;n&#125;,&#123;n,&#125;,&#123;n,m&#125;)</code>后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code>。<br>. |匹配除<code>\n</code>之外的任何单个字符。要匹配包括<code>\n</code>在内的任何字符，请使用像(.&#124;\n)的模式。<br>(pattern) |匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code>。<br>(?:pattern) |匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符(&#124;)来组合一个模式的各个部分是很有用。例如industr(?:y&#124;ies)就是一个比industry&#124;industries更简略的表达式。<br>(?&#x3D;pattern) |正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，Windows(?&#x3D;95&#124;98&#124;NT&#124;2000)能匹配<code>Windows2000</code>中的<code>Windows</code>，但不能匹配<code>Windows3.1</code>中的<code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern) |正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如<code>Windows(?!95&amp;#124;98&amp;#124;NT&amp;#124;2000)</code>能匹配<code>Windows3.1</code>中的<code>Windows</code>，但不能匹配<code>Windows2000</code>中的<code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始<br>(?&lt;&#x3D;pattern) |反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，(?&lt;&#x3D;95&#124;98&#124;NT&#124;2000)Windows能匹配<code>2000Windows</code>中的<code>Windows</code>，但不能匹配<code>3.1Windows</code>中的<code>Windows</code>。<br>(?&lt;!pattern) |反向否定预查，与正向否定预查类拟，只是方向相反。例如(?&lt;!95&#124;98&#124;NT&#124;2000)Windows能匹配<code>3.1Windows</code>中的<code>Windows</code>，但不能匹配<code>2000Windows</code>中的<code>Windows</code>。<br>x&#124;y |匹配x或y。例如，<code>z&amp;#124;food</code>能匹配<code>z</code>或<code>food</code>。<code>(z&amp;#124;f)ood</code>则匹配<code>zood</code>或<code>food</code>。</li>
</ul>
<p>[xyz] |字符集合。匹配所包含的任意一个字符。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。<br>[^xyz] |负值字符集合。匹配未包含的任意字符。例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>p</code>。<br>[a-z] |字符范围。匹配指定范围内的任意字符。例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符。<br>[^a-z] |负值字符范围。匹配任何不在指定范围内的任意字符。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符。<br>\b |匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>er\b</code>可以匹配<code>never</code>中的<code>er</code>，但不能匹配<code>verb</code>中的<code>er</code>。<br>\B |匹配非单词边界。<code>er\B</code>能匹配<code>verb</code>中的<code>er</code>，但不能匹配<code>never</code>中的<code>er</code>。<br>\cx |匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的<code>c</code>字符。<br>\d |匹配一个数字字符。等价于<code>[0-9]</code>。<br>\D |匹配一个非数字字符。等价于<code>[^0-9]</code>。<br>\f |匹配一个换页符。等价于<code>\x0c</code>和<code>\cL</code>。<br>\n |匹配一个换行符。等价于<code>\x0a</code>和<code>\cJ</code>。<br>\r |匹配一个回车符。等价于<code>\x0d</code>和<code>\cM</code>。<br>\s |匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。<br>\S |匹配任何非空白字符。等价于<code>[^ \f\n\r\t\v]</code>。<br>\t |匹配一个制表符。等价于<code>\x09</code>和<code>\cI</code>。<br>\v |匹配一个垂直制表符。等价于<code>\x0b</code>和<code>\cK</code>。<br>\w |匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code>。<br>\W |匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code>。<br>\xn |匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\x41</code>匹配<code>A</code>。<code>\x041</code>则等价于<code>\x04&amp;1</code>。正则表达式中可以使用ASCII编码。<br>\num |匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，<code>(.)\1</code>匹配两个连续的相同字符。<br>\n |标识一个八进制转义值或一个向后引用。如果<code>\n</code>之前至少<code>n</code>个获取的子表达式，则<code>n</code>为向后引用。否则，如果<code>n</code>为八进制数字<code>(0-7)</code>，则<code>n</code>为一个八进制转义值。<br>\nm |标识一个八进制转义值或一个向后引用。如果<code>\nm</code>之前至少有<code>nm</code>个获得子表达式，则<code>nm</code>为向后引用。如果<code>\nm</code>之前至少有<code>n</code>个获取，则<code>n</code>为一个后跟文字<code>m</code>的向后引用。如果前面的条件都不满足，若<code>n</code>和<code>m``均为八进制数字</code>(0-7)<code>，则</code>\nm<code>将匹配八进制转义值</code>nm<code>。 \nml |如果</code>n<code>为八进制数字</code>(0-3)<code>，且m和l均为八进制数字</code>(0-7)<code>，则匹配八进制转义值</code>nml<code>。 \un |匹配</code>n<code>，其中</code>n<code>是一个用四个十六进制数字表示的Unicode字符。例如，</code>\u00A9<code>匹配版权符号</code>(©)&#96;。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 连接数据库操作</title>
    <url>/2015/11/07/Python-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>来一个简单的例子，看Python如何操作数据库，相比Java的JDBC来说，确实非常简单，省去了很多复杂的重复工作，只关心数据的获取与操作。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要有相应的环境和模块：</p>
<blockquote>
<p>Ubuntu 14.04 64bit<br>Python 2.7.6<br>MySQLdb</p>
</blockquote>
<p>**注意:**Ubuntu 自带安装了Python，但是要使用Python连接数据库，还需要安装MySQLdb模块，安装方法也很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install MySQLdb</span><br></pre></td></tr></table></figure>
<p>然后进入Python环境，import这个包，如果没有报错，则安装成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~|⇒ python</span><br><span class="line">Python 2.7.6 (default, Jun 22 2015, 17:58:13) </span><br><span class="line">[GCC 4.8.2] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import MySQLdb</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>Python标准的数据库接口的<code>Python DB-API</code>（包括Python操作MySQL）。大多数Python数据库接口坚持这个标准。不同的数据库也就需要不同额模块，由于我本机装的是MySQL，所以使用了<code>MySQLdb</code>模块，对不同的数据库而言，只需要更改底层实现了接口的模块，代码不需要改，这就是模块的作用。</p>
<h3 id="Python数据库操作"><a href="#Python数据库操作" class="headerlink" title="Python数据库操作"></a>Python数据库操作</h3><p>首先我们需要一个测试表</p>
<h4 id="建表语句："><a href="#建表语句：" class="headerlink" title="建表语句："></a>建表语句：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE study;</span><br><span class="line">use study;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> python_demo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> python_demo (</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键，自增&#x27;</span>,</span><br><span class="line">  user_no <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  user_name <span class="type">VARBINARY</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  password <span class="type">VARBINARY</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  remark <span class="type">VARBINARY</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id,user_no)</span><br><span class="line">)ENGINE <span class="operator">=</span>innodb <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="string">&#x27;用户测试表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1001</span>,<span class="string">&#x27;张三01&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1002</span>,<span class="string">&#x27;张三02&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1003</span>,<span class="string">&#x27;张三03&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1004</span>,<span class="string">&#x27;张三04&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1005</span>,<span class="string">&#x27;张三05&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1006</span>,<span class="string">&#x27;张三06&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1007</span>,<span class="string">&#x27;张三07&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> python_demo(user_no, user_name, password, remark) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1008</span>,<span class="string">&#x27;张三08&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;我是张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --coding=utf8--</span></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host=conf.get(<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;host&#x27;</span>),</span><br><span class="line">                               user=conf.get(<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;user&#x27;</span>),</span><br><span class="line">                               passwd=conf.get(<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;passwd&#x27;</span>),</span><br><span class="line">                               db=conf.get(<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;db&#x27;</span>),</span><br><span class="line">                               charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> conn</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Error:数据库连接错误&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_demo</span>(<span class="params">conn, sql</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="keyword">return</span> cursor.fetchall()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Error:数据库连接错误&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_demo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_demo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_demo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conf = ConfigParser.ConfigParser()</span><br><span class="line">    conf.read(<span class="string">&#x27;mysql.conf&#x27;</span>)</span><br><span class="line">    conn = init_db()</span><br><span class="line">    sql = <span class="string">&quot;select * from %s&quot;</span> % conf.get(<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;table&#x27;</span>)</span><br><span class="line">    data = select_demo(conn, sql)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 默认参数陷阱</title>
    <url>/2015/10/10/Python-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>Python的函数定义提供了默认参数这个选择，使得函数的定义和使用更加的灵活，但是也会带来一些坑，例如之前的一个例子：<br>函数定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<p>调用函数的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>很明显这个与函数的定义初衷不符，用一句话解释就是：</p>
<blockquote>
<p>Default values are computed once, then re-used.</p>
</blockquote>
<p>为了深入研究这个问题，我们来看看另一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;a executed&quot;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">x=a(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(x):&quot;</span>, <span class="built_in">id</span>(x)</span><br><span class="line">    x.append(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;x:&quot;</span>, x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;不带参数调用，使用默认参数&quot;</span></span><br><span class="line">    b()</span><br><span class="line">    <span class="built_in">print</span> b.__defaults__</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(b.__defaults__[0]):&quot;</span>, <span class="built_in">id</span>(b.__defaults__[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;带参数调用，传入一个list&quot;</span></span><br><span class="line">    b(<span class="built_in">list</span>())</span><br><span class="line">    <span class="built_in">print</span> b.__defaults__</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(b.__defaults__[0]):&quot;</span>, <span class="built_in">id</span>(b.__defaults__[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>**NOTE:**稍微解释一下，所有默认值都存储在函数对象的<code>__defaults__</code>属性中，这是一个列表，每一个元素均为一个默认参数值。<br>来看看输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a executed</span><br><span class="line">不带参数调用，使用默认参数</span><br><span class="line"><span class="built_in">id</span>(x): 140038854650552</span><br><span class="line">x: [5]</span><br><span class="line">([5],)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 140038854650552</span><br><span class="line">不带参数调用，使用默认参数</span><br><span class="line"><span class="built_in">id</span>(x): 140038854650552</span><br><span class="line">x: [5, 5]</span><br><span class="line">([5, 5],)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 140038854650552</span><br><span class="line">带参数调用，传入一个list</span><br><span class="line"><span class="built_in">id</span>(x): 140038854732400</span><br><span class="line">x: [5]</span><br><span class="line">([5, 5],)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 140038854650552</span><br><span class="line">带参数调用，传入一个list</span><br><span class="line"><span class="built_in">id</span>(x): 140038854732472</span><br><span class="line">x: [5]</span><br><span class="line">([5, 5],)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 140038854650552</span><br></pre></td></tr></table></figure>
<p>简单分析一下输出结果：</p>
<ul>
<li><p>第1行<br>在定义函数<code>b()</code>，即执行<code>def</code>语句，代码第7行<code>def b(x=a()):</code>的时候，这句话使用了默认参数，所以在定义的时候会计算默认参数<code>x</code>的值，这个时候会调用<code>a()</code>，所以打印出了<code>a executed</code>。</p>
</li>
<li><p>第2~6行<br>第一次执行循环，代码第14行调用<code>b()</code>没有传递参数，使用默认参数，此时<code>x=[]</code>，所以调用一次之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> b.__defaults__</span><br></pre></td></tr></table></figure>
<p> 输出结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">([5],)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第7~11行<br>第二次循环，代码第14行调用<code>b()</code>没有传递参数，使用默认参数。<br><strong>注意：</strong><code>默认参数只会计算一次，也就是说那个内存区域就固定了，但是这个地址所指向的是一个list，内容可以改变</code>，此时由于上一次调用<code>x: [5]</code>，所以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> b.__defaults__</span><br></pre></td></tr></table></figure>
<p> 输出结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">([5, 5],)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第12~16行<br>第二个循环语句，第一次循环，代码第20行传入一个空的<code>list</code>,所以不使用默认参数，此时<code>x=[]</code>，所以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> b.__defaults__</span><br></pre></td></tr></table></figure>
<p> 输出结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">([5],)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第18~21行<br>第二个循环语句，第二次循环，代码第20行传入一个空的<code>list</code>,所以也不使用默认参数，此时仍然是<code>x=[]</code>，所以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> b.__defaults__</span><br></pre></td></tr></table></figure>
<p> 输出结果依然为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">([5],)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数也是对象，因此定义的时候就被执行，默认参数是函数的属性，它的值可能会随着函数被调用而改变。其他对象不都是如此吗？<br><strong>牢记:</strong> 默认参数必须指向不变对象！代码改一下如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;a executed&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">x=a(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(x):&quot;</span>, <span class="built_in">id</span>(x)</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        x = []</span><br><span class="line">    x.append(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;x:&quot;</span>, x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;不带参数调用，使用默认参数&quot;</span></span><br><span class="line">    b()</span><br><span class="line">    <span class="built_in">print</span> b.__defaults__</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(b.__defaults__[0]):&quot;</span>, <span class="built_in">id</span>(b.__defaults__[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;带参数调用，传入一个list&quot;</span></span><br><span class="line">    b(<span class="built_in">list</span>())</span><br><span class="line">    <span class="built_in">print</span> b.__defaults__</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(b.__defaults__[0]):&quot;</span>, <span class="built_in">id</span>(b.__defaults__[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p> 此时的输出结果看看是什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a executed</span><br><span class="line">不带参数调用，使用默认参数</span><br><span class="line"><span class="built_in">id</span>(x): 9568656</span><br><span class="line">x: [5]</span><br><span class="line">(None,)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 9568656</span><br><span class="line">不带参数调用，使用默认参数</span><br><span class="line"><span class="built_in">id</span>(x): 9568656</span><br><span class="line">x: [5]</span><br><span class="line">(None,)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 9568656</span><br><span class="line">带参数调用，传入一个list</span><br><span class="line"><span class="built_in">id</span>(x): 140725126699632</span><br><span class="line">x: [5]</span><br><span class="line">(None,)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 9568656</span><br><span class="line">带参数调用，传入一个list</span><br><span class="line"><span class="built_in">id</span>(x): 140725126699704</span><br><span class="line">x: [5]</span><br><span class="line">(None,)</span><br><span class="line"><span class="built_in">id</span>(b.__defaults__[0]): 9568656</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2.x os.path.join /报错</title>
    <url>/2016/01/20/Python2.x-os-join-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>我们在实际编程中经常会用到加载路径中的一些指定的文件,这就涉及到路径的拼接,<code>Unix/Linux</code>中的路径是<code>/</code>分隔,但是<code>Windows</code>中路径分隔是<code>\\</code>.所以自己拼接路径容易出错,python直接提供了路径拼接函数帮我们完成这些麻烦的事情.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.join(path1,path2,path3....)</span><br></pre></td></tr></table></figure>
<p>它会根据系统的不同,自动选择使用<code>/</code>或者<code>\\</code>来连接两个字符串路径.</p>
<p>但是在服务器上使用这个函数来拼接字符串的时候,如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.join(<span class="string">&#x27;/home/bin&#x27;</span>, /python<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>输出结果是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/python&#x27;</span></span><br></pre></td></tr></table></figure>
<p>正常情况下应该输出<code>/home/bin/python</code>,但是好像这个没起作用.<br>**注意:**这个里面两个路径都是<code>/</code>开头,经测试,这个函数在python2.6.6和python2.7.10+上测试都是一样的,官方给出的解释是:</p>
<blockquote>
<p>如果路径前面带有&#x2F;,那么python会认为这是一个绝对路径,所以就不需要再拼接路径了</p>
</blockquote>
<p>**切记:**在使用这个函数拼接绝对路径的时候,最前面那个路径可以带<code>/</code>开头,但是后面的路径开头必须是不带<code>/</code>的一个字符串.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出及字符串</title>
    <url>/2015/10/09/Python%E5%85%A5%E9%97%A8:%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">os: Ubuntu 14.04 (Linux 3.13.0-32-generic linux x64)</span><br><span class="line">python: Python 2.7.6 (default, Mar 22 2014, 22:59:56)</span><br><span class="line">IDE: pyCharm 4.5.4</span><br></pre></td></tr></table></figure>

<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>安装python<br><code>Windows</code>用户需要手动安装<code>python</code>环境，<code>Ubuntu</code>自带<code>python</code>，所以这步跳过，不用安装，如果需要安装指定版本，则需要去官网下载手动安装，考虑到很多<code>python</code>的库都是基于<code>python 2.7.x</code>编写的，所以没啥大问题我就默认使用<code>python 2.7.6</code>了。</p>
</li>
<li><p>安装IDE<br>这个看个人喜好，我安装的是<code>PyCharm 4.5.4</code>，首先需要去官网下载，根据你的系统下载不同的包，下载页面是<a href="http://www.jetbrains.com/pycharm/download/">Download PyCharm</a>。网速不是很好，我是开代理下载的，如果下载太慢，可以去我的百度网盘下载<a href="">PyCharm 4.5.4 百度云</a></p>
</li>
<li><p>解压到指定目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf pycharm-professional-4.5.4.tar.gz -C /usr/devlop</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>pycharm</code><br>可以在<code>/usr/devlop/pycharm-4.5.4/bin</code>下找到一个脚本<code>pycharm.sh</code>。运行脚本即可,具体方法是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/devlop/pycharm-4.5.4/bin</span><br><span class="line">./pycharm.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="python基本知识"><a href="#python基本知识" class="headerlink" title="python基本知识"></a>python基本知识</h4><ul>
<li><p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">hello, world</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;The quick brown fox&#x27;</span>, <span class="string">&#x27;jumps over&#x27;</span>, <span class="string">&#x27;the lazy dog&#x27;</span></span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;100 + 200 =&#x27;</span>, 100 + 200</span><br><span class="line">100 + 200 = 300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name = raw_input()</span><br><span class="line">Michael</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> name</span><br><span class="line">Michael</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; name = raw_input(<span class="string">&#x27;please enter your name: &#x27;</span>)</span><br><span class="line">please enter your name:</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> <code>raw_input</code>返回的永远是字符串，也就是说你输入一个<code>int</code>型，返回的是一个数字字符串，你需要进行转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; number = raw_input(<span class="string">&quot;输入一个整数：&quot;</span>)</span><br><span class="line">输入一个整数：123</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line">&gt;&gt;&gt; number = int(raw_input(<span class="string">&quot;输入一个整数：&quot;</span>))</span><br><span class="line">输入一个整数：123</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串<br>字符串用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>括起来，如果字符串内部有<code>‘</code>或者<code>&quot;</code>，需要使用<code>\</code>进行转义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;I\&#x27;</span>m ok.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">I&#x27;</span>m ok.</span><br></pre></td></tr></table></figure>
<p> 转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。当然如果不需要转义，可以使用<code>r&#39;&#39;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;\\\t\\&#x27;</span></span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> r<span class="string">&#x27;\\\t\\&#x27;</span></span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure>
<p> 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span><span class="string">&#x27;line1</span></span><br><span class="line"><span class="string">... line2</span></span><br><span class="line"><span class="string">... line3&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>
<p> 如果写成程序，就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空值<br><code>python</code>里空值用<code>None</code>表示，相当于<code>Java/C++</code>里的<code>null</code>。</p>
</li>
<li><p>变量<br><code>python</code>是动态语言，里面的变量不像<code>Java/C++</code>里，脚本语言都比较宽松，所以代码在声明变量的时候都不需要显示的声明类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span> <span class="comment"># a是整数</span></span><br><span class="line"><span class="built_in">print</span> a</span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span> <span class="comment"># a变为字符串</span></span><br><span class="line"><span class="built_in">print</span> a</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量<br>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PI = <span class="number">3.14159265359</span></span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong><code>python</code>中即使这样定义了，也无法阻止你修改常量，可以随便改的，所以这只是个约定，但是最好不要改动。这里有个地方需要注意一下，<code>PI</code>是变量，但是其内容对象是不可变对象，看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&gt;&gt;&gt; b = a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line"><span class="string">&#x27;Abc&#x27;</span></span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
</li>
</ul>
<ul>
<li><p>单行注释<br> <code>#</code> 后面的内容为注释内容</p>
</li>
<li><p>特殊注释</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/python</span></span><br></pre></td></tr></table></figure>
<p> 告诉<code>Linux/Unix</code>去找到<code>python</code>的翻译器，这样有个好处，脚本可以直接运行，而不用<code>python hello.py</code>这样。</p>
</li>
<li><p>编码注释</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong>这个只能放在第二行，多一个空格都不行。</p>
</li>
<li><p>doc String注释<br>这个东西主要是用于模块、函数和类的描述，类似于下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testDocString</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试文档注释</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> testDocString.__doc__</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在终端中运行一下脚本，看看最后输出内容</span></span><br><span class="line">➜  python  ./Comments.py      </span><br><span class="line">     测试文档注释</span><br><span class="line">    :<span class="keyword">return</span>:</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><ul>
<li>中文编码问题</li>
</ul>
<blockquote>
<p># coding &#x3D; utf-8</p>
</blockquote>
<p> 结果报错：</p>
<blockquote>
<p>SyntaxError: Non-ASCII character ‘&#x2F;xe6’</p>
</blockquote>
<p> 所以最后改成了</p>
<blockquote>
<p># coding&#x3D;utf-8</p>
</blockquote>
<ul>
<li>Unicode编码问题<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  python</span><br><span class="line">Python 2.7.6 (default, Mar 22 2014, 22:59:56) </span><br><span class="line">[GCC 4.8.2] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(u<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
 <strong>注意：</strong> 这个问题是由<code>python</code>编码导致的，详细的编码问题详见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000">字符串和编码</a>，但是在<code>python 3.x</code>中这个编码问题就不存在了：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  python3 </span><br><span class="line">Python 3.4.0 (default, Jun 19 2015, 14:20:21) </span><br><span class="line">[GCC 4.8.2] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len(u<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>最常见的还不是编码带来的长度问题不一致，编码主要会导致一些系统异常，常见的有两种:</p>
<ul>
<li>encode(编码)异常</li>
</ul>
<p>常见的就是<code>UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode character u&#39;xxxx&#39; in position xx: ordinal not in range(128)</code>,<br>意思就是把一个字符串编码为str的时候，系统默认是编码成<code>ascii</code>编码格式，但是中文里面的编码超出了<code>ascii</code>编码的最大范围，直接<br>报错，常见的就是直接掉<code>str()</code>函数的时候没有指定编码。建议少用<code>str()</code>函数，采用<code>xxx.encode(&#39;utf8&#39;)</code>这种显示的声明</p>
<ul>
<li>decode(解码)异常</li>
</ul>
<p>道理是一样的，默认也是用<code>ascii</code>解码，如果是中文的话，需要手动指定<code>uft-8</code>解码方式.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 免密码登陆</title>
    <url>/2016/04/24/SSH-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<p>开发工作中，经常需要使用ssh来登录服务器，密码一般都是机器生成的，特别难记，关键是机器多了这样也麻烦，所以配置一下ssh面密码登录，节省时间。</p>
<h3 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h3><p>本地机器：Ubuntu<br>服务器：CentOS</p>
<h3 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h3><p>需要服务器和本机都做一定的配置才能免密码登陆</p>
<h4 id="本地机器配置"><a href="#本地机器配置" class="headerlink" title="本地机器配置"></a>本地机器配置</h4><ol>
<li>通过<code>ssh-keygen</code>产生RSA公私密钥对</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen`</span><br></pre></td></tr></table></figure>
<p>然后一路回车，不要输入任何密码和字符，最后在<code>~/.ssh/</code>文件夹中会生成两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，然后需要修改问年间权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod 775 ~/.ssh</span><br></pre></td></tr></table></figure>
<p>将<code>id_rsa.pub</code>上传到服务器的<code>~/.ssh/</code>文件夹下，其实也不用上传，直接把这个文件的内容复制然后在服务器的对应文件夹下创建文件，然后写入也是一样的。<br>2. 在<code>~/.ssh/</code>文件夹里创建配置文件<code>config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host my_server // 服务器别名</span><br><span class="line">    HostName 192.168.1.120  // 服务器ip</span><br><span class="line">    User root   //登录用户名</span><br><span class="line">    Port 22     // ssh端口</span><br></pre></td></tr></table></figure>

<h4 id="服务器机器配置"><a href="#服务器机器配置" class="headerlink" title="服务器机器配置"></a>服务器机器配置</h4><ol>
<li>修改<code>/etc/ssh/sshd_config</code>文件,将下面几行前面的注释去掉<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
如果已经注释掉了就不用配置则这里了，</li>
<li>在用户目录下创建<code>.ssh</code>文件夹，如果有就不用创建了，具体路径为<code>~/.ssh/</code><br>然后在<code>~/.ssh/</code>文件夹下面创建<code>authorized_keys</code>文件,并将之前上传到服务器上的<code>id_rsa.pub</code>文件里的内容拷贝到<code>authorized_keys</code>中,保存之后重启ssh服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh/</span><br><span class="line">$ sudo cat id_rsa.pub &gt; authorized_keys</span><br><span class="line">$ sudo chmod 644 authorized_keys</span><br><span class="line">$ sudo service sshd restart</span><br></pre></td></tr></table></figure>

<h4 id="本机测试"><a href="#本机测试" class="headerlink" title="本机测试"></a>本机测试</h4><p>通过终端连接服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh my_server</span><br></pre></td></tr></table></figure>
<p>**注意:**如果这一步出现<code>bad owers</code>等错误，记得要修改本机的文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod 700 ~/.ssh</span><br><span class="line">$ chmod go+rwx ~/.ssh/*</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ShadowSocks+Haproxy中继</title>
    <url>/2018/05/22/ShadowSocks-Haproxy%E4%B8%AD%E7%BB%A7/</url>
    <content><![CDATA[<p>最近发现家里的网连我国外的服务器非常的慢,丢包已经基本上到了访问不了的地步了,所以搭的ss代理基本上只能在公司用.之前花几百快撸的腾讯云服务器放了好几个月都没管过了,正好拿来做中继代理.之前买了半年的阿里云服务器搞过，后来过期了没有续费了,这次撸了6年的应该够用了.</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>其实就是运营商的国际出口比较堵,所以直接访问国外的服务器丢包严重，当然实测应该还有一个原因，应该是运营商主动干扰这些代理服务器.个人感觉后面的可能性要大一些,不过不管是哪种都不重要了,要实现低延迟链路，只能借助大厂的线路(阿里，腾讯),基本原理也很简单:</p>
<ul>
<li>直连方案:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local(A) --&gt; sserver(C)</span><br></pre></td></tr></table></figure></li>
<li>中继方案:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local(A) --&gt; aliyun/cloud tencent(B) --&gt; sserver(C)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>主要是在中继机器B上操作,sserver(C)不用做任何变更,首先登录我们的中继机器(B):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install haproxy -y</span><br></pre></td></tr></table></figure>
<p>然后就是配置我们的机器了,编辑<code>sudo vim /etc/haproxy/haproxy.cfg</code>,直接改成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    ulimit-n  51200</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log     global</span><br><span class="line">    mode    tcp</span><br><span class="line">    option  dontlognull</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    timeout client  50000</span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line">frontend ss-in</span><br><span class="line">    bind *: &#123;B_local_listen_port&#125;</span><br><span class="line">    default_backend ss-out</span><br><span class="line"></span><br><span class="line">backend ss-out</span><br><span class="line">    server sserver_name &#123;sserver_ip&#125;:&#123;sserver_port&#125; maxconn 20480</span><br></pre></td></tr></table></figure>
<p>这里需要设置的几个地方为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;B_local_listen_port&#125;:这个就是中继服务器监听外部请求的端口,为了你local改动小,这个端口可以设置和sserver(C)的端口一致</span><br><span class="line">&#123;sserver_ip&#125;:这个就很好理解了,就是你部署sserver的机器的ip,后面那个端口也是ss服务器的端口</span><br></pre></td></tr></table></figure>
<p>等这些都改完了，然后还需要做一件事,就是给你的中继服务器开安全组策略，阿里和腾讯的云主机基本上是一样的，开入站和出战规则即可,然后把设置好的安全组规则绑定到你的机器实例上.简单来说就是需要对<code>&#123;B_local_listen_port&#125;</code>开入站规则,对<code>&#123;sserver_port&#125;</code>开出战规则，如果你分不清觉得麻烦，就把这两个端口设置的一样,然后开一个端口的出站和入站规则即可.</p>
<h1 id="服务启用"><a href="#服务启用" class="headerlink" title="服务启用"></a>服务启用</h1><p>由于你改了安全组规则，所以需要重启你的服务器实例,重启好了之后,需要启动haproxy服务,不同的机器不一样，以我的腾讯云主机为例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start haproxy.service</span><br><span class="line"># 设置成开机启动(CentOS7)</span><br><span class="line">systemctl enable haproxy.service</span><br><span class="line"># 设置成开机启动(CentOS6,没测试过，网上查的)</span><br><span class="line">chkconfig –level 3 haproxy.service on</span><br></pre></td></tr></table></figure>
<p>启动服务之后可以检测一下服务是否开启了,直接用<code>ps</code>命令即可.</p>
<p>然后就是本地<code>local</code>机器,即<code>sslocal</code>的配置,因为我们上面配置的中继监听端口和<code>sserver</code>的端口一致,所以我们的<code>sslocal</code>只用改一个ip，端口不用改,ip由原来的<code>sserver ip</code>改为中继服务器的ip就行了.延迟由原来的300ms直接降为40ms,收工.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>高级特性:切片,迭代,生成式</title>
    <url>/2015/10/12/Python-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7:%E5%88%87%E7%89%87,%E8%BF%AD%E4%BB%A3,%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    <content><![CDATA[<p>Python崇尚的是代码越少越好，借鉴了其他各类语言的特性，另外考虑到日常编程中的一些非常繁琐的操作，Python对有一些非常常用的操作提供了简单的实现。</p>
<h3 id="Python高级特性"><a href="#Python高级特性" class="headerlink" title="Python高级特性"></a>Python高级特性</h3><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>取一个<code>list</code>或<code>tuple</code>中的部分元素，当然其他语言，例如<code>java</code>也可以使用截取函数，传入区间进行截取，但是Python提供了一个更简单的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>注意，3表示的不是截取的元素个数，而是索引结束位置，即不包括索引为3的元素，如果开始索引为0，还可以省略</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[1:3]</span><br><span class="line">[<span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>前面也提到过，Python取元素还支持<code>L[-1]</code>这种取倒数第一个元素的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; L[-2:-1]</span><br><span class="line">[<span class="string">&#x27;Bob&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><code>L[:]</code>，这个表示复制一个<code>list</code>，其实就是默认把整个<code>list</code>切片。</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>这个和Java也差不多，在Java中也有迭代器以及<code>foreach(element: elements)</code>这种循环语句,在Python中，使用<code>for ... in</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>:</span><br><span class="line">...     <span class="built_in">print</span> ch</span><br><span class="line">... </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>dict</code>通过<code>key</code>迭代。也可以通过<code>value</code>来迭代：<code>for value in d.itervalues()</code>。也可以同时迭代<code>key</code>和<code>value</code>：<code>for k, v in d.iteritems()</code>。<br>所以，只要判断一个对象是可迭代对象就可以使用<code>for ... in</code>这种循环，通过<code>collections</code>模块的<code>Iterable</code>类型判断：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>有时候也需要里列表里的下标，这点Python也提供了一个内置的<code>enumerate</code>函数，可以把一个<code>list</code>变成<code>索引-元素对</code>，这样就可以做到在<code>for</code>循环中迭代索引和元素本身。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line">...     <span class="built_in">print</span> i, value</span><br><span class="line">... </span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure>
<p>还可以同时引用两个变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> x, y <span class="keyword">in</span> [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     <span class="built_in">print</span> x, y</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure>

<h4 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h4><p>即创建列表的方式，最笨的方法就是写循环逐个生成，前面也介绍过可以使用<code>range()</code>函数来生成，不过只能生成线性列表，下面看看更为高级的生成方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把<code>list</code>创建出来，十分有用，多写几次，很快就可以熟悉这种语法。<br>你甚至可以在后面加上<code>if</code>判断：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11) <span class="keyword">if</span> x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>
<p>循环嵌套，全排列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>看一个简单应用，列出当前目录下所有文件和目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)]</span><br><span class="line">[<span class="string">&#x27;README.md&#x27;</span>, <span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;lib&#x27;</span>, <span class="string">&#x27;sublime-imfix&#x27;</span>, <span class="string">&#x27;src&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>前面也说过Python里循环中可以同时引用两个变量，所以生成变量也可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">&gt;&gt;&gt; [k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems()]</span><br><span class="line">[<span class="string">&#x27;y=B&#x27;</span>, <span class="string">&#x27;x=A&#x27;</span>, <span class="string">&#x27;z=C&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>也可以通过一个<code>list</code>生成另一个<code>list</code>，例如把一个list中所有字符串变为小写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;ibm&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题，<code>list</code>中如果有其他非字符串类型，那么<code>lower()</code>会报错，解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, 12, 34]</span><br><span class="line">&gt;&gt;&gt; [s.lower() <span class="keyword">if</span> isinstance(s,str) <span class="keyword">else</span> s <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;ibm&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, 12, 34]</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>列表生成式虽然强大，但是也会有一个问题，当我们想生成一个很大的列表时，会非常耗时，并且占用很大的存储空间，关键是这里面的元素可能你只需要用到前面很少的一部分，大部分的空间和时间都浪费了。Python提供了一种边计算边使用的机制，称为生成器(Generator)，创建一个Generator最简单的方法就是把<code>[]</code>改为<code>()</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7fe73eb85cd0&gt;</span><br></pre></td></tr></table></figure>

<p>如果要一个一个打印出来，可以通过generator的next()方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>其实<code>generator object</code>也是可迭代的，所以可以用循环打印，还不会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(10))</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">...     <span class="built_in">print</span> n</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure>
<p>这是简单的推算算法，但是如果算法比较复杂，写在<code>()</code>里就不太合适了，我们可以换一种方式，使用函数来实现。<br>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<blockquote>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
</blockquote>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面的函数可以输出斐波那契数列的前N个数,这个也是通过前面的数推算出后面的，所以可以把函数变成<code>generator object</code>，只需要把<code>print b</code>改为<code>yield b</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数定义中包含了<code>yield</code>关键字，这个函数就不在是普通函数，而是一个<code>generator object</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fib(6)</span><br><span class="line">&lt;generator object fib at 0x7fa1c3fcdaf0&gt;</span><br><span class="line">&gt;&gt;&gt; fib(6).next()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>所以要想调用这个函数，需要使用<code>next()</code>函数，并且遇到<code>yield</code>语句返回(可以把yield理解为return):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 3&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>看看调用输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; o = odd()</span><br><span class="line">&gt;&gt;&gt; o.next()</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; o.next()</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; o.next()</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; o.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>同样也可以改为<code>for</code>循环语句输出。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 3&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    o = odd()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span> o.<span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 反引号，单引号，双引号</title>
    <url>/2015/11/06/Shell-%E5%8F%8D%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<p>最近碰到个坑,在写shell脚本查询Hive数据的时候,有一个脚本在Shell里怎么都执行不出结果,但是拷贝到Hive界面里却能正常执行出结果,因为Hive表是按日期分区的,有两种格式:<br>一种是<code>%Y%m%d</code>,另一种是<code>%Y-%m-%d</code>.dw_source的表是第一种格式,而dw_transform层的表是第二种格式:</p>
<h3 id="错误样例"><a href="#错误样例" class="headerlink" title="错误样例"></a>错误样例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql用单引号 执行成功,可以返回正常结果</span></span><br><span class="line">sql1=<span class="string">&#x27;select uid,first_ip,first_date from dw_source.user_ext where dt=&#x27;</span>20151104<span class="string">&#x27;;&#x27;</span></span><br><span class="line">sudo -uhive_user hive -e <span class="string">&quot;<span class="variable">$sql1</span>&quot;</span> &gt; source.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql用单引号 执行成功,但是没有返回值</span></span><br><span class="line">sql2=<span class="string">&#x27;select uid,first_ip,first_date from dw_transform.user_ext where dt=&#x27;</span>2015-11-04<span class="string">&#x27;;&#x27;</span></span><br><span class="line">sudo -uhive_user hive -e <span class="string">&quot;<span class="variable">$sql2</span>&quot;</span> &gt; transform.txt</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>echo</code>命令来看看具体执行的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sql1=<span class="string">&#x27;select uid,first_ip,first_date from dw_source.user_ext where dt=&#x27;</span>20151104<span class="string">&#x27;;&#x27;</span></span><br><span class="line">sql2=<span class="string">&#x27;select uid,first_ip,first_date from dw_transform.user_ext where dt=&#x27;</span>2015-11-04<span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> sudo -uhive_user hive -e <span class="string">&quot;<span class="variable">$sql1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> sudo -uhive_user hive -e <span class="string">&quot;<span class="variable">$sql2</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>看看返回结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -uhive_user hive -e <span class="keyword">select</span> uid,first_ip,first_date from dw_source.user_ext <span class="built_in">where</span> dt=20151104;</span><br><span class="line">sudo -uhive_user hive -e <span class="keyword">select</span> uid,first_ip,first_date from dw_transform.user_ext <span class="built_in">where</span> dt=2015-11-04;</span><br></pre></td></tr></table></figure>
<p>看到这里发现了一个问题,本来在日期上应该有的单引号消失了,因为第一种时间格式没有分隔符,可以被正常的识别,但是第二种就比较悲催了,应该是被<code>-</code>分隔了,导致日期不对,解决办法就是最外面用双引号,即改成如下内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sql1=<span class="string">&quot;select uid,first_ip,first_date from dw_source.user_ext where dt=&#x27;20151104&#x27;;&quot;</span></span><br><span class="line">sql2=<span class="string">&quot;select uid,first_ip,first_date from dw_transform.user_ext where dt=&#x27;2015-11-04&#x27;;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="反引号-双引号-单引号用法"><a href="#反引号-双引号-单引号用法" class="headerlink" title="反引号 双引号 单引号用法"></a>反引号 双引号 单引号用法</h3><p>这几个符号长得比较像，但是功能还是有很大区别的。</p>
<h4 id="反引号"><a href="#反引号" class="headerlink" title="反引号(&#96;)"></a>反引号(&#96;)</h4><p>起着命令替换的作用。命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。,举个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="built_in">echo</span> The <span class="built_in">date</span> is `<span class="built_in">date</span>`</span><br><span class="line">The <span class="built_in">date</span> is 2015年 11月 06日 星期五 16:27:46 CST</span><br></pre></td></tr></table></figure>

<h4 id="双引号-“"><a href="#双引号-“" class="headerlink" title="双引号(“)"></a>双引号(“)</h4><p>双引号是字符串的界定符,而不是字符的界定符,取消除[`,$,”,]以外,其他的都变成字符串的内容了.双引号是弱引用，引号里的值若再包含变量，那在赋值的时候，所有这些变量就被立即替换了。<br>用双引号的时候:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$加变量名可以取变量的值</span><br><span class="line">反引号仍表示命令替换</span><br><span class="line">\$表示$的字面值</span><br><span class="line">\`表示`的字面值</span><br><span class="line">\&quot;表示&quot;的字面值</span><br><span class="line">\\表示\的字面值</span><br></pre></td></tr></table></figure>
<p>看个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  name=World</span><br><span class="line">➜  ~  <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">World</span><br><span class="line">➜  ~  sayHello=<span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span></span><br><span class="line">➜  ~  <span class="built_in">echo</span> <span class="variable">$sayHello</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h4 id="单引号-‘"><a href="#单引号-‘" class="headerlink" title="单引号(‘)"></a>单引号(‘)</h4><p>单引号告诉shell忽略所有特殊字符,保持引号内所有字符的字面值，即使引号内的\和回车也不例外,单引号是强引用,但是字符串中不能出现单引号。之前的问题就是犯了这个错,两个单引号嵌套了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="built_in">echo</span> <span class="string">&quot;`date`&quot;</span></span><br><span class="line">2015年 11月 06日 星期五 16:42:29 CST</span><br><span class="line">➜  ~  <span class="built_in">echo</span> <span class="string">&#x27;`date`&#x27;</span></span><br><span class="line">`<span class="built_in">date</span>`</span><br><span class="line">➜  ~  <span class="built_in">echo</span> <span class="string">&quot;&#x27;`date`&#x27;&quot;</span></span><br><span class="line"><span class="string">&#x27;2015年 11月 06日 星期五 16:42:29 CST&#x27;</span></span><br><span class="line">➜  ~  </span><br></pre></td></tr></table></figure>
<p>**注意:**如果<code>&#39;</code>出现在<code>&quot;</code>里面，<code>&#39;</code>就退化为一个单纯的字符了，而不再有强引用一说。换句话说，只有最外层的<code>&#39;</code>才具有强引用效果。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>这个对我们有啥影响呢？基本在我们使用Shell的时候都会碰到这个坑，尤其是正则表达式，有时候匹配数字用<code>\d</code>就可以了，但是像Hive这种用Java写的，内部会有转义，所以需要传入两个<code>\\</code>的时候，就容易踩坑，以Hive中的正则为例,看下面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg_str1=&#x27;.*id=(\\d).*&#x27;</span><br><span class="line">reg_str2=&quot;.*id=(\\\\d).*&quot;</span><br></pre></td></tr></table></figure>
<p>这两种写法都是正确的写法，效果是一样的，其他的写法都是不对的</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 按日期循环执行</title>
    <url>/2015/11/03/Shell-%E6%8C%89%E6%97%A5%E6%9C%9F%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>服务器上有些脚本,执行的参数用到了日期,也就是每天执行一次,日期取当天时间作为参数,当有些时候需要把这些脚本过去一段时间的运行结果重新运行一次时,手动指定脚本日期没有办法大批量执行,需要在shell中写循环,让脚本批量执行.</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>以一个小的例子来说:把指定日期时间段内的日期都输出来,看看下面的代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">start_date=20151101</span><br><span class="line">end_date=20151103</span><br><span class="line">start_sec=`<span class="built_in">date</span> -d <span class="string">&quot;<span class="variable">$start_date</span>&quot;</span> <span class="string">&quot;+%s&quot;</span>`</span><br><span class="line">end_sec=`<span class="built_in">date</span> -d <span class="string">&quot;<span class="variable">$end_date</span>&quot;</span> <span class="string">&quot;+%s&quot;</span>`</span><br><span class="line"><span class="keyword">for</span>((i=start_sec;i&lt;=end_sec;i+=<span class="number">86400</span>)); <span class="keyword">do</span></span><br><span class="line">    day=$(<span class="built_in">date</span> -d <span class="string">&quot;@<span class="variable">$i</span>&quot;</span> <span class="string">&quot;+%Y-%m-%d&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$day</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>看看输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2015-11-01</span><br><span class="line">2015-11-02</span><br><span class="line">2015-11-03</span><br></pre></td></tr></table></figure>
<p>执行结果是循环输出日期,把需要循环的脚本放在循环里调用,把<code>$day</code>当参数使用即可.如果脚本里面的变量是日期,那就把脚本代码拷贝到循环中间.日期的格式可以按需求自己调整.例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=start_sec;i&lt;=end_sec;i+=<span class="number">86400</span>)); <span class="keyword">do</span></span><br><span class="line">    day=$(<span class="built_in">date</span> -d <span class="string">&quot;@<span class="variable">$i</span>&quot;</span> <span class="string">&quot;+%Y-%m-%d&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$day</span></span><br><span class="line">    sudo /usr/python/ /usr/dev/job.py <span class="variable">$day</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这样就可以把时间参数批量传入脚本.</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>但是上面的还是很麻烦，你要记住一天有多少秒，这样也不太容易记住，下面还有另一种方法,注意到时间格式为<code>20151101</code>,这种其实也是一个数字，我们可以让日期按天增加，然后比较日期大小关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">start=20160101</span><br><span class="line">end=20160103</span><br><span class="line"></span><br><span class="line">while [ $&#123;start&#125; -le $&#123;end&#125; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;start&#125;</span><br><span class="line">  start=`date -d &quot;1 day $&#123;start&#125;&quot; +%Y%m%d`	# 日期自增</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>**备注:**Shell里面的数字大小比较:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-ne	# 不相等</span><br><span class="line">-gt	# 大于</span><br><span class="line">-lt	# 小于</span><br><span class="line">-ge	# 大于或等于</span><br><span class="line">-le	# 小于或等于</span><br></pre></td></tr></table></figure>

<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>虽然上面的方法二比方法一要好很多，但是好像有个问题，一般日期都是以字符串的形式传入，多半是<code>2016-01-01</code>这种带间隔的方式，这种情况我们是没办法比较的，当然把上面的改一改也能用,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line"># 先把日期处理成纯数字的格式</span><br><span class="line">start=`date -d &quot;2016-01-01&quot; +%Y%m%d`</span><br><span class="line">end=`date -d &quot;2016-03-01&quot; +%Y%m%d`</span><br><span class="line"></span><br><span class="line">while [ $&#123;start&#125; -le $&#123;end&#125; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;start&#125;</span><br><span class="line">  # 假设下面有一个脚本需要2016-01-01格式的日期</span><br><span class="line">  bash xxx.sh `date -d &quot;$&#123;start&#125;&quot; +%Y-%m-%d`</span><br><span class="line">  start=`date -d &quot;1 day $&#123;start&#125;&quot; +%Y%m%d`	# 日期自增</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这样感觉好麻烦，为啥循环就只能是数字呢?有没有一种比较通用的循环方式,这个当然有，你可以像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">start=&#x27;2016-01-01&#x27;</span><br><span class="line">end=&#x27;2016-01-03&#x27;</span><br><span class="line"></span><br><span class="line">while [ &quot;$&#123;start&#125;&quot; != &quot;$&#123;end&#125;&quot; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;start&#125;</span><br><span class="line">  start=`date -d &quot;1 day $&#123;start&#125;&quot; +%Y-%m-%d`	# 日期自增</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就可以循环了，但是记住，<code>start</code>取不到<code>end</code>值，即最后输出的是<code>[start,end)</code>，好像Shell里面并没有<code>do...while</code>这种循环，所以最好在循环之前，先做一步处理:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end=`date -d &quot;1 day $&#123;end&#125;&quot; +%Y-%m-%d`	# 日期自增</span><br></pre></td></tr></table></figure>
<p>然后再就可以取到两边的边界值了。<br>**注意:**这样比较的时候，一定要注意<code>while</code>里面的左右条件一定要用<code>&quot;&quot;</code>引起来，<code>&#39;</code>不行。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本报错：Syntax error: &#39;(&#39; unexpected</title>
    <url>/2015/11/10/Shell%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99%EF%BC%9ASyntax-error-unexpected/</url>
    <content><![CDATA[<p>执行脚本报错:</p>
<blockquote>
<p>Syntax error: “(“ unexpected</p>
</blockquote>
<p>与实际使用的Shell版本有关，判断方法可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">⚡ ⇒ <span class="built_in">ls</span> -l /bin/*sh</span><br><span class="line">-rwxr-xr-x 1 root root 1021112 10月  8  2014 /bin/bash</span><br><span class="line">-rwxr-xr-x 1 root root  121272  2月 19  2014 /bin/dash</span><br><span class="line">lrwxrwxrwx 1 root root       4 10月  8  2014 /bin/rbash -&gt; bash</span><br><span class="line">lrwxrwxrwx 1 root root      22 10月 24 18:08 /bin/rzsh -&gt; /etc/alternatives/rzsh</span><br><span class="line">lrwxrwxrwx 1 root root       4 10月 24 14:21 /bin/sh -&gt; dash</span><br><span class="line">lrwxrwxrwx 1 root root       7 10月 24 14:21 /bin/static-sh -&gt; busybox</span><br><span class="line">lrwxrwxrwx 1 root root      21 10月 24 18:08 /bin/zsh -&gt; /etc/alternatives/zsh</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>sh</code>果然被重定向到<code>dash</code>。因此，如果执行<code>./scirpt.sh</code>，使用的是<code>dash</code>。<br>避免报错方法很多，可以手动指定用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash script.sh</span><br></pre></td></tr></table></figure>
<p>或者，在脚本第一行制定用什么Shell来执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 下载与入门</title>
    <url>/2016/06/21/Spark-%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>开发环境:<br>OS: Ubuntu 16.04 64bit</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo wget http://d3kbcqa49mib13.cloudfront.net/spark-1.6.1-bin-hadoop2.6.tgz</span><br><span class="line">sudo tar -xvf spark-1.6.1-bin-hadoop2.6.tgz -C /usr/dev </span><br><span class="line">sudo chown -R anonymous:anonymous spark-1.6.1-bin-hadoop2.6	# anonymous为当前用户名</span><br></pre></td></tr></table></figure>

<h4 id="运行Spark"><a href="#运行Spark" class="headerlink" title="运行Spark"></a>运行Spark</h4><p>Spark支持多种语言,我们可以通过Python,Scala进入Spark交互式环境。</p>
<ul>
<li>Scala Shell</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/dev/spark-1.6.1-bin-hadoop2.6</span><br><span class="line">./bin/spark-shell	# 启动Scala Shell</span><br></pre></td></tr></table></figure>
<p>**注意:**如果报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tue Jun 21 23:30:04 CST 2016 Thread[main,5,main] java.io.FileNotFoundException: derby.log (权限不够)</span><br><span class="line">16/06/21 23:30:04 WARN Connection: BoneCP specified but not present in CLASSPATH (or one of dependencies)</span><br><span class="line">Tue Jun 21 23:30:04 CST 2016 Thread[main,5,main] Cleanup action starting</span><br><span class="line">ERROR XBM0H: Directory /usr/dev/spark-1.6.1-bin-hadoop2.6/bin/metastore_db cannot be created.</span><br></pre></td></tr></table></figure>
<p>出现这个问题一般就是没有创建文件的权限,安装的最后一个命令就是起这个作用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown -R anonymous:anonymous spark-1.6.1-bin-hadoop2.6	# anonymous为当前用户名</span><br></pre></td></tr></table></figure>

<ul>
<li>Python Shell</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/pyspark</span><br></pre></td></tr></table></figure>
<p>为了在Shell里面写Python有补全提示，强烈建议安装<code>ipython</code>,Ubuntu安装也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y ipython</span><br></pre></td></tr></table></figure>
<p>然后启动的时候可以这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPYTHON=1 ./bin/pyspark</span><br></pre></td></tr></table></figure>
<p>进入Shell大概是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  spark-1.6.1-bin-hadoop2.6 IPYTHON=1 bin/pyspark</span><br><span class="line">Python 2.7.11+ (default, Apr 17 2016, 14:00:29) </span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 2.4.1 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&#x27;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&#x27;s own help system.</span><br><span class="line">object?   -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.</span><br><span class="line">Using Spark&#x27;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line">16/06/21 23:57:06 INFO SparkContext: Running Spark version 1.6.1</span><br><span class="line">16/06/21 23:57:06 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 1.6.1</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 2.7.11+ (default, Apr 17 2016 14:00:29)</span><br><span class="line">SparkContext available as sc, HiveContext available as sqlContext.</span><br><span class="line"></span><br><span class="line">In [1]: lines = sc.textFile(&quot;README.md&quot;)</span><br></pre></td></tr></table></figure>
<p>如果你觉得这样也有些麻烦,可以在<code>~/.bashrc</code>里面加一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ipython=&#x27;IPYTHON=1&#x27;</span><br></pre></td></tr></table></figure>
<p>然后就可以这么启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cd /usr/dev/spark-1.6.1-bin-hadoop2.6 </span><br><span class="line">➜  spark-1.6.1-bin-hadoop2.6 ipython bin/pyspark </span><br></pre></td></tr></table></figure>

<h4 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h4><p>Scala也不熟，就以Python为例吧,注意我的当前目录是在<code>/usr/dev/spark-1.6.1-bin-hadoop2.6</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: lines = sc.textFile(&quot;README.md&quot;)</span><br><span class="line"> n [2]: lines.count()</span><br><span class="line">16/06/21 23:57:41 INFO FileInputFormat: Total input paths to process : 1</span><br><span class="line">16/06/21 23:57:41 INFO SparkContext: Starting job: count at &lt;ipython-input-2-44aeefde846d&gt;:1</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Got job 0 (count at &lt;ipython-input-2-44aeefde846d&gt;:1) with 2 output partitions</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Final stage: ResultStage 0 (count at &lt;ipython-input-2-44aeefde846d&gt;:1)</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Parents of final stage: List()</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Missing parents: List()</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Submitting ResultStage 0 (PythonRDD[2] at count at &lt;ipython-input-2-44aeefde846d&gt;:1), which has no missing parents</span><br><span class="line">16/06/21 23:57:41 INFO MemoryStore: Block broadcast_1 stored as values in memory (estimated size 5.6 KB, free 173.1 KB)</span><br><span class="line">16/06/21 23:57:41 INFO MemoryStore: Block broadcast_1_piece0 stored as bytes in memory (estimated size 3.4 KB, free 176.6 KB)</span><br><span class="line">16/06/21 23:57:41 INFO BlockManagerInfo: Added broadcast_1_piece0 in memory on localhost:36609 (size: 3.4 KB, free: 511.5 MB)</span><br><span class="line">16/06/21 23:57:41 INFO SparkContext: Created broadcast 1 from broadcast at DAGScheduler.scala:1006</span><br><span class="line">16/06/21 23:57:41 INFO DAGScheduler: Submitting 2 missing tasks from ResultStage 0 (PythonRDD[2] at count at &lt;ipython-input-2-44aeefde846d&gt;:1)</span><br><span class="line">16/06/21 23:57:41 INFO TaskSchedulerImpl: Adding task set 0.0 with 2 tasks</span><br><span class="line">16/06/21 23:57:41 INFO TaskSetManager: Starting task 0.0 in stage 0.0 (TID 0, localhost, partition 0,PROCESS_LOCAL, 2151 bytes)</span><br><span class="line">16/06/21 23:57:41 INFO TaskSetManager: Starting task 1.0 in stage 0.0 (TID 1, localhost, partition 1,PROCESS_LOCAL, 2151 bytes)</span><br><span class="line">16/06/21 23:57:41 INFO Executor: Running task 0.0 in stage 0.0 (TID 0)</span><br><span class="line">16/06/21 23:57:41 INFO Executor: Running task 1.0 in stage 0.0 (TID 1)</span><br><span class="line">16/06/21 23:57:41 INFO HadoopRDD: Input split: file:/usr/dev/spark-1.6.1-bin-hadoop2.6/README.md:0+1679</span><br><span class="line">16/06/21 23:57:41 INFO HadoopRDD: Input split: file:/usr/dev/spark-1.6.1-bin-hadoop2.6/README.md:1679+1680</span><br><span class="line">16/06/21 23:57:41 INFO deprecation: mapred.tip.id is deprecated. Instead, use mapreduce.task.id</span><br><span class="line">16/06/21 23:57:41 INFO deprecation: mapred.task.id is deprecated. Instead, use mapreduce.task.attempt.id</span><br><span class="line">16/06/21 23:57:41 INFO deprecation: mapred.task.is.map is deprecated. Instead, use mapreduce.task.ismap</span><br><span class="line">16/06/21 23:57:41 INFO deprecation: mapred.task.partition is deprecated. Instead, use mapreduce.task.partition</span><br><span class="line">16/06/21 23:57:41 INFO deprecation: mapred.job.id is deprecated. Instead, use mapreduce.job.id</span><br><span class="line">16/06/21 23:57:42 INFO PythonRunner: Times: total = 283, boot = 268, init = 14, finish = 1</span><br><span class="line">16/06/21 23:57:42 INFO PythonRunner: Times: total = 291, boot = 272, init = 19, finish = 0</span><br><span class="line">16/06/21 23:57:42 INFO Executor: Finished task 0.0 in stage 0.0 (TID 0). 2124 bytes result sent to driver</span><br><span class="line">16/06/21 23:57:42 INFO Executor: Finished task 1.0 in stage 0.0 (TID 1). 2124 bytes result sent to driver</span><br><span class="line">16/06/21 23:57:42 INFO TaskSetManager: Finished task 0.0 in stage 0.0 (TID 0) in 407 ms on localhost (1/2)</span><br><span class="line">16/06/21 23:57:42 INFO TaskSetManager: Finished task 1.0 in stage 0.0 (TID 1) in 393 ms on localhost (2/2)</span><br><span class="line">16/06/21 23:57:42 INFO DAGScheduler: ResultStage 0 (count at &lt;ipython-input-2-44aeefde846d&gt;:1) finished in 0.423 s</span><br><span class="line">16/06/21 23:57:42 INFO TaskSchedulerImpl: Removed TaskSet 0.0, whose tasks have all completed, from pool </span><br><span class="line">16/06/21 23:57:42 INFO DAGScheduler: Job 0 finished: count at &lt;ipython-input-2-44aeefde846d&gt;:1, took 0.489031 s</span><br><span class="line">Out[2]: 95</span><br><span class="line"></span><br><span class="line">In [3]: lines.first()</span><br><span class="line">16/06/21 23:58:15 INFO SparkContext: Starting job: runJob at PythonRDD.scala:393</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Got job 1 (runJob at PythonRDD.scala:393) with 1 output partitions</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Final stage: ResultStage 1 (runJob at PythonRDD.scala:393)</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Parents of final stage: List()</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Missing parents: List()</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Submitting ResultStage 1 (PythonRDD[3] at RDD at PythonRDD.scala:43), which has no missing parents</span><br><span class="line">16/06/21 23:58:15 INFO MemoryStore: Block broadcast_2 stored as values in memory (estimated size 4.8 KB, free 181.3 KB)</span><br><span class="line">16/06/21 23:58:15 INFO MemoryStore: Block broadcast_2_piece0 stored as bytes in memory (estimated size 3.0 KB, free 184.3 KB)</span><br><span class="line">16/06/21 23:58:15 INFO BlockManagerInfo: Added broadcast_2_piece0 in memory on localhost:36609 (size: 3.0 KB, free: 511.5 MB)</span><br><span class="line">16/06/21 23:58:15 INFO SparkContext: Created broadcast 2 from broadcast at DAGScheduler.scala:1006</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Submitting 1 missing tasks from ResultStage 1 (PythonRDD[3] at RDD at PythonRDD.scala:43)</span><br><span class="line">16/06/21 23:58:15 INFO TaskSchedulerImpl: Adding task set 1.0 with 1 tasks</span><br><span class="line">16/06/21 23:58:15 INFO TaskSetManager: Starting task 0.0 in stage 1.0 (TID 2, localhost, partition 0,PROCESS_LOCAL, 2151 bytes)</span><br><span class="line">16/06/21 23:58:15 INFO Executor: Running task 0.0 in stage 1.0 (TID 2)</span><br><span class="line">16/06/21 23:58:15 INFO HadoopRDD: Input split: file:/usr/dev/spark-1.6.1-bin-hadoop2.6/README.md:0+1679</span><br><span class="line">16/06/21 23:58:15 INFO PythonRunner: Times: total = 41, boot = -33244, init = 33285, finish = 0</span><br><span class="line">16/06/21 23:58:15 INFO Executor: Finished task 0.0 in stage 1.0 (TID 2). 2143 bytes result sent to driver</span><br><span class="line">16/06/21 23:58:15 INFO TaskSetManager: Finished task 0.0 in stage 1.0 (TID 2) in 67 ms on localhost (1/1)</span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: ResultStage 1 (runJob at PythonRDD.scala:393) finished in 0.068 s</span><br><span class="line">16/06/21 23:58:15 INFO TaskSchedulerImpl: Removed TaskSet 1.0, whose tasks have all completed, from pool </span><br><span class="line">16/06/21 23:58:15 INFO DAGScheduler: Job 1 finished: runJob at PythonRDD.scala:393, took 0.082887 s</span><br><span class="line">Out[3]: u&#x27;# Apache Spark&#x27;</span><br></pre></td></tr></table></figure>
<p>看看，其实很简单的，但是有个问题，每次输入一个操作，结果搞出这么一大堆的日志，看着确实影响输入，我们可以控制一下Spark的输出日志级别,编辑<code>spark-1.6.1-bin-hadoop2.6/conf/log4j.properties.template</code>文件,为了安全起见，我们直接拷贝一份模板作为我们的日志配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd conf/</span><br><span class="line">sudo cp log4j.properties.template log4j.properties</span><br></pre></td></tr></table></figure>
<p>定位到这一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory=INFO, console</span><br></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory=WARN, console</span><br></pre></td></tr></table></figure>
<p>看看之前的操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using Python version 2.7.11+ (default, Apr 17 2016 14:00:29)</span><br><span class="line">SparkContext available as sc, HiveContext available as sqlContext.</span><br><span class="line"></span><br><span class="line">In [1]: lines = sc.textFile(&quot;README.md&quot;)</span><br><span class="line"></span><br><span class="line">In [2]: lines.count()</span><br><span class="line">Out[2]: 95</span><br><span class="line"></span><br><span class="line">In [3]: lines.first()</span><br><span class="line">Out[3]: u&#x27;# Apache Spark&#x27;</span><br><span class="line"></span><br><span class="line">In [4]: </span><br></pre></td></tr></table></figure>
<p>这样就只会输出警告及以上的日志了。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>开发环境</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 Atom 编辑器中文乱码</title>
    <url>/2015/12/17/Ubuntu-14-04-Atom-%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>最近尝鲜试了一把<code>Atom</code>编辑器，发现在Ubuntu上这个编辑器果然还是刚出来，不是很成熟，中文显示不了，换了中文编码<code>GBK</code>，<code>GB18030</code>也不行。网上很多人说换成文泉驿字体就可以了，但是我试了发现，还是乱码。很多人都是抄那一种方法，都没有去试试到底行不行，其实方法没有错，只是不是所有的人都可以这么解决乱码，正确的步骤应该是：</p>
<ol>
<li><p>从菜单中打开<code>Edit-&gt;Open your config</code>选项，或者<code>setting views</code>中的<code>font-family</code>选项，把字体设置成你机器上有的中文字体</p>
</li>
<li><p>怎么看自己机器上的中文字体，你可以在终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fc-list :lang=zh</span><br><span class="line">/usr/share/fonts/truetype/arphic/uming.ttc: AR PL UMing TW MBE:style=Light</span><br><span class="line">/usr/share/fonts/truetype/arphic/ukai.ttc: AR PL UKai CN:style=Book</span><br><span class="line">/usr/share/fonts/truetype/arphic/ukai.ttc: AR PL UKai HK:style=Book</span><br><span class="line">/usr/share/fonts/simsun.ttf: SimSun,宋体:style=Regular</span><br><span class="line">/usr/share/fonts/truetype/arphic/ukai.ttc: AR PL UKai TW:style=Book</span><br><span class="line">/usr/share/fonts/truetype/droid/DroidSansFallbackFull.ttf: Droid Sans Fallback:style=Regular</span><br><span class="line">/usr/share/fonts/truetype/arphic/ukai.ttc: AR PL UKai TW MBE:style=Book</span><br><span class="line">/usr/share/fonts/truetype/arphic/uming.ttc: AR PL UMing TW:style=Light</span><br><span class="line">/usr/share/fonts/truetype/arphic/uming.ttc: AR PL UMing CN:style=Light</span><br><span class="line">/usr/share/fonts/truetype/arphic/uming.ttc: AR PL UMing HK:style=Light</span><br></pre></td></tr></table></figure>
<p> 之前由于<code>IDEA</code>这款<code>IDE</code>有乱码我下载了<code>SimSun</code>字体，所以我就没有按照网上的去设置什么文泉驿字体了，我压根就没有，再设置也是乱码。</p>
</li>
<li><p>最终配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">editor:</span><br><span class="line"></span><br><span class="line">invisibles:</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  tabLength: 4</span><br><span class="line">  fontFamily: &quot;SimSun&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 Git 配置</title>
    <url>/2015/10/06/Ubuntu-14-04-Git-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>首先测试一下电脑安装git没有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>没有安装则按照以下步骤来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core git-gui git-doc gitk</span><br></pre></td></tr></table></figure>

<p>安装完毕看看是否安装成功，如果安装成功的版本低于1.9.5则说明Ubuntu版本太低，进行如下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>安装成功之后再次测试，版本就应该是比较高了。</p>
<p>以上安装的是git，但是没有图形化界面，如果需要图形化界面，需要安装工具KDiff3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install kdiff3</span><br></pre></td></tr></table></figure>

<p>安装好以上几个基本的组件之后，还需要做一些简单的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;san.zhang&quot;</span>            <span class="comment"># 请换成你自己的名字，除非你凑巧也叫san.zhang</span></span><br><span class="line">git config --global user.email <span class="string">&quot;san.zhang@qq.com&quot;</span>   <span class="comment"># 同上</span></span><br><span class="line">git config --global merge.tool <span class="string">&quot;kdiff3&quot;</span>             <span class="comment"># 要是没装KDiff3就不用设这一行</span></span><br><span class="line">git config --global push.default simple             <span class="comment"># 要是你非要用低版本的`Git`（比如1.7.x），好吧，那就不设`simple`设`current`，否则你的`Git`不支持</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span>             <span class="comment"># 让Git不要管Windows/Unix换行符转换的事</span></span><br><span class="line">git config --global gui.encoding utf-8              <span class="comment"># 避免git gui中的中文乱码</span></span><br><span class="line">git config --global core.quotepath off              <span class="comment"># 避免git status显示的中文文件名乱码</span></span><br><span class="line">git config --global core.editor nano                <span class="comment"># 辑器，默认是vim，但是可以自己配置成其他的，可以使用nano </span></span><br></pre></td></tr></table></figure>

<h3 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h3><p>如果要跟Git服务器打交道，还要设ssh。注意，不要在跳板机等Ops&#x2F;IT已经为你设了<code>ssh key pair</code>的地方做下面的操作。<br>注意，少数童鞋如果以前为连接<code>GitHub/oschina</code>等已经生成过<code>ssh key pair</code>，这里不必再次生成，复用即可。<br>在<code>Linux</code>的命令行下，或<code>Windos</code>上<code>Git Bash</code>命令行窗口中（总之不要用iOS），键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;san.zhang@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后一路回车，不要输入任何密码之类，生成<code>ssh key pair</code>。如果在<code>Linux</code>上，需要把其中的私钥告诉本地系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>再把其中公钥的内容复制到<code>Git</code>服务器上。具体方法是：<br>显示ssh公钥的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>密钥内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDCE6avWtobESaS6nngDJnLFPPHZ+enhp+twpRw/t+9uaM/IFRhgP8YO09jG4Vdq8h5tzUe+ijM4b/rtVNAROCngkegrefopMwcqVNxQiFP/9Dl67/qOxorcYWhizQLjIzAdQxMGoNTebozjbLElWLO1pramWaK+nqO1PQL13olUinZa1Hxhv3XTCpODoPdz1woyVfYaPu4knjODQp2E3aawtmeZ5A7EJP7696XWi1tjK44iMWwZMWTOYbSGTyXq62xT5YfVmQFwxhG5tJYD6h27R65b0/WKOM7Y8cwVmo9RqpgFRJ5EPd42Fr6pjyBkPOGpVQkUn+V/GVpKrC+LWIJ san.zhang@qq.com</span><br></pre></td></tr></table></figure>

<p>打开<code>Github</code>网页，具体位置自行百度。点击<code>Add SSH Key</code>，然后把刚才<code>ssh</code>公钥<code>id_rsa.pub</code>（<code>windows</code>下的用户目录找到<code>.ssh</code>文件夹进去就可以看到）的内容paste进去。不需要填<code>title</code>，<code>title</code>会自动生成。<br>要是<code>Git</code>服务器报“不是有效的<code>key</code>”之类的错误，可能是你没去除注意去除多余的回车符，也可能是<code>paste</code>之前<code>copy</code>的时候，没<code>copy</code>最开头的<code>ssh-rsa</code>这几个字。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Git</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04下 IntelliJ IDEA 乱码</title>
    <url>/2015/10/25/Ubuntu-14-04-IntelliJ-IDEA-%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>在Ubuntu下，由于缺少宋体，导致中文路径出现乱码，解决办法是先下载字体，然后在IDEA中设置使用宋体即可。<br>乱码有几种情况，</p>
<h3 id="编辑器以及调试信息乱码"><a href="#编辑器以及调试信息乱码" class="headerlink" title="编辑器以及调试信息乱码"></a>编辑器以及调试信息乱码</h3><p>解决方案，选择<code>File--&gt;settings--&gt;Editor--&gt;File Encoding</code><br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2014.04%E4%B8%8B%20IntelliJ%20IDEA%20%E4%B9%B1%E7%A0%8101.png" alt="IDEA 中设置默认字符编码"><br>如上图所示，两个编码都选择<code>UTF-8</code>，这样可以保证以后新建的文件编码方式，防止乱码。</p>
<h3 id="IDEA-其他窗口乱码"><a href="#IDEA-其他窗口乱码" class="headerlink" title="IDEA 其他窗口乱码"></a>IDEA 其他窗口乱码</h3><p>如下图所示：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2014.04%E4%B8%8B%20IntelliJ%20IDEA%20%E4%B9%B1%E7%A0%8102.png" alt="IDEA 中窗口乱码"><br>出现这样的原因是linux系统提供的字体不支持中文的显示，在idea中，默认的是ubuntu字体，该字体并不支持中文显示。因此，还需要自己下载一个支持中文显示的字体。</p>
<ul>
<li>下载simsun字体，<a href="http://pan.baidu.com/s/1pJ06y2B">百度盘下载地址</a></li>
<li>将下载好的字体添加到系统字体库中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> Downloads/simsun.ttf /usr/share/fonts</span><br></pre></td></tr></table></figure>

<ul>
<li>重启IDEA，设置字体<br>重启idea，然后选择<code>File-&gt;settings-&gt;Appearance &amp; Behavior-&gt;Appearance</code>.如下所示：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2014.04%E4%B8%8B%20IntelliJ%20IDEA%20%E4%B9%B1%E7%A0%8103.png" alt="IDEA中设置simsun字体"><br>在右边勾选上<code>Override default fonts by(....)</code>,并在<code>Name</code>选项中选择刚刚添加的SimSun字体。</li>
</ul>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 Sublime Text 3 不能输入中文</title>
    <url>/2015/10/02/Ubuntu-14-04-Sublime-Text-3-%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h3 id="Ubuntu-14-04-Sublime-Text-3-不能输入中文"><a href="#Ubuntu-14-04-Sublime-Text-3-不能输入中文" class="headerlink" title="Ubuntu 14.04 Sublime Text 3 不能输入中文"></a>Ubuntu 14.04 Sublime Text 3 不能输入中文</h3><p><code>sublime</code>这个编辑器很好用，小巧，比<code>IDE</code>要轻，主要是想用来写<code>markdown</code>。但是<code>ubuntu</code>下不能输入中文，这是一个很大的问题。</p>
<h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><blockquote>
<p>Ubuntu 14.04 64bits<br>sougou pingyin v1.2.0.0056<br>Sublime Text 3</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>1.打开终端，下载所需要的库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~  git clone git@github.com:lyfeyaj/sublime-text-imfix.git</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 如果你没有装<code>git</code>，直接去<a href="https://github.com/lyfeyaj/sublime-text-imfix">项目github</a>地址下载也行。下载下来的项目的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  sublime-text-imfix git:(master) tree -L 3</span><br><span class="line">.</span><br><span class="line">├── image</span><br><span class="line">│   └── fcitx.png</span><br><span class="line">├── lib</span><br><span class="line">│   └── libsublime-imfix.so</span><br><span class="line">├── README.md</span><br><span class="line">├── src</span><br><span class="line">│   ├── anran.tar.gz</span><br><span class="line">│   ├── subl</span><br><span class="line">│   └── sublime-imfix.c</span><br><span class="line">└── sublime-imfix</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure>
<ul>
<li>2.将subl移动到&#x2F;usr&#x2F;bin&#x2F;，并且将sublime-imfix.so移动到&#x2F;opt&#x2F;sublime_text&#x2F;（sublime的安装目录）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~  cd sublime-text-imfix</span><br><span class="line">➜  ~  sudo cp ./lib/libsublime-imfix.so /opt/sublime_text </span><br><span class="line">➜  ~  sudo cp ./src/subl /usr/bin/</span><br></pre></td></tr></table></figure>

<ul>
<li>3.用subl命令试试能不能启动sublime，如果成功启动的话，应该就可以输入中文了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~  subl</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
        <tag>Web</tag>
        <tag>开发环境</tag>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 64位 安装WPS</title>
    <url>/2015/12/29/Ubuntu-14-04-64%E4%BD%8D-%E5%AE%89%E8%A3%85WPS/</url>
    <content><![CDATA[<p>经常要处理数据,自带的那个<code>LibreOffice</code>看看数据还行,但是要自己统计,我还是不太会用,所以就装了个<code>WPS for Linux</code>.之前也装过一次,但是装完了启动不了,今天要做统计,所以就再装了一下.</p>
<p>首先要下载安装包<a href="http://kdl.cc.ksosoft.com/wps-community/download/a20/wps-office_10.1.0.5444~a20_amd64.deb">wps-office_10.1.0.5444~a20_amd64.deb</a></p>
<p>直接点开就可以安装,但是正常情况下会安装失败,缺少依赖啥的,所以要装依赖库<code>libc6-i386</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install libc6-i386</span><br></pre></td></tr></table></figure>

<p>安装成功之后再重新安装<code>WPS</code>的安装包,装好了就可以使用了,记住,刚开始启动可能会有个警告报错,缺少字体,下载对应的字体就可以了,当然不下载也是可以使用的,没有什么多大的区别.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 使用VPN</title>
    <url>/2015/10/25/Ubuntu-14-04-%E4%BD%BF%E7%94%A8VPN/</url>
    <content><![CDATA[<p>Linux下使用VPN十分简单，只需要安装一软件即可。</p>
<ul>
<li>安装网络挂件<code>vpnc</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vpnc</span><br></pre></td></tr></table></figure>

<ul>
<li>找到公司的默认配置文件<code>xxx_common.pcf</code>,使用命令将其转化成对应的配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pcf2vpnc Documents/xxx_common.pcf default.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>替换配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 /etc/vpnc </span><br><span class="line">sudo <span class="built_in">cp</span> default.conf /etc/vpnc</span><br></pre></td></tr></table></figure>

<ul>
<li>更改配置文件中的账户Xauth username</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vpnc/default.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>连接VPN</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vpnc-connect</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong> 关闭连接用<code>sudo vpnc-disconnect</code>。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 MySQL 从本地文件批量导入数据</title>
    <url>/2015/11/22/Ubuntu-14-04-MySQL-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>想做几个数据测试，于是把服务器上的<code>mysql</code>数据查询结果导入到服务器本地一个文件中，然后下载到本地机器想直接导入到自己机器的mysql表中:<br>假设我的MySQL用户名和密码分别为:root root123456,对应的库为test,表为user</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载的文件为result.txt,目录为当前用户根目录,即~/result.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入mysql</span></span><br><span class="line">$ mysql -uroot -proot123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行导入命令</span></span><br><span class="line">mysql&gt; use <span class="built_in">test</span>;</span><br><span class="line">mysql&gt; load data <span class="built_in">local</span> infile <span class="string">&#x27;~/result.txt&#x27;</span> into table user;</span><br></pre></td></tr></table></figure>
<p>结果报错，信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1148 (42000): The used command is not allowed with this MySQL version</span><br></pre></td></tr></table></figure>
<p>**备注:**网上查了一下：如果指定<code>local</code>关键词，则表明从客户主机读文件。如果<code>local</code>没指定，文件必须位于服务器上。既然是在本地机器上测试，那么我们也是服务器，所以我们可以去掉这个<code>local</code>参数，直接导入,结果又报新的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; load data infile &#x27;~/result.txt&#x27; into table user;</span><br><span class="line">ERROR 13 (HY000): Can&#x27;t get stat of &#x27;/var/lib/mysql/test/result.txt&#x27; (Errcode: 2)</span><br></pre></td></tr></table></figure>
<p>在我们指定的路径处<code>var/lib/mysql/test/result.txt</code>没有找到这个文件,原来默认是在*<strong>当前数据库</strong>(此处为我们的<code>test</code>库)目录下载入文件。我的文件放在当前用户的根目录下，当然会找不到，于是我把文件拷贝到这个目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> ~/result.txt /var/lib/mysql/test</span><br></pre></td></tr></table></figure>
<p>这回应该可以导入了吧，再次执行导入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> load data infile <span class="string">&#x27;~/result.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br><span class="line">ERROR <span class="number">13</span> (HY000): Can<span class="string">&#x27;t get stat of &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>result.txt<span class="string">&#x27; (Errcode: 2)</span></span><br></pre></td></tr></table></figure>
<p>还是报错，奇怪了，难道文件没有拷贝到我们指定的目录？为了一探究竟，我决定去这个目录下看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/mysql</span><br><span class="line"><span class="built_in">cd</span>: permission denied: /var/lib/mysql</span><br></pre></td></tr></table></figure>
<p>访问权限受限了，这个简单，加上就行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> 777 mysql</span><br><span class="line">$ <span class="built_in">cd</span> mysql</span><br></pre></td></tr></table></figure>
<p>没问题了，然后进入<code>test</code>目录，果然还是一样没权限，同样处理，然后进入<code>test</code>目录，居然有我们的<code>result.txt</code>文件。然后重新在mysql里执行导入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> load data infile <span class="string">&#x27;~/result.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br><span class="line">Query OK, <span class="number">44173</span> <span class="keyword">rows</span> affected (<span class="number">0.22</span> sec)</span><br><span class="line">Records: <span class="number">44173</span>  Deleted: <span class="number">0</span>  Skipped: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我擦，居然成功了，看来果然是权限的问题,虽然有点儿麻烦，但是可以导入数据就行。有时间再研究一下加<code>local</code>的用法。</p>
<p>其实不用这么麻烦，主要要先赋权限，然后再加一个参数就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R zhangsan:zhangsan /var/lib/mysql </span><br><span class="line">$ sudo chown -R mysql:mysql /var/lib/mysql</span><br><span class="line">$ sudo mysql -uroot --local-infile=1 -proot123456</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &#x27;/home/zhangsan/result.txt&#x27; REPLACE INTO TABLE oc_daily_order_cheche FIELDS TERMINATED BY &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure>
<p>所以其实主要问题在一个<code>--local-infile=1</code>以及一个权限问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 IDEA配置和使用</title>
    <url>/2015/10/25/Ubuntu-14-04-IDEA%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>IDEA相比Eclipse的好处我这里就不多说了，反正感觉无论是界面还是与其他插件的集成都做的非常好，特别是git和数据库这块，做的时想当好。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先根据系统下载对应IDEA的压缩包，以Ubuntu 14.04的64位系统为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf ideaIU-14.0.3.tar.gz -C /usr/dev</span><br><span class="line"><span class="built_in">cd</span> /usr/dev/idea-IU-139.1117.1/bin</span><br><span class="line">./idea.sh</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>正常情况下，在你启动成功之后，可以在Ubuntu应用里直接启动，但是我的总是不行，没办法，在用户根目录下建了一个脚本，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/dev/idea-IU-139.1117.1/bin/idea.sh &amp;</span><br></pre></td></tr></table></figure>
<p>然后对脚本赋可执行权限</p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>必装插件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eclipse Code Formatter</span><br><span class="line">Lombok plugin</span><br><span class="line">Vim Emulation</span><br></pre></td></tr></table></figure>
<p>激活服务器搭建:<a href="http://blog.lanyus.com/archives/174.html">http://blog.lanyus.com/archives/174.html</a></p>
<h3 id="无法切换中文输入法"><a href="#无法切换中文输入法" class="headerlink" title="无法切换中文输入法"></a>无法切换中文输入法</h3><p>修改启动脚本<code>/usr/dev/idea-IU-139.1117.1/bin/idea.sh</code>,头部加入下面几行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>
<p>前提是你用的是<code>fcitx</code>架构的输入法.</p>
<h3 id="序列化ID警告"><a href="#序列化ID警告" class="headerlink" title="序列化ID警告"></a>序列化ID警告</h3><p>I am not sure if you have an old version of IntelliJ but If I go File &#x3D;&gt; Settings… &#x3D;&gt; Inspections &#x3D;&gt; Serialization issues &#x3D;&gt;  Serializable class without ‘serialVersionUID’ enabled, the class you provide give me warnings</p>
<h3 id="文件头模板d定制"><a href="#文件头模板d定制" class="headerlink" title="文件头模板d定制"></a>文件头模板d定制</h3><p>文件上右击–New–Edit File Templates–Includes–File Header</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 Sublime Text 3 手动安装插件</title>
    <url>/2015/10/02/Ubuntu-14-04-Sublime-Text-3-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="Ubuntu-14-04-Sublime-Text-3-手动安装插件"><a href="#Ubuntu-14-04-Sublime-Text-3-手动安装插件" class="headerlink" title="Ubuntu 14.04 Sublime Text 3 手动安装插件"></a>Ubuntu 14.04 Sublime Text 3 手动安装插件</h3><p>首先声明，这种方式只针对于在线安装失败的情况下，例如公司封端口，或者远端仓库不稳定的情况，<code>github</code>在国内有时候确实不太稳定。</p>
<h4 id="先安装Package-Control"><a href="#先安装Package-Control" class="headerlink" title="先安装Package Control"></a>先安装Package Control</h4><ul>
<li><p>Sublime Text 3 终端安装<br>先按ctrl+`调出终端，或者直接 <code>View &gt; Show Console</code><br>然后在终端中输入下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; </span><br><span class="line">h = <span class="string">&#x27;2915d1851351e5ee549c20394736b442&#x27;</span> + <span class="string">&#x27;8bc59f460fa1548d1514676163dafc88&#x27;</span>; </span><br><span class="line">pf = <span class="string">&#x27;Package Control.sublime-package&#x27;</span>; </span><br><span class="line">ipp = sublime.installed_packages_path(); </span><br><span class="line">urllib.request.install_opener( </span><br><span class="line">urllib.request.build_opener( </span><br><span class="line">urllib.request.ProxyHandler()</span><br><span class="line">) </span><br><span class="line">); </span><br><span class="line">by = urllib.request.urlopen( <span class="string">&#x27;http://packagecontrol.io/&#x27;</span> + pf.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;%20&#x27;</span>)).read(); </span><br><span class="line">dh = hashlib.sha256(by).hexdigest(); </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Error validating download (got %s instead of %s), please try manual install&#x27;</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> <span class="built_in">open</span>(os.path.join( ipp, pf), <span class="string">&#x27;wb&#x27;</span> ).write(by)</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 如果在线安装失败，可以离线安装，具体方法是：</p>
</li>
<li><p>下载<code>Package Control</code>安装包<a href="https://packagecontrol.io/Package%20Control.sublime-package">Package Control.sublime-package</a></p>
</li>
<li><p>找到<code>Preferences &gt; Browse Packages</code>,打开的主目录为<code>Packages</code>，到上一级目录<code>sublime-text-3</code>，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  sublime-text-3  tree -L 1</span><br><span class="line">.</span><br><span class="line">├── Cache</span><br><span class="line">├── Installed Packages</span><br><span class="line">├── Local</span><br><span class="line">└── Packages</span><br></pre></td></tr></table></figure>
</li>
<li><p>把下载的<code>Package Control.sublime-package</code>离线压缩包拷到<code>Installed Packages</code>目录下(不用解压)，然后重启<code>sublime text 3</code>，然后在<code>Preferences</code>菜单下就可以看到多了两个选项<code>Package Settings</code>和<code>Package Control</code>，这就说明安装成功了。</p>
</li>
</ul>
<h4 id="安装MarkdownEditing插件"><a href="#安装MarkdownEditing插件" class="headerlink" title="安装MarkdownEditing插件"></a>安装M<code>arkdownEditing</code>插件</h4><ul>
<li>首先下载插件安装包,并将安装包拷贝到<code>Sublime Text 3</code>的安装目录下对应的目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/SublimeText-Markdown/MarkdownEditing.git</span><br><span class="line">sudo cp -r MarkdownEditing/ ~/.config/sublime-text-3/Packages</span><br></pre></td></tr></table></figure>
打开一个<code>.md</code>文件就可以看到效果了。</li>
</ul>
<h4 id="安装Markdown-Preview插件"><a href="#安装Markdown-Preview插件" class="headerlink" title="安装Markdown Preview插件"></a>安装<code>Markdown Preview</code>插件</h4><p>安装上面的插件看到的当然看到的不是最终效果，如果需要预览，还可以装一个<code>Markdown Preview</code>的插件，同样的我的还是不能通过包控制器安装，还是说说如何手动安装吧。<br><strong>NOTE:</strong> 以下方法来自<code>Markdown Preview</code>的<a href="https://github.com/revolunet/sublimetext-markdown-preview">github官方地址</a></p>
<ul>
<li>首先下载插件安装包,并将安装包拷贝到<code>Sublime Text 3</code>的安装目录下对应的目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:revolunet/sublimetext-markdown-preview.git</span><br><span class="line">sudo cp -r sublimetext-markdown-preview ~/.config/sublime-text-3/Packages</span><br></pre></td></tr></table></figure></li>
<li>如果需要预览，可以按输入<code>Shift+Ctrl+p</code>，输入<code>Markdown Preview</code>，可以选择以下几个选项</li>
</ul>
<ul>
<li>Markdown Preview: Preview in Browser</li>
<li>Markdown Preview: Export HTML in Sublime Text</li>
<li>Markdown Preview: Copy to Clipboard</li>
<li>Markdown Preview: Open Markdown Cheat sheet</li>
</ul>
<p>默认就选第一个了，最后选<code>github</code>或者<code>markdown</code>然后就可以在浏览器中查看预览内容了。<br><strong>NOTE:</strong> 但是这样太麻烦，可以设置一个快捷键,点击<code>Preferences-&gt;</code>选择<code>Key Bindings User</code>，将其内容改为如下代码，以后直接按<code>alt+m</code>就可以在浏览器中预览了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;keys&quot;:[&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
        <tag>Sublime Text</tag>
        <tag>插件</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04使用shadowsocks 科学上网</title>
    <url>/2015/10/06/Ubuntu-14-04-%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p><code>shadowsocks</code>是目前本人和小伙伴们使用最多的一种，主要是因为<code>GoAgent</code>作者被请去喝茶了。准备工作，需要有配置好的<code>shadowsocks</code>服务端，这个去搜吧，你如果连一个<code>shadowsocks</code>账号也没有，那也没用，现在假定你有个<br><code>shadowsocks</code>的服务器账号可以用来作代理。<br>看官方提供的安装<code>shadowsocks</code>方法</p>
<blockquote>
<p>pip install shadowsocks</p>
</blockquote>
<p>安装之前可以看下是否有对应的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip search shadowsocks</span><br></pre></td></tr></table></figure>
<p>如果有就装的了，没有的话只能去github上找源码装了。确实，由于<code>shadowsocks</code>传播的太广，作者也被请去喝茶了，所以<code>github</code>上的原项目也被删了，相关服务器也没了，要装<code>shadowsocks</code>只能像下面这样，首先，你要有项目的源码，地址我的<code>github</code>上备份了一份：<a href="git@github.com:sjq597/shadowsocks.git">shadowsocks github地址</a>,貌似这个地址现在好像也访问不了了,直接去github上搜应该可以搜到。使用<code>git clone</code>下来即可，目前最新的就是<code>2.6.1</code>。</p>
<p>接下来，你需要将项目的代码打包安装，命令如下：</p>
<blockquote>
<p>sudo python setup.py install</p>
</blockquote>
<p><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101.png" alt="shadowsocks 目录结构"><br>然后编辑服务端配置文件<code>server.json</code>。没有则创建一个这个文件,下面这个是多端口多密码的配置，编辑内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;1234&quot;:&quot;the fuck password 1234&quot;,</span><br><span class="line">         &quot;1235&quot;:&quot;the fuck password 1235&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端也可以用命令行启动，<code>client.json</code>配置如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#123;your vps ip&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span><span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;the fuck password 1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workers&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>配置照着改，把你的<code>shadowsocks</code>的账号的地址和端口要填对，加密方式看你的账号是啥方式。</p>
<p>服务端启动方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssserver -c ./server.json</span><br></pre></td></tr></table></figure>
<p>好了，安装成功并且编辑成功之后，你现在只需要启动终端中的服务进行端口监听就行(没有图形界面还省内存)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c ./client.json</span><br></pre></td></tr></table></figure>

<p>成功启动的界面就是下面这样的：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9102.png" alt="启动代理服务"></p>
<p>然后你需要在浏览器里设置代理，注意<code>shadowsocks</code>是<code>socks 5</code>代理，所以和<code>vpn</code>还不太一样，默认不是全局代理的，也就是说你的应用<br>没有办法翻墙，但是浏览器可以。</p>
<p>3、设置浏览器代理，以<code>Chrome</code>为例，火狐也是一样。</p>
<p>由于<code>Chrome</code>的商店被墙了，上不了，你需要手动下载<code>SwitchySharp</code>，<a href="http://pan.baidu.com/s/1kTivhMf">百度盘地址</a>。<br>手动安装过程：在<code>Chrome</code>浏览器地址栏输入</p>
<blockquote>
<p>chrome:&#x2F;&#x2F;extensions&#x2F; </p>
</blockquote>
<p>然后把插件拖到浏览器，安装即可。</p>
<p>安装好之后需要进行规则的设置，在工具栏点插件图标，选择<code>options</code>，如图<code>Proxy Profiles</code>：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9103.png" alt="Proxy Profiles界面"><br>注意<code>SOCKS Host</code>地址和端口设置分别为<code>127.0.0.1</code>和<code>1080</code>。特别注意要选<code>SOCKS v5</code>。不代理的地址可以加在下面<code>No Proxy for</code>里面。</p>
<p>还需要设置切换规则，也就是哪些特定的地址用代理，哪些不用，这样有个好处，比如你点开国内的不用代理的网站更快，而且有的号是需要流量的，这样还可以省流量,<code>Switch Rules</code>：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9104.png" alt="Switch Rules界面"><br>上面那些地址就是需要代理的，注意选你能用的代理，我这个插件由于开始使用了<code>goagent</code>，导入了<code>goagent</code>的配置文件，所以有三个代理。<br>但是正是<code>goagent</code>的<code>ip</code>都不好用，而且人多就卡，非常不稳定，我才决定折腾一下<code>shadowsocks</code>。代理规则可以自己填或者从配置文件导入.具体的配置文件<a href="http://pan.baidu.com/s/1jGpOLvg">百度盘连接</a><br>用法就是在插件的<code>Import/Export</code>选项里，<code>Switch Rules</code>里<code>Export Rules List</code>即可。<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9105.png" alt="导入代理规则"><br>手机上的教程就不多讲了，只讲我的<code>android</code>手机配置吧。具体可以取网上搜，也是下一个手机的客户端，在配置文件里配置好你的<br>手机客户端，我在<code>google play</code>下载的，放心，绝对安全，<a href="http://pan.baidu.com/s/1ntF1drF">百度盘地址</a><br>安装之后，点左上角，添加配置文件，配置文件界面如下：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu-14-04%E4%BD%BF%E7%94%A8shadowsocks-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9106.png" alt="安卓代理设置"><br>把你的<code>shadowsocks</code>服务器地址，端口以及密码和加密算法填完就<code>ok</code>。然后点右上角就可以打开了。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 升级gcc</title>
    <url>/2015/11/02/Ubuntu-14-04-%E5%8D%87%E7%BA%A7gcc/</url>
    <content><![CDATA[<p>前段时间安装mysqldb时碰到gcc的编译错误问题,后来看到了网上有人说需要更新gcc编译器,在Ubuntu 14.04下更新gcc也很简单</p>
<h3 id="Ubuntu-更新gcc编译器"><a href="#Ubuntu-更新gcc编译器" class="headerlink" title="Ubuntu 更新gcc编译器"></a>Ubuntu 更新gcc编译器</h3><ul>
<li>首先更新源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-4.9 g++-4.9</span><br></pre></td></tr></table></figure>

<ul>
<li>保留旧的gcc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 10  </span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 20</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 10</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20</span><br></pre></td></tr></table></figure>

<ul>
<li>查看配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br></pre></td></tr></table></figure>
<p> 如下结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  选择       路径        优先级  状态</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0     /usr/bin/gcc-4.9   20   自动模式</span><br><span class="line">  1     /usr/bin/gcc-4.8   10   手动模式</span><br><span class="line">  2     /usr/bin/gcc-4.9   20   手动模式</span><br></pre></td></tr></table></figure>
<p> 可以手动选择使用哪个版本,由于我们把<code>gcc-4.9</code>设置的优先级最高,所以默认就是使用的高版本的,对于<code>g++</code>同样.</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 升级后键盘鼠标失灵解决方案</title>
    <url>/2015/11/21/Ubuntu-14-04-%E5%8D%87%E7%BA%A7%E5%90%8E%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E5%A4%B1%E7%81%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>最近家里的台式机<code>Ubuntu 14.04 64bit</code>升级了内核之后，重启之后鼠标键盘全都失灵了，连登陆系统输密码的地方都输入不了，鼠标键盘都失效连重启都没办法，只能强行按电源键关机。<br>网上查了各种资料，都有说在系统里修复啥的，但是我压根就连系统也进不去，如果要修复就只能用启动盘了。开始怀疑是USB接口的问题，但是进<code>Windows 10</code>一点问题都没有，鼠标键盘都是好的。看来是Ubuntu系统升级的问题，可能是升级之后驱动的不兼容，后来一想，既然在Grub启动菜单那里键盘鼠标还可以用，于是试了一下其他的几个启动项，发现在高级选项里可以选择使用其他内核驱动，抱着试一试的态度，试了倒数第二个，恢复模式，结果进去之后，貌似要重置系统，不敢点，于是退出来，选了上一个版本的内核，但是这回是选择正常启动，结果居然好使了。看来就是系统内核的问题，可能主板的驱动不兼容吧，暂时就这么用了吧。顺便说一下，Ubuntu的升级真是他妈的坑爹，老是碰到升级卡死，然后强行关机，然后就启动不了了，这回升级倒是可以，结果升级内核之后居然还不好使。<br>具体的操作记录在下面了，首先开机进入Grub菜单：</p>
<ul>
<li><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2014.04%20%E5%8D%87%E7%BA%A7%E5%90%8E%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E5%A4%B1%E7%81%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%8801.jpg" alt="Grub 开机启动菜单"><br>正常情况下是选第一项的，但是现在系统挂了，我们想用以前的内核启动，选第二项：<code>Advanced options for Ubuntu Kylin GUN/Linux</code></li>
<li><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2014.04%20%E5%8D%87%E7%BA%A7%E5%90%8E%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E5%A4%B1%E7%81%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%8802.jpg" alt="Grub 启动内核版本选择"><br>内核版本从上到下版本号一次递减，选正常模式，一般选倒数第二新的版本即可，如果不行，那就再选更旧的版本。家里的电脑是升级到<code>-68</code>代号的内核出问题的，后来在台式机上选倒数第二新的内核就可以进去了，记住不要选<code>recovery mode</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 多终端窗口合并</title>
    <url>/2015/10/14/Ubuntu-14-04-%E5%A4%9A%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>最近刚接触数据处理，线上的服务器有大概10台，并且<code>hadoop</code>和<code>Hive</code>的数据非常多，有些数据需要迁移，首先要登陆跳板机，然后跳板机再登陆线上的机器，这样切换非常麻烦，多个终端窗口切换非常乱，所以找了一下如何使用一款多窗口终端软件</p>
<h3 id="Terminator-终结者"><a href="#Terminator-终结者" class="headerlink" title="Terminator(终结者)"></a>Terminator(终结者)</h3><h4 id="终端安装"><a href="#终端安装" class="headerlink" title="终端安装"></a>终端安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install terminator</span><br><span class="line">cd ~/.config/</span><br><span class="line">sudo mkdir terminator</span><br><span class="line">cd terminator</span><br><span class="line">sudo touch config</span><br></pre></td></tr></table></figure>
<p>安装完了之后，打开一个窗口，类似于下面：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu%2014.04%20%E5%A4%9A%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3%E5%90%88%E5%B9%B601.png" alt="Terminator 窗口"></p>
<h4 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h4><p>下面配置一下这个终端的颜色，我使用<code>solarized</code>配色,修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo subl ~/.config/terminator/config</span><br></pre></td></tr></table></figure>
<p><code>subl</code>是<code>Sublime Text 3</code>编辑器，用你有的工具修改即可，把文件内容替换成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global_config]</span><br><span class="line">  title_transmit_bg_color = &quot;#d30102&quot;</span><br><span class="line">  focus = system</span><br><span class="line">[keybindings]</span><br><span class="line">[profiles]</span><br><span class="line">  [[default]]</span><br><span class="line">    # solarized-dark</span><br><span class="line">    #palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">    #foreground_color = &quot;#eee8d5&quot;</span><br><span class="line">    #background_color = &quot;#002b36&quot;</span><br><span class="line">    #cursor_color = &quot;#eee8d5&quot;</span><br><span class="line"></span><br><span class="line">  [[solarized-dark]]</span><br><span class="line">    palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">    foreground_color = &quot;#eee8d5&quot;</span><br><span class="line">    background_color = &quot;#002b36&quot;</span><br><span class="line">    cursor_color = &quot;#eee8d5&quot;</span><br><span class="line"></span><br><span class="line">  [[solarized-light]]</span><br><span class="line">    palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">    background_color = &quot;#eee8d5&quot;</span><br><span class="line">    foreground_color = &quot;#002b36&quot;</span><br><span class="line">    cursor_color = &quot;#002b36&quot;</span><br><span class="line"></span><br><span class="line">[layouts]</span><br><span class="line">  [[default]]</span><br><span class="line">    [[[child1]]]</span><br><span class="line">      type = Terminal</span><br><span class="line">      parent = window0</span><br><span class="line">      profile = solarized-dark</span><br><span class="line">    [[[window0]]]</span><br><span class="line">      type = Window</span><br><span class="line">      parent = &quot;&quot;</span><br><span class="line">[plugins]</span><br></pre></td></tr></table></figure>
<p>或者还可以直接导入配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br><span class="line">curl https://raw.githubusercontent.com/ghuntley/terminator-solarized/master/config &gt; ~/.config/terminator/config</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 这个配置项目的<a href="https://github.com/ghuntley/terminator-solarized">github 地址</a>有可能会变动，如果不行可以复制我的配置文件内容，按前一种方式修改即可,，我的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global_config]</span><br><span class="line">    title_transmit_bg_color = &quot;#d30102&quot;</span><br><span class="line">    focus = system</span><br><span class="line">    suppress_multiple_term_dialog = True</span><br><span class="line">[keybindings]</span><br><span class="line">[profiles]</span><br><span class="line">    [[default]]</span><br><span class="line">        palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">        copy_on_selection = True</span><br><span class="line">        background_image = None</span><br><span class="line">        background_darkness = 0.95</span><br><span class="line">        background_type = transparent</span><br><span class="line">        use_system_font = False</span><br><span class="line">        cursor_color = &quot;#eee8d5&quot;</span><br><span class="line">        foreground_color = &quot;#839496&quot;</span><br><span class="line">        show_titlebar = False</span><br><span class="line">        font = Monospace 11</span><br><span class="line">        background_color = &quot;#002b36&quot;</span><br><span class="line">    [[solarized-dark]]</span><br><span class="line">        palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">        background_color = &quot;#002b36&quot;</span><br><span class="line">        background_image = None</span><br><span class="line">        cursor_color = &quot;#eee8d5&quot;</span><br><span class="line">        foreground_color = &quot;#839496&quot;</span><br><span class="line">    [[solarized-light]]</span><br><span class="line">        palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot;</span><br><span class="line">        background_color = &quot;#fdf6e3&quot;</span><br><span class="line">        background_image = None</span><br><span class="line">        cursor_color = &quot;#002b36&quot;</span><br><span class="line">        foreground_color = &quot;#657b83&quot;</span><br><span class="line">[layouts]</span><br><span class="line">    [[default]]</span><br><span class="line">        [[[child1]]]</span><br><span class="line">            type = Terminal</span><br><span class="line">            parent = window0</span><br><span class="line">            profile = default</span><br><span class="line">        [[[window0]]]</span><br><span class="line">            type = Window</span><br><span class="line">            parent = &quot;&quot;</span><br><span class="line">[plugins]</span><br></pre></td></tr></table></figure>

<h4 id="更换目录配色方案"><a href="#更换目录配色方案" class="headerlink" title="更换目录配色方案"></a>更换目录配色方案</h4><p>不过这个主题在文件和文件夹的颜色上区分不明显，都是灰色的，配置目录的颜色,修改目录配色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/seebi/dircolors-solarized/master/dircolors.ansi-dark &gt; ~/.dircolors</span><br></pre></td></tr></table></figure>
<p>吐过下载不下来,同样可以自己建一个文件叫<code>.dircolors</code>,内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Below, there should be one TERM entry for each termtype that is colorizable</span><br><span class="line">TERM ansi</span><br><span class="line">TERM color_xterm</span><br><span class="line">TERM color-xterm</span><br><span class="line">TERM con132x25</span><br><span class="line">TERM con132x30</span><br><span class="line">TERM con132x43</span><br><span class="line">TERM con132x60</span><br><span class="line">TERM con80x25</span><br><span class="line">TERM con80x28</span><br><span class="line">TERM con80x30</span><br><span class="line">TERM con80x43</span><br><span class="line">TERM con80x50</span><br><span class="line">TERM con80x60</span><br><span class="line">TERM cons25</span><br><span class="line">TERM console</span><br><span class="line">TERM cygwin</span><br><span class="line">TERM dtterm</span><br><span class="line">TERM dvtm</span><br><span class="line">TERM dvtm-256color</span><br><span class="line">TERM Eterm</span><br><span class="line">TERM eterm-color</span><br><span class="line">TERM fbterm</span><br><span class="line">TERM gnome</span><br><span class="line">TERM gnome-256color</span><br><span class="line">TERM jfbterm</span><br><span class="line">TERM konsole</span><br><span class="line">TERM konsole-256color</span><br><span class="line">TERM kterm</span><br><span class="line">TERM linux</span><br><span class="line">TERM linux-c</span><br><span class="line">TERM mach-color</span><br><span class="line">TERM mlterm</span><br><span class="line">TERM nxterm</span><br><span class="line">TERM putty</span><br><span class="line">TERM putty-256color</span><br><span class="line">TERM rxvt</span><br><span class="line">TERM rxvt-256color</span><br><span class="line">TERM rxvt-cygwin</span><br><span class="line">TERM rxvt-cygwin-native</span><br><span class="line">TERM rxvt-unicode</span><br><span class="line">TERM rxvt-unicode256</span><br><span class="line">TERM rxvt-unicode-256color</span><br><span class="line">TERM screen</span><br><span class="line">TERM screen-16color</span><br><span class="line">TERM screen-16color-bce</span><br><span class="line">TERM screen-16color-s</span><br><span class="line">TERM screen-16color-bce-s</span><br><span class="line">TERM screen-256color</span><br><span class="line">TERM screen-256color-bce</span><br><span class="line">TERM screen-256color-s</span><br><span class="line">TERM screen-256color-bce-s</span><br><span class="line">TERM screen-256color-italic</span><br><span class="line">TERM screen-bce</span><br><span class="line">TERM screen-w</span><br><span class="line">TERM screen.linux</span><br><span class="line">TERM screen.xterm-256color</span><br><span class="line">TERM screen.xterm-new</span><br><span class="line">TERM st</span><br><span class="line">TERM st-meta</span><br><span class="line">TERM st-256color</span><br><span class="line">TERM st-meta-256color</span><br><span class="line">TERM vt100</span><br><span class="line">TERM xterm</span><br><span class="line">TERM xterm-new</span><br><span class="line">TERM xterm-16color</span><br><span class="line">TERM xterm-256color</span><br><span class="line">TERM xterm-256color-italic</span><br><span class="line">TERM xterm-88color</span><br><span class="line">TERM xterm-color</span><br><span class="line">TERM xterm-debian</span><br><span class="line">TERM xterm-termite</span><br><span class="line"></span><br><span class="line"># EIGHTBIT, followed by &#x27;1&#x27; for on, &#x27;0&#x27; for off. (8-bit output)</span><br><span class="line">EIGHTBIT 1</span><br><span class="line"></span><br><span class="line">#############################################################################</span><br><span class="line"># Below are the color init strings for the basic file types. A color init</span><br><span class="line"># string consists of one or more of the following numeric codes:</span><br><span class="line">#</span><br><span class="line"># Attribute codes:</span><br><span class="line">#   00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed</span><br><span class="line"># Text color codes:</span><br><span class="line">#   30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white</span><br><span class="line"># Background color codes:</span><br><span class="line">#   40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white</span><br><span class="line">#</span><br><span class="line"># NOTES:</span><br><span class="line"># - See http://www.oreilly.com/catalog/wdnut/excerpt/color_names.html</span><br><span class="line"># - Color combinations</span><br><span class="line">#   ANSI Color code       Solarized  Notes                Universal             SolDark              SolLight</span><br><span class="line">#   ~~~~~~~~~~~~~~~       ~~~~~~~~~  ~~~~~                ~~~~~~~~~             ~~~~~~~              ~~~~~~~~</span><br><span class="line">#   00    none                                            NORMAL, FILE          &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   30    black           base02</span><br><span class="line">#   01;30 bright black    base03     bg of SolDark</span><br><span class="line">#   31    red             red                             docs &amp; mm src         &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;31 bright red      orange                          EXEC                  &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   32    green           green                           editable text         &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;32 bright green    base01                          unimportant text      &lt;SAME&gt;</span><br><span class="line">#   33    yellow          yellow     unclear in light bg  multimedia            &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;33 bright yellow   base00     fg of SolLight                             unimportant non-text</span><br><span class="line">#   34    blue            blue       unclear in dark bg   user customized       &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;34 bright blue     base0      fg in SolDark                                                   unimportant text</span><br><span class="line">#   35    magenta         magenta                         LINK                  &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;35 bright magenta  violet                          archive/compressed    &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   36    cyan            cyan                            DIR                   &lt;SAME&gt;               &lt;SAME&gt;</span><br><span class="line">#   01;36 bright cyan     base1                           unimportant non-text                       &lt;SAME&gt;</span><br><span class="line">#   37    white           base2</span><br><span class="line">#   01;37 bright white    base3      bg in SolLight</span><br><span class="line">#   05;37;41                         unclear in Putty dark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### By file type</span><br><span class="line"></span><br><span class="line"># global default</span><br><span class="line">NORMAL 00</span><br><span class="line"># normal file</span><br><span class="line">FILE 00</span><br><span class="line"># directory</span><br><span class="line">DIR 34</span><br><span class="line"># 777 directory</span><br><span class="line">OTHER_WRITABLE 34;40</span><br><span class="line"># symbolic link</span><br><span class="line">LINK 35</span><br><span class="line"></span><br><span class="line"># pipe, socket, block device, character device (blue bg)</span><br><span class="line">FIFO 30;44</span><br><span class="line">SOCK 35;44</span><br><span class="line">DOOR 35;44 # Solaris 2.5 and later</span><br><span class="line">BLK  33;44</span><br><span class="line">CHR  37;44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############################################################################</span><br><span class="line">### By file attributes</span><br><span class="line"></span><br><span class="line"># Orphaned symlinks (blinking white on red)</span><br><span class="line"># Blink may or may not work (works on iTerm dark or light, and Putty dark)</span><br><span class="line">ORPHAN  05;37;41</span><br><span class="line"># ... and the files that orphaned symlinks point to (blinking white on red)</span><br><span class="line">MISSING 05;37;41</span><br><span class="line"></span><br><span class="line"># files with execute permission</span><br><span class="line">EXEC 01;31  # Unix</span><br><span class="line">.cmd 01;31  # Win</span><br><span class="line">.exe 01;31  # Win</span><br><span class="line">.com 01;31  # Win</span><br><span class="line">.bat 01;31  # Win</span><br><span class="line">.reg 01;31  # Win</span><br><span class="line">.app 01;31  # OSX</span><br><span class="line"></span><br><span class="line">#############################################################################</span><br><span class="line">### By extension</span><br><span class="line"></span><br><span class="line"># List any file extensions like &#x27;.gz&#x27; or &#x27;.tar&#x27; that you would like ls</span><br><span class="line"># to colorize below. Put the extension, a space, and the color init string.</span><br><span class="line"># (and any comments you want to add after a &#x27;#&#x27;)</span><br><span class="line"></span><br><span class="line">### Text formats</span><br><span class="line"></span><br><span class="line"># Text that we can edit with a regular editor</span><br><span class="line">.txt 32</span><br><span class="line">.org 32</span><br><span class="line">.md 32</span><br><span class="line">.mkd 32</span><br><span class="line"></span><br><span class="line"># Source text</span><br><span class="line">.h 32</span><br><span class="line">.c 32</span><br><span class="line">.C 32</span><br><span class="line">.cc 32</span><br><span class="line">.cpp 32</span><br><span class="line">.cxx 32</span><br><span class="line">.objc 32</span><br><span class="line">.sh 32</span><br><span class="line">.bash 32</span><br><span class="line">.csh 32</span><br><span class="line">.zsh 32</span><br><span class="line">.el 32</span><br><span class="line">.vim 32</span><br><span class="line">.java 32</span><br><span class="line">.pl 32</span><br><span class="line">.pm 32</span><br><span class="line">.py 32</span><br><span class="line">.rb 32</span><br><span class="line">.hs 32</span><br><span class="line">.php 32</span><br><span class="line">.htm 32</span><br><span class="line">.html 32</span><br><span class="line">.shtml 32</span><br><span class="line">.erb 32</span><br><span class="line">.haml 32</span><br><span class="line">.xml 32</span><br><span class="line">.rdf 32</span><br><span class="line">.css 32</span><br><span class="line">.sass 32</span><br><span class="line">.scss 32</span><br><span class="line">.less 32</span><br><span class="line">.js 32</span><br><span class="line">.coffee 32</span><br><span class="line">.man 32</span><br><span class="line">.0 32</span><br><span class="line">.1 32</span><br><span class="line">.2 32</span><br><span class="line">.3 32</span><br><span class="line">.4 32</span><br><span class="line">.5 32</span><br><span class="line">.6 32</span><br><span class="line">.7 32</span><br><span class="line">.8 32</span><br><span class="line">.9 32</span><br><span class="line">.l 32</span><br><span class="line">.n 32</span><br><span class="line">.p 32</span><br><span class="line">.pod 32</span><br><span class="line">.tex 32</span><br><span class="line">.go 32</span><br><span class="line">.sql 32</span><br><span class="line"></span><br><span class="line">### Multimedia formats</span><br><span class="line"></span><br><span class="line"># Image</span><br><span class="line">.bmp 33</span><br><span class="line">.cgm 33</span><br><span class="line">.dl 33</span><br><span class="line">.dvi 33</span><br><span class="line">.emf 33</span><br><span class="line">.eps 33</span><br><span class="line">.gif 33</span><br><span class="line">.jpeg 33</span><br><span class="line">.jpg 33</span><br><span class="line">.JPG 33</span><br><span class="line">.mng 33</span><br><span class="line">.pbm 33</span><br><span class="line">.pcx 33</span><br><span class="line">.pdf 33</span><br><span class="line">.pgm 33</span><br><span class="line">.png 33</span><br><span class="line">.PNG 33</span><br><span class="line">.ppm 33</span><br><span class="line">.pps 33</span><br><span class="line">.ppsx 33</span><br><span class="line">.ps 33</span><br><span class="line">.svg 33</span><br><span class="line">.svgz 33</span><br><span class="line">.tga 33</span><br><span class="line">.tif 33</span><br><span class="line">.tiff 33</span><br><span class="line">.xbm 33</span><br><span class="line">.xcf 33</span><br><span class="line">.xpm 33</span><br><span class="line">.xwd 33</span><br><span class="line">.xwd 33</span><br><span class="line">.yuv 33</span><br><span class="line"></span><br><span class="line"># Audio</span><br><span class="line">.aac 33</span><br><span class="line">.au  33</span><br><span class="line">.flac 33</span><br><span class="line">.m4a 33</span><br><span class="line">.mid 33</span><br><span class="line">.midi 33</span><br><span class="line">.mka 33</span><br><span class="line">.mp3 33</span><br><span class="line">.mpa 33</span><br><span class="line">.mpeg 33</span><br><span class="line">.mpg 33</span><br><span class="line">.ogg  33</span><br><span class="line">.ra 33</span><br><span class="line">.wav 33</span><br><span class="line"></span><br><span class="line"># Video</span><br><span class="line">.anx 33</span><br><span class="line">.asf 33</span><br><span class="line">.avi 33</span><br><span class="line">.axv 33</span><br><span class="line">.flc 33</span><br><span class="line">.fli 33</span><br><span class="line">.flv 33</span><br><span class="line">.gl 33</span><br><span class="line">.m2v 33</span><br><span class="line">.m4v 33</span><br><span class="line">.mkv 33</span><br><span class="line">.mov 33</span><br><span class="line">.MOV 33</span><br><span class="line">.mp4 33</span><br><span class="line">.mp4v 33</span><br><span class="line">.mpeg 33</span><br><span class="line">.mpg 33</span><br><span class="line">.nuv 33</span><br><span class="line">.ogm 33</span><br><span class="line">.ogv 33</span><br><span class="line">.ogx 33</span><br><span class="line">.qt 33</span><br><span class="line">.rm 33</span><br><span class="line">.rmvb 33</span><br><span class="line">.swf 33</span><br><span class="line">.vob 33</span><br><span class="line">.webm 33</span><br><span class="line">.wmv 33</span><br><span class="line"></span><br><span class="line">### Misc</span><br><span class="line"></span><br><span class="line"># Binary document formats and multimedia source</span><br><span class="line">.doc 31</span><br><span class="line">.docx 31</span><br><span class="line">.rtf 31</span><br><span class="line">.odt 31</span><br><span class="line">.dot 31</span><br><span class="line">.dotx 31</span><br><span class="line">.ott 31</span><br><span class="line">.xls 31</span><br><span class="line">.xlsx 31</span><br><span class="line">.ods 31</span><br><span class="line">.ots 31</span><br><span class="line">.ppt 31</span><br><span class="line">.pptx 31</span><br><span class="line">.odp 31</span><br><span class="line">.otp 31</span><br><span class="line">.fla 31</span><br><span class="line">.psd 31</span><br><span class="line"></span><br><span class="line"># Archives, compressed</span><br><span class="line">.7z   1;35</span><br><span class="line">.apk  1;35</span><br><span class="line">.arj  1;35</span><br><span class="line">.bin  1;35</span><br><span class="line">.bz   1;35</span><br><span class="line">.bz2  1;35</span><br><span class="line">.cab  1;35  # Win</span><br><span class="line">.deb  1;35</span><br><span class="line">.dmg  1;35  # OSX</span><br><span class="line">.gem  1;35</span><br><span class="line">.gz   1;35</span><br><span class="line">.iso  1;35</span><br><span class="line">.jar  1;35</span><br><span class="line">.msi  1;35  # Win</span><br><span class="line">.rar  1;35</span><br><span class="line">.rpm  1;35</span><br><span class="line">.tar  1;35</span><br><span class="line">.tbz  1;35</span><br><span class="line">.tbz2 1;35</span><br><span class="line">.tgz  1;35</span><br><span class="line">.tx   1;35</span><br><span class="line">.war  1;35</span><br><span class="line">.xpi  1;35</span><br><span class="line">.xz   1;35</span><br><span class="line">.z    1;35</span><br><span class="line">.Z    1;35</span><br><span class="line">.zip  1;35</span><br><span class="line"></span><br><span class="line"># For testing</span><br><span class="line">.ANSI-30-black 30</span><br><span class="line">.ANSI-01;30-brblack 01;30</span><br><span class="line">.ANSI-31-red 31</span><br><span class="line">.ANSI-01;31-brred 01;31</span><br><span class="line">.ANSI-32-green 32</span><br><span class="line">.ANSI-01;32-brgreen 01;32</span><br><span class="line">.ANSI-33-yellow 33</span><br><span class="line">.ANSI-01;33-bryellow 01;33</span><br><span class="line">.ANSI-34-blue 34</span><br><span class="line">.ANSI-01;34-brblue 01;34</span><br><span class="line">.ANSI-35-magenta 35</span><br><span class="line">.ANSI-01;35-brmagenta 01;35</span><br><span class="line">.ANSI-36-cyan 36</span><br><span class="line">.ANSI-01;36-brcyan 01;36</span><br><span class="line">.ANSI-37-white 37</span><br><span class="line">.ANSI-01;37-brwhite 01;37</span><br><span class="line"></span><br><span class="line">#############################################################################</span><br><span class="line"># Your customizations</span><br><span class="line"></span><br><span class="line"># Unimportant text files</span><br><span class="line"># For universal scheme, use brightgreen 01;32</span><br><span class="line"># For optimal on light bg (but too prominent on dark bg), use white 01;34</span><br><span class="line">.log 01;32</span><br><span class="line">*~ 01;32</span><br><span class="line">*# 01;32</span><br><span class="line">#.log 01;34</span><br><span class="line">#*~ 01;34</span><br><span class="line">#*# 01;34</span><br><span class="line"></span><br><span class="line"># Unimportant non-text files</span><br><span class="line"># For universal scheme, use brightcyan 01;36</span><br><span class="line"># For optimal on dark bg (but too prominent on light bg), change to 01;33</span><br><span class="line">#.bak 01;36</span><br><span class="line">#.BAK 01;36</span><br><span class="line">#.old 01;36</span><br><span class="line">#.OLD 01;36</span><br><span class="line">#.org_archive 01;36</span><br><span class="line">#.off 01;36</span><br><span class="line">#.OFF 01;36</span><br><span class="line">#.dist 01;36</span><br><span class="line">#.DIST 01;36</span><br><span class="line">#.orig 01;36</span><br><span class="line">#.ORIG 01;36</span><br><span class="line">#.swp 01;36</span><br><span class="line">#.swo 01;36</span><br><span class="line">#*,v 01;36</span><br><span class="line">.bak 01;33</span><br><span class="line">.BAK 01;33</span><br><span class="line">.old 01;33</span><br><span class="line">.OLD 01;33</span><br><span class="line">.org_archive 01;33</span><br><span class="line">.off 01;33</span><br><span class="line">.OFF 01;33</span><br><span class="line">.dist 01;33</span><br><span class="line">.DIST 01;33</span><br><span class="line">.orig 01;33</span><br><span class="line">.ORIG 01;33</span><br><span class="line">.swp 01;33</span><br><span class="line">.swo 01;33</span><br><span class="line">*,v 01;33</span><br><span class="line"></span><br><span class="line"># The brightmagenta (Solarized: purple) color is free for you to use for your</span><br><span class="line"># custom file type</span><br><span class="line">.gpg 34</span><br><span class="line">.gpg 34</span><br><span class="line">.pgp 34</span><br><span class="line">.asc 34</span><br><span class="line">.3des 34</span><br><span class="line">.aes 34</span><br><span class="line">.enc 34</span><br><span class="line">.sqlite 34</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改<code>~/.bashrc</code>配置，我安装了<code>oh-my-zsh</code>，所以我修改的文件是<code>~/.zshrc</code>。加入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable color support of ls and also add handy aliases</span></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b)</span>&quot;</span></span><br><span class="line">    <span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias dir=&#x27;dir --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># some more ls aliases</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/seebi/dircolors-solarized">dircolors-solarized github地址</a>最后效果如下：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu%2014.04%20%E5%A4%9A%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3%E5%90%88%E5%B9%B602.png" alt="dircolors-solarized配色"></p>
<h4 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h4><p>在终端上的某个终端窗口右键，就可以<code>Split Horizontally</code>以及<code>Split Vertically</code>进行屏幕分割，这个操作可以类推，效果类似于：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu%2014.04%20%E5%A4%9A%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3%E5%90%88%E5%B9%B603.png" alt="最终分屏效果"></p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 安装Python Mysqldb</title>
    <url>/2015/10/14/Ubuntu-14-04-%E5%AE%89%E8%A3%85Python-Mysqldb/</url>
    <content><![CDATA[<p>使用Python连接数据库，需要安装<code>MySQLdb</code>模块。</p>
<blockquote>
<p>系统：Ubuntu 14.04 64bit<br>mysql:Server version: 5.5.44-0ubuntu0.14.04.1 (Ubuntu)</p>
</blockquote>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 安装git</title>
    <url>/2015/10/25/Ubuntu-14-04-%E5%AE%89%E8%A3%85git/</url>
    <content><![CDATA[<p>首先测试一下电脑安装git没有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>没有安装按照以下步骤来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core git-gui git-doc gitk</span><br></pre></td></tr></table></figure>
<p>安装完毕看看是否安装成功，如果安装成功的版本低于1.9.5则说明Ubuntu版本太低，进行如下操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>安装成功之后再次测试，版本就应该是比较高了。</p>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>基本配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;zhang.san&quot;</span>             <span class="comment"># 请换成你自己的名字，除非你凑巧也叫zhang.san</span></span><br><span class="line">git config --global user.email <span class="string">&quot;zhang.san@163.com&quot;</span>    <span class="comment"># 同上</span></span><br><span class="line">git config --global merge.tool <span class="string">&quot;kdiff3&quot;</span>               <span class="comment"># 要是没装KDiff3就不用设这一行</span></span><br><span class="line">git config --global push.default simple               <span class="comment"># 要是你非要用低版本的Git（比如1.7.x），好吧，那就不设simple设current，否则你的Git不支持</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span>               <span class="comment"># 让Git不要管Windows/Unix换行符转换的事</span></span><br><span class="line">git config --global gui.encoding utf-8                <span class="comment"># 避免git gui中的中文乱码</span></span><br><span class="line">git config --global core.quotepath off                <span class="comment"># 避免git status显示的中文文件名乱码</span></span><br></pre></td></tr></table></figure>
<p>如果你不习惯使用<code>Vim</code>,可以修改git默认的编辑器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editor nano</span><br></pre></td></tr></table></figure>

<h3 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h3><p>要和git服务器打交道，还要设置ssh，如果你之前已经有则不需要再次生成,命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;zhang.san@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后一路回车，不要输入任何密码之类，生成ssh key pair。如果在Linux上，需要把其中的私钥告诉本地系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>查看公钥内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>最后把公钥的内容复制到git服务器上，以github为例<br>登陆github，在<code>Settings--&gt;SSH keys--&gt; Add SSH key</code>,把公钥的内容复制到key里面，title不用管。(windows下的用户目录找到.ssh文件夹进去就可以看到)的内容paste进去。不需要填title，title会自动生成。<br>要是Git服务器报“不是有效的key”之类的错误，可能是你没去除注意去除多余的回车符，也可能是paste之前copy的时候，没copy最开头的ssh-rsa这几个字。<br>测试一下成功了没</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Warning: Permanently added the RSA host key <span class="keyword">for</span> IP address <span class="string">&#x27;192.30.252.129&#x27;</span> to the list of known hosts.</span><br><span class="line">Hi zhang.san! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 设置wifi热点</title>
    <url>/2015/10/07/Ubuntu-14-04-%E8%AE%BE%E7%BD%AEwifi%E7%83%AD%E7%82%B9/</url>
    <content><![CDATA[<p>查了一下资料主要有两种方法:</p>
<h3 id="第一种-network-manager设置"><a href="#第一种-network-manager设置" class="headerlink" title="第一种:network manager设置"></a>第一种:network manager设置</h3><p>这种方法配置比较复杂.并且不能给<code>Android</code>手机和<code>iPhone</code>共享.果断放弃(其实我是尝试过的,真的没有用).</p>
<h3 id="第二种-使用ap-hotspot-亲测可用"><a href="#第二种-使用ap-hotspot-亲测可用" class="headerlink" title="第二种:使用ap-hotspot,亲测可用"></a>第二种:使用ap-hotspot,亲测可用</h3><p>这种方法配置简单,用起来也方便。</p>
<h4 id="第一步-安装ap-hotspot"><a href="#第一步-安装ap-hotspot" class="headerlink" title="第一步:安装ap-hotspot"></a>第一步:安装ap-hotspot</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:nilarimogard/webupd8</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install hostapd</span><br><span class="line">$ sudo apt-get install ap-hotspot</span><br></pre></td></tr></table></figure>

<h4 id="第二步-配置ap-hotspot"><a href="#第二步-配置ap-hotspot" class="headerlink" title="第二步:配置ap-hotspot"></a>第二步:配置ap-hotspot</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ap-hotspot configure</span><br><span class="line">Detecting configuration...</span><br><span class="line">Detected eth0 as the network interface connected to the Internet. Press ENTER <span class="keyword">if</span> this is correct or enter the desired interface below (e.g.- eth0, ppp0 etc.):</span><br><span class="line"><span class="comment"># 确认eth0作为连接网络的网卡(有多个有线网卡可能不同，自己选择)，一般就默认回车确认选择</span></span><br><span class="line">Detected wlan0 as your WiFi interface. Press ENTER <span class="keyword">if</span> this is correct or enter the desired interface (e.g.- wlan1):</span><br><span class="line"><span class="comment"># 确认wlan0作为发射wifi信号的网卡，一般就默认回车确认选择</span></span><br><span class="line">Enter the desired Access Point name or press ENTER to use the default one (myhotspot):</span><br><span class="line"><span class="comment"># 输入你想建的wifi的名字</span></span><br><span class="line">Enter the desired WPA Passphrase below or press ENTER to use the default one (qwerty0987):</span><br><span class="line"><span class="comment">#输入wifi的密码</span></span><br></pre></td></tr></table></figure>

<h4 id="第三步-启动wifi"><a href="#第三步-启动wifi" class="headerlink" title="第三步:启动wifi"></a>第三步:启动wifi</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ap-hotspot start</span><br><span class="line">Starting Wireless Hotspot...</span><br><span class="line">Wireless Hotspot active</span><br></pre></td></tr></table></figure>
<p>正常情况下，<code>Ubuntu 14.04</code>是会一直在<code>Starting Wireless Hotspot...</code>状态的，即新建<code>wifi</code>失败，失败解决方案有下面两种，第一个不行换第二个。</p>
<h3 id="第一次配置无法启动解决方案"><a href="#第一次配置无法启动解决方案" class="headerlink" title="第一次配置无法启动解决方案"></a>第一次配置无法启动解决方案</h3><ul>
<li>无法出现<code>Wireless Hotspot active</code>，并一直保持<code>Starting Wireless Hotspot...</code></li>
</ul>
<p><code>hostapd</code>默认版本有bug<br>解决方法：移除hostapd:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove hostapd</span><br></pre></td></tr></table></figure>

<p>然后</p>
<ul>
<li>64 bit</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp wget http://archive.ubuntu.com/ubuntu/pool/universe/w/wpa/hostapd_2.1-0ubuntu1.3_amd64.deb</span><br><span class="line">sudo dpkg -i hostapd*.deb </span><br><span class="line">sudo apt-mark hold hostapd</span><br></pre></td></tr></table></figure>
<ul>
<li>32bit：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp wget http://archive.ubuntu.com/ubuntu/pool/universe/w/wpa/hostapd_2.1-0ubuntu1.3_i386.deb</span><br><span class="line">sudo dpkg -i hostapd*.deb </span><br><span class="line">sudo apt-mark hold hostapd</span><br></pre></td></tr></table></figure>
<p> 之后需要重新安装ap-hotspot.<br>如果下载包一直404 not found就去找这里找<a href="http://archive.ubuntu.com/ubuntu/pool/universe/w/wpa/">2.x的deb包下载地址</a></p>
<ul>
<li><p>下载了2.x的包还是不行，直接去Ubuntu官网<a href="http://old-releases.ubuntu.com/ubuntu/pool/universe/w/wpa/hostapd_1.0-3ubuntu2.1_amd64.deb">Ubuntu官网1.0版本下载</a></p>
</li>
<li><p>重新安装第二次启动出现问题</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">出现如下问题：</span><br><span class="line">$ sudo ap-hotspot start</span><br><span class="line">Another process is already running</span><br><span class="line">$ sudo ap-hotspot stop</span><br><span class="line">Wireless Hotspot is not active</span><br></pre></td></tr></table></figure>
<p>解决办法：<code>sudo rm /tmp/hotspot.pid</code></p>
<p>**NOTE:**另外附上几个常用的命令选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:    ap-hotspot [argument]</span><br><span class="line"></span><br><span class="line">    start          start wireless hotspot        // 打开wifi</span><br><span class="line">    stop           stop wireless hotspot         // 停止wifi</span><br><span class="line">    restart        restart wireless hotspot      // 重启wifi</span><br><span class="line">    configure      configure hotspot             // 配置wifi</span><br><span class="line">    debug          start with detailed messages  // dubug模式打开wifi,会显示一些详细的信息</span><br></pre></td></tr></table></figure>

<h3 id="隐藏SSID"><a href="#隐藏SSID" class="headerlink" title="隐藏SSID"></a>隐藏SSID</h3><p>上面讲了这么多,比较复杂,而且这个建的热点还不能隐藏,下面介绍一个比较简单的另一个工具,<code>create_ap</code>项目的github地址:<a href="https://github.com/oblique/create_ap#start-service-immediately">oblique&#x2F;create_ap</a><br>比较强大,主要是看中了他无线可以隐藏的功能,因为公司不让私自建wifi.</p>
<h4 id="安装create-ap"><a href="#安装create-ap" class="headerlink" title="安装create_ap"></a>安装create_ap</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oblique/create_ap</span><br><span class="line"><span class="built_in">cd</span> create_ap</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="create-ap使用"><a href="#create-ap使用" class="headerlink" title="create_ap使用"></a>create_ap使用</h4><ol>
<li>无密码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_ap wlan0 eth0 MyAccessPoint</span><br></pre></td></tr></table></figure></li>
<li>WPA + WPA2加密<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_ap wlan0 eth0 MyAccessPoint MyPassPhrase</span><br></pre></td></tr></table></figure></li>
<li>创建隐藏wifi<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_ap --hidden wlan0 eth0 MyAccessPoint MyPassPhrase</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 安装vim-gnome失败解决办法</title>
    <url>/2015/11/15/Ubuntu-14-04-%E5%AE%89%E8%A3%85vim-gnome%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>每次想拷贝Vim里的内容到其他地方,开始都是用鼠标的,但是后来发现,如果要复制大片内容,终端里没有显示出来就没辙了,所以网上搜了怎么把Vim里的内容复制到剪贴板.<br>网上搜了一下如何把Vim里的内容复制到系统剪贴板,大部分都是建议安装<code>vim-gnome</code>这个插件,仅针对于<code>Ubuntu</code>桌面环境,其他的我没有测试过:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<p>结果报错了,报错信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some packages could not be installed. This may mean that you have</span><br><span class="line">requested an impossible situation or if you are using the unstable</span><br><span class="line">distribution that some required packages have not yet been created</span><br><span class="line">or been moved out of Incoming.</span><br><span class="line">The following information may help to resolve the situation:</span><br><span class="line"></span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> vim-gnome : Depends: vim-gui-common (= 2:7.4.052-1ubuntu3) but it is not going to be installed</span><br><span class="line">             Depends: vim-common (= 2:7.4.052-1ubuntu3) but 2:7.4.826-1 is to be installed</span><br><span class="line">             Depends: vim-runtime (= 2:7.4.052-1ubuntu3) but 2:7.4.826-1 is to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure>
<p>看上面的意思是这个插件依赖的几个库没有安装,手动安装一下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-gui-common</span><br></pre></td></tr></table></figure>
<p>然后再试试可不可以安装<code>vim-gnome</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<p>果不其然又报错了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> vim-gnome : Depends: vim-runtime (= 2:7.4.052-1ubuntu3) but 2:7.4.826-1 is to be installed</span><br></pre></td></tr></table></figure>
<p>这个意思就是说依赖的<code>vim-runtime</code>是一个老的版本,但是安装的是一个更加新的版本.那我们来手动装一下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-runtime</span><br></pre></td></tr></table></figure>
<p>看看提示信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim-runtime is already the newest version.</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  g++-4.8 libstdc++-4.8-dev linux-headers-3.13.0-32</span><br><span class="line">  linux-headers-3.13.0-32-generic linux-image-3.13.0-32-generic</span><br><span class="line">  linux-image-extra-3.13.0-32-generic</span><br><span class="line">Use &#x27;apt-get autoremove&#x27; to remove them.</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 16 not upgraded.</span><br></pre></td></tr></table></figure>
<p>好了,找到问题的关键所在了,我之前升级了<code>gcc 4.9.2</code>,我们需要把这些老的包移除掉,不要漏掉了,也可以逐一卸载:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove g++-4.8 libstdc++-4.8-dev linux-headers-3.13.0-32 linux-headers-3.13.0-32-generic linux-image-extra-3.13.0-32-generic</span><br></pre></td></tr></table></figure>
<p>然后强制安装一下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-runtime</span><br></pre></td></tr></table></figure>
<p>好了,然后在Vim里的非<code>INSERT</code>模式下使用<code>&quot;+y</code>就可以把Vim里的内容复制到系统剪贴板了,注意记得重启Vim才能生效.</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 更改源</title>
    <url>/2015/10/25/Ubuntu-14-04-%E6%9B%B4%E6%94%B9%E6%BA%90/</url>
    <content><![CDATA[<p>之前把Ubuntu的默认的源替换了，速度有点慢，现在替换回来<br>在命令行下修改，修改<code>/etc/apt/sources.list</code>,内容修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deb cdrom:[Ubuntu-Kylin 14.04.1 LTS _Trusty Tahr_ - Release amd64 (20140722.1)]/ trusty main multiverse restricted universe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span></span><br><span class="line"><span class="comment"># newer versions of the distribution.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted</span><br><span class="line"></span><br><span class="line"><span class="comment">## Major bug fix updates produced after the final release of the</span></span><br><span class="line"><span class="comment">## distribution.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted</span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team. Also, please note that software in universe WILL NOT receive any</span></span><br><span class="line"><span class="comment">## review or updates from the Ubuntu security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty universe</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universe</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universe</span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu </span></span><br><span class="line"><span class="comment">## team, and may not be under a free licence. Please satisfy yourself as to </span></span><br><span class="line"><span class="comment">## your rights to use the software. Also, please note that software in </span></span><br><span class="line"><span class="comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span></span><br><span class="line"><span class="comment">## security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository may not have been tested as</span></span><br><span class="line"><span class="comment">## extensively as that contained in the main release, although it includes</span></span><br><span class="line"><span class="comment">## newer versions of some applications which may provide useful features.</span></span><br><span class="line"><span class="comment">## Also, please note that software in backports WILL NOT receive any review</span></span><br><span class="line"><span class="comment">## or updates from the Ubuntu security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu trusty-security main restricted</span><br><span class="line">deb-src http://security.ubuntu.com/ubuntu trusty-security main restricted</span><br><span class="line">deb http://security.ubuntu.com/ubuntu trusty-security universe</span><br><span class="line">deb-src http://security.ubuntu.com/ubuntu trusty-security universe</span><br><span class="line">deb http://security.ubuntu.com/ubuntu trusty-security multiverse</span><br><span class="line">deb-src http://security.ubuntu.com/ubuntu trusty-security multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">## Uncomment the following two lines to add software from Canonical&#x27;s</span></span><br><span class="line"><span class="comment">## &#x27;partner&#x27; repository.</span></span><br><span class="line"><span class="comment">## This software is not part of Ubuntu, but is offered by Canonical and the</span></span><br><span class="line"><span class="comment">## respective vendors as a service to Ubuntu users.</span></span><br><span class="line"><span class="comment"># deb http://archive.canonical.com/ubuntu trusty partner</span></span><br><span class="line"><span class="comment"># deb-src http://archive.canonical.com/ubuntu trusty partner</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Uncomment the following two lines to add software from Ubuntu&#x27;s</span></span><br><span class="line"><span class="comment">## &#x27;extras&#x27; repository.</span></span><br><span class="line"><span class="comment">## This software is not part of Ubuntu, but is offered by third-party</span></span><br><span class="line"><span class="comment">## developers who want to ship their latest software.</span></span><br><span class="line"><span class="comment"># deb http://extras.ubuntu.com/ubuntu trusty main</span></span><br><span class="line"><span class="comment"># deb-src http://extras.ubuntu.com/ubuntu trusty main</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 配置JDK</title>
    <url>/2015/10/06/Ubuntu-14-04-%E9%85%8D%E7%BD%AEJDK/</url>
    <content><![CDATA[<h3 id="Ubuntu-14-04-安装jdk"><a href="#Ubuntu-14-04-安装jdk" class="headerlink" title="Ubuntu 14.04 安装jdk"></a>Ubuntu 14.04 安装<code>jdk</code></h3><p>根据自己的系统下载对应的压缩包，我的是<code>Ubuntu 14.04</code>，需要下载的是<code>jdk-7u40-linux-x64.tar.gz</code>。具体地址去<code>oracle</code>官网。</p>
<ul>
<li>解压压缩包：</li>
</ul>
<blockquote>
<p>tar -xvf jdk-7u40-linux-x64.tar.gz</p>
</blockquote>
<p>新建一个目录，将解压的文件移动到该目录中</p>
<blockquote>
<p>mkdir &#x2F;usr&#x2F;java<br>sudo cp -a jdk1.7.0_40&#x2F; &#x2F;usr&#x2F;java&#x2F;</p>
</blockquote>
<p>进入vi编辑器，编辑环境变量</p>
<blockquote>
<p>vi ~&#x2F;.bashrc</p>
</blockquote>
<p>**NOTE:**如果你还装了其他的<code>shell</code>，比如我装的是<code>oh-my-zsh</code>，那么需要修改对应的文件而不再是<code>.bashrc</code>，而是<code>.zshrc</code>。</p>
<p>在最后加入以下内容</p>
<blockquote>
<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_40<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p>
</blockquote>
<p><strong>注意：</strong> 等号之间不要有空格，否则会出错<br>最后还需要更新一下</p>
<blockquote>
<p>source ~&#x2F;.bashrc</p>
</blockquote>
<p>好了，在终端中可以测试一下jdk是否安装成功了</p>
<blockquote>
<p>java -version</p>
</blockquote>
<p>输出结果为</p>
<blockquote>
<p>java version “1.7.0_40”<br>Java(TM) SE Runtime Environment (build 1.7.0_40-b43)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.0-b56, mixed mode)</p>
</blockquote>
<p>至此，<code>jdk</code>就安装好了。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>开发环境</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 Hadoop本地安装配置</title>
    <url>/2016/07/19/Ubuntu-16-04-Hadoop%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>线上集群测试太慢，有时候需要在本地跑一些计算或者测试某个逻辑，主要做调试用，所以在本地也装一个Hive测试用,但是装Hive需要先安装Hadoop.</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>开发环境为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04 LTS 64bit</span><br><span class="line">JDK: 1.7.0_40</span><br><span class="line">ssh server:1:7.2p2-4ubuntu1</span><br><span class="line">Hadoop:hadoop-2.6.4.tar.gz</span><br><span class="line">➜  Blog git:(master) ✗ whoami </span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure>
<p>**注意:**当前用户为<code>anonymous</code>,下面所有涉及到用户的地方，需要对应修改为你自己的用户名。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>具体的安装步骤可能有些多，具体过程如下:</p>
<h4 id="ssh登陆配置"><a href="#ssh登陆配置" class="headerlink" title="ssh登陆配置"></a>ssh登陆配置</h4><p>先安装ssh server程序:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  sudo apt update</span><br><span class="line">➜  sudo apt install openssh-server -y</span><br><span class="line">➜  ssh localhost</span><br></pre></td></tr></table></figure>
<p>输入密码之后可以登陆则没有问题，然后使用<code>exit</code>命令注销当前用户,直接忽略下面的异常问题，<br>如果第一步出现下面的错误，按照下面的方法解决即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">忽略:1 http://dl.google.com/linux/chrome/deb stable InRelease</span><br><span class="line">获取:2 http://archive.ubuntukylin.com:10006/ubuntukylin xenial InRelease [3,192 B]</span><br><span class="line">命中:3 http://cn.archive.ubuntu.com/ubuntu xenial InRelease</span><br><span class="line">错误:2 http://archive.ubuntukylin.com:10006/ubuntukylin xenial InRelease</span><br><span class="line">  由于没有公钥，无法验证下列签名： NO_PUBKEY 8D5A09DC9B929006</span><br><span class="line">命中:4 http://cn.archive.ubuntu.com/ubuntu xenial-updates InRelease</span><br><span class="line">获取:5 http://cn.archive.ubuntu.com/ubuntu xenial-backports InRelease [92.2 kB]</span><br><span class="line">命中:6 http://security.ubuntu.com/ubuntu xenial-security InRelease</span><br><span class="line">命中:7 http://dl.google.com/linux/chrome/deb stable Release</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">W: GPG 错误：http://archive.ubuntukylin.com:10006/ubuntukylin xenial InRelease: 由于没有公钥&gt;，无法验证下列签名： NO_PUBKEY 8D5A09DC9B929006</span><br><span class="line">E: 仓库 “http://archive.ubuntukylin.com:10006/ubuntukylin xenial InRelease” 没有数字签名。</span><br><span class="line">N: 无法安全地用该源进行更新，所以默认禁用该源。</span><br><span class="line">N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。</span><br></pre></td></tr></table></figure>
<p>需要按如下方案解决,手动添加上面报错的签名<code>8D5A09DC9B929006</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 8D5A09DC9B929006</span><br></pre></td></tr></table></figure>

<h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>每次登陆都需要输密码很不方便，设置免密码登陆,记得注销当前用户<code>exit</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  cd ~/.ssh</span><br><span class="line">➜  sh-keygen -t rsa</span><br><span class="line">➜  cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<p>**注意:**生成密钥的时候一路回车，不要输入任何东西,如果进行到这一步，我们就可以切回原来的系统了，然后使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure>

<h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>这个安装也很简单，解压然后配置环境变量即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf jdk-7u40-linux-x64.tar.gz -C /usr/dev</span><br></pre></td></tr></table></figure>
<p>然后编辑<code>~/.bashrc</code>文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/dev/jdk1.7.0_40</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>然后更新一下文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>测试JDK是否配置正确:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  java -version</span><br><span class="line">java version &quot;1.7.0_40&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_40-b43)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.0-b56, mixed mode)</span><br></pre></td></tr></table></figure>

<h4 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h4><p>确认JDK安装正确之后，下面就可以来安装Hadoop了,进入到压缩包所在目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  sudo tar -xvf hadoop-2.6.4.tar.gz -C /usr/dev/</span><br><span class="line">➜  sudo chown -R anonymous /usr/dev/hadoop-2.6.4/</span><br></pre></td></tr></table></figure>
<p>看看是否正确安装了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  cd /usr/dev/hadoop-2.6.4</span><br><span class="line">➜  ./bin/hadoop version</span><br><span class="line">Hadoop 2.6.4</span><br><span class="line">Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r 5082c73637530b0b7e115f9625ed7fac69f937e6</span><br><span class="line">Compiled by jenkins on 2016-02-12T09:45Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum 8dee2286ecdbbbc930a6c87b65cbc010</span><br><span class="line">This command was run using /usr/dev/hadoop-2.6.4/share/hadoop/common/hadoop-common-2.6.4.jar</span><br></pre></td></tr></table></figure>
<p>可以识别到版本就说明没啥问题了。<br>为了方便以后使用，可以再配置一下环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/dev/hadoop-2.6.4</span><br><span class="line">export PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>**注意:**后面的操作如果没有特殊指明，都是在hadoop的安装目录<code>/usr/dev/hadoop-2.6.4</code>下进行的操作</p>
<h3 id="单机配置"><a href="#单机配置" class="headerlink" title="单机配置"></a>单机配置</h3><p>单机配置比较简单，我们以一个简单的单词统计来看看怎么配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  cd /usr/dev/hadoop-2.6.4</span><br><span class="line">➜  mkdir input</span><br><span class="line">➜  cp etc/hadoop/*.xml input/</span><br><span class="line">➜  ./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.4.jar grep input/ output &#x27;dfs[a-z.]+&#x27;</span><br><span class="line">➜  cat output/*</span><br><span class="line">1       dfsadmin</span><br></pre></td></tr></table></figure>

<h3 id="伪分布式"><a href="#伪分布式" class="headerlink" title="伪分布式"></a>伪分布式</h3><p>伪分布式需要修改两个文件<code>etc/hadoop/core-site.xml</code>以及<code>etc/hadoop/hdfs-site.xml</code>,修改对应位置，改为如下内容:</p>
<ul>
<li>etc&#x2F;hadoop&#x2F;core-site.xml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:/usr/dev/hadoop-2.6.4/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>etc&#x2F;hadoop&#x2F;hdfs-site.xml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:/usr/dev/hadoop-2.6.4/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:/usr/dev/hadoop-2.6.4/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>格式化节点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./bin/hdfs namenode -format</span><br><span class="line">............省略一堆调试信息............</span><br><span class="line">16/07/19 16:23:54 INFO common.Storage: Storage directory /usr/dev/hadoop-2.6.4/tmp/dfs/name has been successfully formatted.</span><br><span class="line">16/07/19 16:23:54 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid &gt;= 0</span><br><span class="line">16/07/19 16:23:54 INFO util.ExitUtil: Exiting with status 0</span><br><span class="line">16/07/19 16:23:54 INFO namenode.NameNode: SHUTDOWN_MSG:</span><br><span class="line">/************************************************************</span><br><span class="line">SHUTDOWN_MSG: Shutting down NameNode at anonymous/127.0.1.1</span><br><span class="line">************************************************************/</span><br></pre></td></tr></table></figure>
<p>**注意:**如果消息最后不是<code>been successfully formatted.</code>以及返回值不是<code>Exiting with status 0</code>则说明执行失败。</p>
<p>开启<code>NameNode</code>和<code>DataNode</code>守护进程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./sbin/start-dfs.sh</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: Error: JAVA_HOME is not set and could not be found.</span><br><span class="line">localhost: Error: JAVA_HOME is not set and could not be found.</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br><span class="line">0.0.0.0: Error: JAVA_HOME is not set and could not be found.</span><br></pre></td></tr></table></figure>
<p>出现这个错误，并不是由于jdk没设置好，不然前面的也不能运行，只好手动修改文件<code>etc/hadoop/hadoop-env.sh</code>，原来的地方是<code>export JAVA_HOME=$&#123;JAVA_HOME&#125;</code>改成<code>~/.bashrc</code>里面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/dev/jdk1.7.0_40</span><br></pre></td></tr></table></figure>
<p>记得要<code>source ~/.bashrc</code>,然后再试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./sbin/start-dfs.sh</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: starting namenode, logging to /usr/dev/hadoop-2.6.4/logs/hadoop-hadoop-namenode-anonymous.out</span><br><span class="line">localhost: starting datanode, logging to /usr/dev/hadoop-2.6.4/logs/hadoop-hadoop-datanode-anonymous.out</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br><span class="line">0.0.0.0: starting secondarynamenode, logging to /usr/dev/hadoop-2.6.4/logs/hadoop-hadoop-secondarynamenode-anonymous.out</span><br></pre></td></tr></table></figure>
<p>看看进程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  jps</span><br><span class="line">19407 SecondaryNameNode</span><br><span class="line">19239 DataNode</span><br><span class="line">19104 NameNode</span><br><span class="line">19574 Jps</span><br></pre></td></tr></table></figure>
<p>**注意:**没有NameNode或者<code>DataNode</code>则<code>NameNode</code>则不对，正常启动之后可以在Web页面<a href="http://localhost:50070/">http://localhost:50070</a>查看:</p>
<h3 id="伪分布式实例"><a href="#伪分布式实例" class="headerlink" title="伪分布式实例"></a>伪分布式实例</h3><p>最开始演示了一个单机模式的单词统计，这里来一个统计hdfs文件统计的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./bin/hdfs dfs -mkdir -p /user/hadoop</span><br><span class="line">➜  ./bin/hdfs dfs -mkdir input</span><br><span class="line">➜  ./bin/hdfs dfs -put etc/hadoop/*.xml input/</span><br><span class="line">➜  ./bin/hdfs dfs -ls input/</span><br><span class="line">Found 8 items</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       4436 2016-07-19 19:37 input/capacity-scheduler.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       1051 2016-07-19 19:37 input/core-site.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       9683 2016-07-19 19:37 input/hadoop-policy.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       1105 2016-07-19 19:37 input/hdfs-site.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup        620 2016-07-19 19:37 input/httpfs-site.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       3523 2016-07-19 19:37 input/kms-acls.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup       5511 2016-07-19 19:37 input/kms-site.xml</span><br><span class="line">-rw-r--r--   1 anonymous supergroup        690 2016-07-19 19:37 input/yarn-site.xml</span><br><span class="line"></span><br><span class="line">➜  ./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.4.jar grep input/ output &#x27;dfs[a-z.]+&#x27;</span><br></pre></td></tr></table></figure>

<p>查看hdfs文件的统计结果可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./bin/hdfs dfs -cat output/*</span><br><span class="line">1	dfsadmin</span><br><span class="line">1	dfs.replication</span><br><span class="line">1	dfs.namenode.name.dir</span><br><span class="line">1	dfs.datanode.data.dir</span><br></pre></td></tr></table></figure>
<p>结果也可以取回本地，当然记得先把本地的文件夹删了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  rm -r output</span><br><span class="line">➜  ./bin/hdfs dfs -get output output</span><br><span class="line">➜  cat output/*</span><br></pre></td></tr></table></figure>

<h3 id="配置Yarn"><a href="#配置Yarn" class="headerlink" title="配置Yarn"></a>配置Yarn</h3><p>有时候我们还需要一个任务或资源的调度器，当然如果是本地的任务，这个功能其实没啥用，反而会是任务运行变慢，这里仅当学习使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure>
<p>编辑下面两个文件<code>etc/hadoop/mapred-site.xml</code>，<code>etc/hadoop/yarn-site.xml</code>:</p>
<ul>
<li>etc&#x2F;hadoop&#x2F;mapred-site.xml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>etc&#x2F;hadoop&#x2F;yarn-site.xml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>启动资源管理器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./sbin/start-yarn.sh</span><br><span class="line">➜  ./sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>集群资源管理器的访问地址为:<a href="http://localhost:8088/cluster">http://localhost:8088/cluster</a>,另外第二条命令是为了看历史任务的。</p>
<p>关闭资源你管理器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ./sbin/stop-yarn.sh</span><br><span class="line">➜  ./sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04 配置maven</title>
    <url>/2015/10/06/Ubuntu-14-04-%E9%85%8D%E7%BD%AEmaven/</url>
    <content><![CDATA[<h3 id="首先下载maven"><a href="#首先下载maven" class="headerlink" title="首先下载maven"></a>首先下载maven</h3><ul>
<li><p>去官网下载压缩包<code>apache-maven-3.0.5-bin.tar.gz</code>，<a href="http://maven.apache.org/download.cgi">apache-maven官网下载页面</a></p>
</li>
<li><p>解压压缩包</p>
</li>
</ul>
<blockquote>
<p>tar -xvzf apache-maven-3.0.5-bin.tar.gz</p>
</blockquote>
<p>把压缩包就放在当前解压目录，或者放到制定目录</p>
<blockquote>
<p>cp -r apache-maven-3.0.5 &#x2F;usr&#x2F;xxx&#x2F;</p>
</blockquote>
<p>现在已经创建好了一个<code>Maven</code>安装目录<code>apache-maven-3.0.5</code>，虽然直接使用该目录配置环境变量之后就能使用<code>Maven</code>了，但推荐做法是，在安装目录旁平行地创建一个符号链接，以方便日后的升级：</p>
<blockquote>
<p>sudo ln -s apache-maven-3.0.5 apache-maven</p>
</blockquote>
<p>查看一下是否成功<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_Ubuntu%E9%85%8D%E7%BD%AEmaven01.png" alt="查看链接是否创建"></p>
<ul>
<li>编辑环境变量</li>
</ul>
<blockquote>
<p>vi ~&#x2F;.bashrc</p>
</blockquote>
<p>在文件末尾加入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> M2_HOME=/usr/xxx/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;M2_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure>

<p>更新一下文件，然后再测试是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">​➜  xxx <span class="built_in">source</span> ~/.bashrc</span><br><span class="line">➜  xxx mvn -v</span><br><span class="line">Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 21:51:28+0800)</span><br><span class="line">Maven home: /usr/xxx/apache-maven</span><br><span class="line">Java version: 1.7.0_40, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/xxx/jdk1.7.0_40/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: <span class="string">&quot;linux&quot;</span>, version: <span class="string">&quot;3.13.0-32-generic&quot;</span>, <span class="built_in">arch</span>: <span class="string">&quot;amd64&quot;</span>, family: <span class="string">&quot;unix&quot;</span></span><br></pre></td></tr></table></figure>

<p>在用户目录<code>~/.m2</code>目录下，添加<code>settings.xml</code>，内容如下：<br>其中最关键的看第29行和第44行，定义了两个仓库，分别是jar包仓库和插件仓库，这样在公司内网下载jar包就非常快</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>g2Dki6XCfhi48Bnj<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>&#123;username&#125;<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>&#123;yourpwd&#125;<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xxxNexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.xxx.xxx.com:8081/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- always , daily (default), interval:X (where X is </span></span><br><span class="line"><span class="comment">                            an integer in minutes) or never.--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xxxNexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.xxx.xxx.com:8081/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>local<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>开发环境</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 Hbase 本地安装配置</title>
    <url>/2016/10/09/Ubuntu-16-04-Hbase-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>单机安装OLAP Kylin多维数据分析工具,Kylin依赖<code>Hadoop</code>,<code>Hive</code>,<code>Hbase</code>这三个，之前安装过前面两个，所以只用装一个Hbase就可以了，也是单机&#x2F;伪分布式这种模式</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04 LTS 64bit</span><br><span class="line">JDK: 1.7.0_40</span><br><span class="line">Hadoop:hadoop-2.6.4</span><br><span class="line">➜  Blog git:(master) ✗ whoami </span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure>

<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>首先去官网<a href="http://apache.fayea.com/hbase/stable/">Hbase下载地址</a>，可以下载编译好的<code>hbase-1.2.3-bin.tar.gz</code>,也可以下载源码自己编译，我下载源码版<code>hbase-1.2.3-src.tar.gz</code>自己编译的,其他的应该都一样,下载之后解压编译:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf hbase-1.2.3-src.tar.gz -C /usr/dev</span><br><span class="line">cd /user/dev/hbase-1.2.3</span><br><span class="line">mvn package -Dmaven.test.skip=true	# 跳过单元测试，不然测试时间会非常长</span><br></pre></td></tr></table></figure>

<p>配置hbase,当前目录默认是<code>/usr/dev/hbase-1.2.3</code>.</p>
<h4 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h4><p>先编辑<code>conf/hbase-site.xml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">    //这里设置让HBase存储文件的地方</span><br><span class="line">    &lt;value&gt;file:///tmp/hbase&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">    //这里设置让HBase存储内建zookeeper文件的地方</span><br><span class="line">    &lt;value&gt;/tmp/zookeeper&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>然后启动hbase:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/start-hbase.sh</span><br></pre></td></tr></table></figure>
<p>看看是否成功启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hbase-1.2.3 jps</span><br><span class="line">22228 Jps</span><br><span class="line">2738 Main</span><br><span class="line">21914 HMaster</span><br></pre></td></tr></table></figure>
<p>如果有<code>HMaster</code>就说明启动成功了，然后可以访问web界面了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:16010/</span><br></pre></td></tr></table></figure>
<p>**注:**不同的版本可能端口号不一致，具体的如果访问不了，网上查一下看看你的版本是那个端口号.</p>
<h4 id="伪分布式"><a href="#伪分布式" class="headerlink" title="伪分布式"></a>伪分布式</h4><p>先把hbase停掉<code>./bin/stop-hbase.sh</code>,然后修改<code>conf/hbase-env.sh</code>文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HBASE_MANAGE_XK=true</span><br></pre></td></tr></table></figure>
<p>然后重新修改<code>conf/hbase-site.xml</code>文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">    //这里设置让HBase存储文件的地方</span><br><span class="line">    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">    //这里设置让HBase存储内建zookeeper文件的地方</span><br><span class="line">    &lt;value&gt;/tmp/zookeeper&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>**注:**上面的<code>hbase.rootdir</code>配置的hdfs路径以及端口要和<code>/usr/dev/hadoop-2.6.4/etc/hadoop/core-site.xml</code>一致:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>然后再次启动hbase,出现如下报错情况:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost: +======================================================================+</span><br><span class="line">localhost: |                    Error: JAVA_HOME is not set                       |</span><br><span class="line">localhost: +----------------------------------------------------------------------+</span><br><span class="line">localhost: | Please download the latest Sun JDK from the Sun Java web site        |</span><br><span class="line">localhost: |     &gt; http://www.oracle.com/technetwork/java/javase/downloads        |</span><br><span class="line">localhost: |                                                                      |</span><br><span class="line">localhost: | HBase requires Java 1.7 or later.                                    |</span><br><span class="line">localhost: +======================================================================+</span><br><span class="line">starting master, logging to /usr/dev/hbase-1.2.3/bin/../logs/hbase-anonymous-master-anonymous.out</span><br><span class="line">starting regionserver, logging to /usr/dev/hbase-1.2.3/bin/../logs/hbase-anonymous-1-regionserver-anonymous.out</span><br></pre></td></tr></table></figure>
<p>出现这个问题一般是配置的问题，可以直接在环境变量文件里面强制配置一下，编辑<code>conf/hbase-env.sh</code>文件，把原来的注释解解掉，改成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/dev/jdk1.7.0_40</span><br></pre></td></tr></table></figure>
<p>然后记得得先把本机的hadoop伪分布式集群启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/dev/hadoop-2.6.4</span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br><span class="line">./sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>然后才能启动hbase</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/dev/hbase-1.2.3</span><br><span class="line">./bin/start-hbase.sh</span><br></pre></td></tr></table></figure>
<p>查看一下是否启动成功:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hbase-1.2.3 jps</span><br><span class="line">26874 HRegionServer</span><br><span class="line">24854 SecondaryNameNode</span><br><span class="line">26087 HQuorumPeer</span><br><span class="line">25125 NodeManager</span><br><span class="line">24529 NameNode</span><br><span class="line">26160 HMaster</span><br><span class="line">24671 DataNode</span><br><span class="line">2738 Main</span><br><span class="line">25312 JobHistoryServer</span><br><span class="line">25008 ResourceManager</span><br><span class="line">27040 Jps</span><br></pre></td></tr></table></figure>
<p>看到如果有HMaster以及HRegionServer说明启动成功.<br>**注:**如果又类似这种提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regionserver running as process 23997. Stop it first.</span><br></pre></td></tr></table></figure>
<p>可以直接先kill掉:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill -9 23997</span><br></pre></td></tr></table></figure>
<p>启动成功之后也会看到hdfs目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfs -ls /hbase</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>大数据</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 Hive 本地安装配置</title>
    <url>/2016/07/20/Ubuntu-16-04-Hive-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>很多时候需要测试一下我们的sql逻辑是否有问题，或者想在本地调试一个东西，线上的Hadoop跑的太慢，要视资源和进群调度情况而定，所以本地调试无疑是效率最高的方式，记录一下本地配置Hive的过程。</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04 LTS 64bit</span><br><span class="line">JDK: 1.7.0_40</span><br><span class="line">Hadoop:hadoop-2.6.4.tar.gz</span><br><span class="line">MySQL: 5.7.13</span><br><span class="line">Hive: hive-2.1.0</span><br><span class="line">➜  Blog git:(master) ✗ whoami </span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure>

<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>首先你需要安装配置好<code>Jdk</code>,<code>Hadoop</code>,<code>MySQL</code>这三个东西，前面两个可以参见上一篇笔记<a href="../../19/Ubuntu-16-04-Hadoop%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE">Ubuntu 16 04 Hadoop本地安装配置</a></p>
<h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>MySQL安装比较简单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y mysql-server</span><br></pre></td></tr></table></figure>
<p>设置对应的密码就行，其他的默认就可以，比较简单就不细讲了.主要讲后面的。</p>
<h4 id="创建Hive用户"><a href="#创建Hive用户" class="headerlink" title="创建Hive用户"></a>创建Hive用户</h4><p>登陆MySQL，创建Hive用户:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br><span class="line">create user &#x27;hive&#x27; identified by &#x27;hive&#x27;;</span><br><span class="line">grant all privileges on *.* to &#x27;hive&#x27;@&#x27;localhost&#x27; identified by &#x27;hive&#x27;;</span><br></pre></td></tr></table></figure>
<p>**注意:**第一个<code>hive</code>是创建的用户名为<code>hive</code>,<code>identified by</code>后面的那个<code>hive</code>是密码。<br>然后用刚创建的用户登陆,并创建数据库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uhive -phive</span><br><span class="line">mysql&gt; create database hive;</span><br></pre></td></tr></table></figure>

<h4 id="安装Hive"><a href="#安装Hive" class="headerlink" title="安装Hive"></a>安装Hive</h4><p>去Apache官网下载就行<a href="https://hive.apache.org/">Hive官网地址</a>,我这里下载的是最新的版本<code>apache-hive-2.1.0-bin.tar.gz</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf apache-hive-2.1.0-bin.tar.gz -C /usr/dev/</span><br><span class="line">sudo chown -R anonymous /usr/dev/apache-hive-2.1.0-bin/</span><br></pre></td></tr></table></figure>
<p>然后需要配置Hive,一下操作默认都是在<code>/usr/dev/apache-hive-2.1.0-bin</code>目录中操作的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp conf/hive-default.xml.template conf/hive-site.xml</span><br></pre></td></tr></table></figure>
<p>然后修改<code>hive-site.xml</code>文件中对应位置的内容，根据实际情况修改，比如数据库的名字，用户名，密码等，我的配置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/usr/dev/apache-hive-2.1.0-bin/warehouse&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;location of default database for the warehouse&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;jdbc:mysql://localhost:3306/hive?characterEncoding=UTF-8&amp;amp;createDatabaseIfNotExist=true&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;</span><br><span class="line">    JDBC connect string for a JDBC metastore.</span><br><span class="line">    To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class="line">    For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;Username to use against metastore database&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;password to use against metastore database&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>MySQL主要用来存储元数据，即一些表的信息，默认的是<code>Derby</code>,现在我们改为用<code>MySQL</code>，所以还需要把<code>Jdbc</code>驱动包拷贝到Hive的库目录下,如果本地没有可以去<a href="https://dev.mysql.com/downloads/connector/j/">MySQL官网</a>下载,不过如果你用过<code>JetBrain</code>系列的IDE，例如<code>IDEA</code>,<code>PyCharm</code>，可以在该用户目录下的<code>.IntelliJIdea14</code>目录下找到这个jar包，把这个jar包拷贝到Hive库目录下即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate mysql-connector-java</span><br></pre></td></tr></table></figure>
<p>根据查找内容找到jar包所在目录，可能会有很多地方有这个jar包，随便拷一个就行，拷贝该jar包即可,以我的为例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /home/anonymous/.m2/repository/mysql/mysql-connector-java/5.1.16/mysql-connector-java-5.1.16.jar /usr/dev/apache-hive-2.1.0-bin/lib</span><br></pre></td></tr></table></figure>
<p>到这里终于可以启动Hive试一试了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/hive</span><br><span class="line">Logging initialized using configuration in jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/hive-common-2.1.0.jar!/hive-log4j2.properties Async: true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: org.apache.hadoop.hive.ql.metadata.HiveException: org.apache.hadoop.hive.ql.metadata.HiveException: MetaException(message:Hive metastore database is not initialized. Please use schematool (e.g. ./schematool -initSchema -dbType ...) to create the schema. If needed, don&#x27;t forget to include the option to auto-create the underlying database in your JDBC connection string (e.g. ?createDatabaseIfNotExist=true for mysql))</span><br><span class="line">	at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:578)</span><br><span class="line">	at org.apache.hadoop.hive.ql.session.SessionState.beginStart(SessionState.java:518)</span><br><span class="line">	at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:705)</span><br><span class="line">	at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:641)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</span><br><span class="line">	at org.apache.hadoop.util.RunJar.run(RunJar.java:221)</span><br><span class="line">	at org.apache.hadoop.util.RunJar.main(RunJar.java:136)</span><br><span class="line">Caused by: org.apache.hadoop.hive.ql.metadata.HiveException: org.apache.hadoop.hive.ql.metadata.HiveException: MetaException(message:Hive metastore database is not initialized. Please use schematool (e.g. ./schematool -initSchema -dbType ...) to create the schema. If needed, don&#x27;t forget to include the option to auto-create the underlying database in your JDBC connection string (e.g. ?createDatabaseIfNotExist=true for mysql))</span><br><span class="line">	at org.apache.hadoop.hive.ql.metadata.Hive.registerAllFunctionsOnce(Hive.java:226)</span><br></pre></td></tr></table></figure>
<p>启动不了,看错误信息里面有提示，好像是元数据库没有初始化，就照着搞一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/schematool -initSchema -dbType mysql</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/log4j-slf4j-impl-2.4.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/hadoop-2.6.4/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line">Metastore connection URL:	 jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true</span><br><span class="line">Metastore Connection Driver :	 com.mysql.jdbc.Driver</span><br><span class="line">Metastore connection User:	 hive</span><br><span class="line">Starting metastore schema initialization to 2.1.0</span><br><span class="line">Initialization script hive-schema-2.1.0.mysql.sql</span><br><span class="line">Initialization script completed</span><br><span class="line">schemaTool completed</span><br></pre></td></tr></table></figure>
<p>好，再启动一下试试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/hive</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/log4j-slf4j-impl-2.4.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/hadoop-2.6.4/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line"></span><br><span class="line">Logging initialized using configuration in jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/hive-common-2.1.0.jar!/hive-log4j2.properties Async: true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D</span><br><span class="line">	at org.apache.hadoop.fs.Path.initialize(Path.java:206)</span><br><span class="line">	at org.apache.hadoop.fs.Path.&lt;init&gt;(Path.java:172)</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>尼玛，还是不行，继续排查,同样，看错误信息貌似是配置文件里面的<code>$&#123;system:java.io.tmpdir</code>这个出问题了，解决方法:替换掉<code>conf/hive-site.xml</code>里面的所有的<code>$&#123;system:java.io.tmpdir&#125;</code>为固定值，比如我设置的就是<code>/usr/dev/apache-hive-2.1.0-bin/tmp</code>,只列出两个，有好几处，都得替换掉:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/dev/apache-hive-2.1.0-bin/tmp/$&#123;system:user.name&#125;&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/dev/apache-hive-2.1.0-bin/tmp/$&#123;hive.session.id&#125;_resources&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>好，再启动试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/hive</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/log4j-slf4j-impl-2.4.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/dev/hadoop-2.6.4/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line"></span><br><span class="line">Logging initialized using configuration in jar:file:/usr/dev/apache-hive-2.1.0-bin/lib/hive-common-2.1.0.jar!/hive-log4j2.properties Async: true</span><br><span class="line">Hive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. tez, spark) or using Hive 1.X releases.</span><br><span class="line">hive&gt; </span><br></pre></td></tr></table></figure>
<p>终于启动成功了,试一下基本的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">Failed with exception java.io.IOException:java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:user.name%7D</span><br><span class="line">Time taken: 0.99 seconds</span><br></pre></td></tr></table></figure>
<p>尼玛，又不行，同样的，把<code>conf/hive-site.xml</code>里面的<code>$&#123;system:user.name&#125;</code>全部替换成<code>$&#123;user.name&#125;</code>，然后重新试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; show tables;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.981 seconds</span><br><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到此终于搞定了。试下创建一张表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; create database dw_subject;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.233 seconds</span><br><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">dw_subject</span><br><span class="line">Time taken: 0.017 seconds, Fetched: 2 row(s)</span><br><span class="line">hive&gt; use dw_subject;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.021 seconds</span><br><span class="line">hive&gt; create table table_test (</span><br><span class="line">    &gt;   id bigint comment &#x27;自增id&#x27;,</span><br><span class="line">    &gt;   name string comment &#x27;姓名&#x27;</span><br><span class="line">    &gt; ) comment &#x27;测试表&#x27;</span><br><span class="line">    &gt; ROW FORMAT DELIMITED</span><br><span class="line">    &gt; FIELDS TERMINATED BY &#x27;\t&#x27;</span><br><span class="line">    &gt; LINES TERMINATED BY &#x27;\n&#x27;;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.315 seconds</span><br><span class="line">hive&gt; show create table table_test;</span><br><span class="line">OK</span><br><span class="line">CREATE TABLE `table_test`(</span><br><span class="line">  `id` bigint COMMENT &#x27;??id&#x27;, </span><br><span class="line">  `name` string COMMENT &#x27;??&#x27;)</span><br><span class="line">COMMENT &#x27;???&#x27;</span><br><span class="line">ROW FORMAT SERDE </span><br><span class="line">  &#x27;org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe&#x27; </span><br><span class="line">WITH SERDEPROPERTIES ( </span><br><span class="line">  &#x27;field.delim&#x27;=&#x27;\t&#x27;, </span><br><span class="line">  &#x27;line.delim&#x27;=&#x27;\n&#x27;, </span><br><span class="line">  &#x27;serialization.format&#x27;=&#x27;\t&#x27;) </span><br><span class="line">STORED AS INPUTFORMAT </span><br><span class="line">  &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">OUTPUTFORMAT </span><br><span class="line">  &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span><br><span class="line">LOCATION</span><br><span class="line">  &#x27;hdfs://localhost:9000/user/anonymous/warehouse/dw_subject.db/table_test&#x27;</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  &#x27;COLUMN_STATS_ACCURATE&#x27;=&#x27;&#123;\&quot;BASIC_STATS\&quot;:\&quot;true\&quot;&#125;&#x27;, </span><br><span class="line">  &#x27;numFiles&#x27;=&#x27;0&#x27;, </span><br><span class="line">  &#x27;numRows&#x27;=&#x27;0&#x27;, </span><br><span class="line">  &#x27;rawDataSize&#x27;=&#x27;0&#x27;, </span><br><span class="line">  &#x27;totalSize&#x27;=&#x27;0&#x27;, </span><br><span class="line">  &#x27;transient_lastDdlTime&#x27;=&#x27;1469260899&#x27;)</span><br><span class="line">Time taken: 0.156 seconds, Fetched: 23 row(s)</span><br></pre></td></tr></table></figure>
<p>这里可以看到有个问题，中文注释乱码了，怎么解决呢？网上有相关的教程，需要修改源码，重新编译<code>hive-exec-2.1.0.jar</code>这个包，暂时能用了，本机基本上是测试用，中文乱码也不影响使用，有空再研究怎么去乱码。</p>
<h3 id="Hive中文乱码"><a href="#Hive中文乱码" class="headerlink" title="Hive中文乱码"></a>Hive中文乱码</h3><p>乱码的问题网上也都一大片，可能每个人的问题还不一样，以我的为例,我的问题还不是乱码，是<code>?</code>，所有的中文都显示成<code>?</code>了。联系到有时候用<code>MySQL</code>没指定编码也会出现问题，我查看了一下hive的元数据表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| COLUMNS_V2 | CREATE TABLE `COLUMNS_V2` (</span><br><span class="line">  `CD_ID` bigint(20) NOT NULL,</span><br><span class="line">  `COMMENT` varchar(256) CHARACTER SET latin1 COLLATE latin1_bin DEFAULT NULL,</span><br><span class="line">  `COLUMN_NAME` varchar(767) CHARACTER SET latin1 COLLATE latin1_bin NOT NULL,</span><br><span class="line">  `TYPE_NAME` varchar(4000) DEFAULT NULL,</span><br><span class="line">  `INTEGER_IDX` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`CD_ID`,`COLUMN_NAME`),</span><br><span class="line">  KEY `COLUMNS_V2_N49` (`CD_ID`),</span><br><span class="line">  CONSTRAINT `COLUMNS_V2_FK1` FOREIGN KEY (`CD_ID`) REFERENCES `CDS` (`CD_ID`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1 |</span><br></pre></td></tr></table></figure>
<p>可能老版本的是叫<code>COLUMNS</code>,这个差不多，视版本而定,可以看到存注释的字段确实不是用的<code>utf8</code>编码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMENT varchar(256) CHARACTER SET latin1 COLLATE latin1_bin DEFAULT NULL,</span><br></pre></td></tr></table></figure>
<p>然后重启<code>hive</code>客户端，然后执行<code>desc</code>命令，发现还是问号，于是把表删了，然后把建表语句重新执行之后，再执行<code>desc</code>命令，果然好了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ve&gt; desc test.window_analysis;</span><br><span class="line">OK</span><br><span class="line">user_id             	bigint              	用户id                </span><br><span class="line">reg_time            	timestamp           	注册时间                </span><br><span class="line">Time taken: 0.091 seconds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure>
<p>但是<code>show create table xxx</code>语句的还是乱码。</p>
<h3 id="解决show-create-table乱码"><a href="#解决show-create-table乱码" class="headerlink" title="解决show create table乱码"></a>解决show create table乱码</h3><p>首先要去官网下载源码自己编译<a href="http://mirrors.cnnic.cn/apache/hive/">Hive源码</a>,</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hive</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 软件无法切换搜狗输入法</title>
    <url>/2016/08/29/Ubuntu-16-04-Pycharm%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p>出去玩了一趟，回来发现有的软件无法切换中文输入法了，总的来说就是浏览器还有系统自带的一些应用好像没啥影响，但是我安装的第三方然简就有的不行了，包括我又重装了输入法等还是不行，最后的解决办法可能和输入法模块的路径有关，不知道为啥找不到了。<br>会出现问题的软件一般为<code>WPS, IDEA, PyCharm</code>这些，所以只好在<code>Pycharm</code>启动文件里面去手动指定了,我的安装路径启动文件为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/dev/pycharm-2016.2/bin/pycharm.sh</span><br></pre></td></tr></table></figure>
<p>修改文件，在顶端加入以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>
<p>然后重启<code>Pycharm</code>就可以切换搜狗输入法了。</p>
<p>但是有时候<code>WPS</code>的中文输入法也不起作用，这个时候用这个方法去改<code>/usr/bin/wps</code>，然后打开文档也不起作用，最后实验了发现，要想用<code>wps</code>编辑输入中文，必须是从应用那先打开<code>wps</code>软件，然后从软件中打开一个文档才行，如果直接用右键，选择<code>wps</code>打开<code>xls</code>的文档是不行的。</p>
<p>**备注:**如果你之前可以，但是照这个方法弄了以后还不行，那么你需要运行一下<code>fcitx</code>诊断命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcitx-diagnose</span><br></pre></td></tr></table></figure>
<p>一般可以发现问题所在，如果没啥异常，那么你需要完全卸载<code>fcitx</code>,然后重新装一遍就好了，卸载命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge  fcitx</span><br><span class="line">sudo apt-get autoremove </span><br></pre></td></tr></table></figure>
<p>然后重新安装一下<code>fcitx</code>,为了保险起见，你可以把搜狗也卸载了重装。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 aria2 百度盘下载</title>
    <url>/2017/03/11/Ubuntu-16-04-aria2-%E7%99%BE%E5%BA%A6%E7%9B%98%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>由于本人经常在我的vps上下载东西上传到百度云,然后再下载到本地机器,平时的工作环境又是Ubuntu,官方没有提供百度盘的Linux版本,就算有如果不是非会员也很麻烦,限速很蛋疼，最快也就下300多k的速度.网上查了一下,虽然百度盘限速，但是不限下载线程,也就是说其实用浏览器去下载,百度官方限制你的单个http请求的速度,破解方法就是开多个线程,一般10个就够了,带宽够大可以再高点，只要机器扛得住。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>需要安装一个软件以及一个chrome的插件</p>
<h4 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h4><p>这个是Linux下面一个非常优秀的多线程下载工具,安装方法:</p>
<ul>
<li>安装aria2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install aria2</span><br></pre></td></tr></table></figure>

<ul>
<li>安装BaiduExporter</li>
</ul>
<p>装了这个之后需要配合一个浏览器插件,因为百度盘的文件链接是不能直接下载的，需要安装下Chrome插件<a href="https://github.com/acgotaku/BaiduExporter/blob/master/chrome.crx">BaiduExporter</a>,怎么安装Chrome插件就不细讲了，不懂的直接度娘。<br><strong>备注:</strong> 如果是Mac用户可以参考这篇文章<a href="http://www.jianshu.com/p/e5e56a1d25a3">Aria2 - 可能是现在下载百度云资料速度最快的方式</a>,由于主要讲Ubuntu下面的配置,这个就不多讲了.</p>
<ul>
<li>下载文件</li>
</ul>
<p>安装好<code>aria2</code>以及<code>BaiduExporter</code>之后,我们以一个百度云里面的文件来做个测试:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2016.04%20aria2%20%E7%99%BE%E5%BA%A6%E7%9B%98%E4%B8%8B%E8%BD%BD01.png" alt="下载文件链接"><br>注意是勾选所需要下载的文件,然后会多出一个<strong>导出下载</strong>标签页,然后我们需要点列表中的<code>导出下载</code>,然后就会弹出一个框:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Ubuntu%2016.04%20aria2%20%E7%99%BE%E5%BA%A6%E7%9B%98%E4%B8%8B%E8%BD%BD02.png" alt="aria2下载链接框"><br>把框里面的内容全部复制出来,直接丢到终端中执行，注意文件会保存到当前路径,如果你想保存到指定位置，还是先cd到指定目录吧.<br>下载的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aria2c -c -s10 -k1M -x16 --enable-rpc=false -o &#x27;Gantz.O.2016.720p.WEB-DL.AAC2.0.H.264 [MultiSub(Eng,Ita,Por,Rum,Swe,Tur)]v2.mkv&#x27; --header &quot;User-Agent: netdisk;5.3.4.5;PC;PC-Windows;5.1.2600;WindowsBaiduYunGuanJia&quot; --header &quot;Referer: http://pan.baidu.com/disk/home&quot; --header &quot;Cookie: BDUSS=FDVnRtbnVaclhoR2dMLWdScHY2TlNFN1h3b3Qyb0stcXgtcXpyS0gtSFpXT3RZSVFBQUFBJCQAAAAAAAAAAAEAAAA7KQQU0KHHv7Tz0KG08wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANnLw1jZy8NYcD; pcsett=1489315049-753101e6547a834c2756fc96703e7839&quot; &quot;https://pcs.baidu.com/rest/2.0/pcs/file?method=download&amp;app_id=250528&amp;path=%2Fapps%2Fbypy%2FGantz.O.2016.720p.WEB-DL.AAC2.0.H.264%20%5BMultiSub(Eng%2CIta%2CPor%2CRum%2CSwe%2CTur)%5Dv2.mkv&quot;</span><br></pre></td></tr></table></figure>
<p>看看下载结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[#99b455 2.2GiB/2.2GiB(99%) CN:10 DL:148KiB ETA:1 *** Download Progress Summary as of Sat Mar 11 19:12:58 2017 *** </span><br><span class="line">================================================</span><br><span class="line">[#99b455 2.2GiB/2.2GiB(99%) CN:10 DL:92KiB ETA:48s]</span><br><span class="line">FILE: /home/anonymous/Gantz.O.2016.720p.WEB-DL.AAC2.0.H.264 [MultiSub(Eng,Ita,Por,Rum,Swe,Tur)]v2.mkv</span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">[#99b455 2.2GiB/2.2GiB(99%) CN:1 DL:19KiB ETA:13</span><br><span class="line">03/11 19:13:57 [NOTICE] Download complete: /home/anonymous/Gantz.O.2016.720p.WEB-DL.AAC2.0.H.264 [MultiSub(Eng,Ita,Por,Rum,Swe,Tur)]v2.mkv</span><br><span class="line"></span><br><span class="line">Download Results:</span><br><span class="line">gid   |stat|avg speed  |path/URI</span><br><span class="line">======+====+===========+=======================================================</span><br><span class="line">99b455|OK  |   1.2MiB/s|/home/anonymous/Gantz.O.2016.720p.WEB-DL.AAC2.0.H.264 [MultiSub(Eng,Ita,Por,Rum,Swe,Tur)]v2.mkv</span><br><span class="line"></span><br><span class="line">Status Legend:</span><br><span class="line">(OK):download completed.</span><br></pre></td></tr></table></figure>
<p>**备注:**简单说明一下命令行里面的命令<code>s10</code>指下载的线程数为10.开始速度均值为<code>2Mb/s</code>,后面快完成的时候会慢下来，均速大概<code>1.2Mb/s</code>.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 安装Apache Kylin</title>
    <url>/2016/10/23/Ubuntu-16-04-%E5%AE%89%E8%A3%85Apache-Kylin/</url>
    <content><![CDATA[<p>最近貌似用Kylin来搭建OLAP数据分析已经成为了大多数公司采取的做法了，这个东西搭建起来还有些&#x3D;麻烦,因为它需要你先配置好Hadoop,Hive,Hbase这三个东西，任何一个配置的不对的话可能会出问题，下面介绍一下我的安装和配置过程</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>主要是依赖的环境的一些版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04 64bit</span><br><span class="line">Java: 1.7.0_40</span><br><span class="line">Hive: 2.1.0</span><br><span class="line">Hadoop: 2.6.4</span><br><span class="line">Hbase: 0.98.22-hadoop2</span><br><span class="line">Kylin: 1.5.4.1</span><br></pre></td></tr></table></figure>

<p>**备注:**这里Hbase并没有用官方的1.x版本，而是采用了Kylin官方建议的0.98版本，因为我第一次安装的时候由于hbase的问题而失败了，所以就换了一个低版本的，你在安装的时候也可以使用最新版，但是如果安装不成功，可以考虑采纳官方建议的组合版本</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>Hadoop,Hive,Hbase的安装这里就不讲了，可以参考我以前的文章，我采用的都是本地为分布式运行模式,去<a href="http://kylin.apache.org/download/">Kylin官方下载</a>最新版本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf apache-kylin-1.5.4.1-bin.tar.gz -C /usr/dev</span><br></pre></td></tr></table></figure>
<p>解压好了，然后就是配置环境变量了，注意我都配置在<code>/etc/profile</code>这个文件里面了，主要是有些时候环境变量读取不到，所以干脆来个最狠的，直接全局配置了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 大数据相关</span><br><span class="line">## Hbase</span><br><span class="line">export HBASE_HOME=/usr/dev/hbase-1.2.3</span><br><span class="line">export HBASE_CONF_DIR=$&#123;HBASE_HOME&#125;/conf</span><br><span class="line"></span><br><span class="line">## Hadoop</span><br><span class="line">export HADOOP_HOME=/usr/dev/hadoop-2.6.4</span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line"></span><br><span class="line">## Hive</span><br><span class="line">export HIVE_HOME=/usr/dev/apache-hive-2.1.0-bin</span><br><span class="line">export HCAT_HOME=$&#123;HIVE_HOME&#125;/hcatalog</span><br><span class="line">export HIVE_CONF=$&#123;HIVE_HOME&#125;/conf</span><br><span class="line"></span><br><span class="line">## Kylin</span><br><span class="line">export KYLIN_HOME=/usr/dev/apache-kylin-1.5.4.1-bin</span><br></pre></td></tr></table></figure>
<p>上面的目录如果不一致，改成你自己对应的目录,然后<code>source /etc/profile</code>使配置生效。</p>
<h3 id="配置Kylin"><a href="#配置Kylin" class="headerlink" title="配置Kylin"></a>配置Kylin</h3><p>配置Kylin使用Hive的数据库名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $&#123;KYLIN_HOME&#125;/conf</span><br><span class="line">vim kylin.properties</span><br><span class="line">kylin.job.hive.database.for.intermediatetable=kylin_middle</span><br></pre></td></tr></table></figure>
<p>然后记得要手动在Hive中创建数据库<code>kylin_middle</code>.</p>
<p>然后创建一个目录并赋给当前用户权限,假设当前用户为<code>anonymous</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop fs -mkdir /kylin</span><br><span class="line">hadoop fs -chown -R anonymous:anonymous /kylin</span><br></pre></td></tr></table></figure>
<p>然后检测一下Kylin的环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $&#123;KYLIN_HOME&#125;/bin</span><br><span class="line">./check-env.sh</span><br></pre></td></tr></table></figure>
<p>如果你的系统也报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KYLIN_HOME is set to /usr/dev/apache-kylin-1.5.4.1-bin</span><br><span class="line">cat：无效选项 -- 1</span><br><span class="line">Try &#x27;cat --help&#x27; for more information.</span><br><span class="line">-mkdir: Not enough arguments: expected 1 but got 0</span><br><span class="line">Usage: hadoop fs [generic options] -mkdir [-p] &lt;path&gt; ...</span><br><span class="line">failed to create , Please make sure the user has right to access</span><br></pre></td></tr></table></figure>
<p>那可能也是由于sh调用的问题，需要把所有sh脚本里面的<code>sh</code>替换成<code>bash</code>，我这里用<code>sed</code>命令来替换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/`sh /`bash /g&#x27; *.sh</span><br></pre></td></tr></table></figure>
<p>这样就把所有的替换了，并且替换结果也直接写回文件了.然后运行环境检测脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./check-env.sh</span><br></pre></td></tr></table></figure>
<p>如果没报什么错误，就可以正式运行了，记得先把hadoop hbase服务启动<br>然后再启动kylin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./kylin.sh start</span><br></pre></td></tr></table></figure>
<p>然后访问<a href="127.0.0.1:7070/kylin">127.0.0.1:7070&#x2F;kylin</a><br>第一次会有点儿慢，需要在hbase中创建表，稍微等大概10s就会弹出登陆界面<br>ADMIN&#x2F;KYLIN登陆就可以了</p>
<h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p>官方也提供了官方测试例子，如果你可以顺利登入系统，那么在<code>$&#123;KYLIN_HOME&#125;/bin</code>下面有个测试脚本<code>sample.sh</code>,运行这个脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $&#123;KYLIN_HOME&#125;/bin</span><br><span class="line">./sample.sh</span><br><span class="line">./kylin.sh stop</span><br><span class="line">./kylin.sh start</span><br></pre></td></tr></table></figure>
<p>一次执行上面三个命令，运行成功之后重新进入系统或者刷新即可，会有一个<code>learn_kylin</code>工程，你只需要在<code>Model</code>里面<code>Actions</code>里面<code>Build</code>这个Cube即可，然后在Monitor里面可以看编译的进度，只有到100%才说明你编译成功，双击可以查看每一步的编译具体步骤，可以查看具体的日志，如果你编译失败了，可以查看具体的日志，直到编译成功为止，然后在Insight里面可以写sql查询:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select part_dt,sum(price) from kylin_sales group by part_dt;</span><br></pre></td></tr></table></figure>
<p>可以看看这句，这个放到hive里面起码要30s,但是这个在Kylin里面基本就秒出结果了,Kylin提供的是sql接口,下一节讲一讲怎么集成上层的多维分析工具。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu create_ap rfkill lock</title>
    <url>/2016/02/20/Ubuntu-create-ap-rfkill-lock/</url>
    <content><![CDATA[<p>在<a href="../../../2015/10/07">Ubuntu 14.04设置wifi热点</a>这篇文章中我们使用create_ap来在Ubuntu上建立wifi,主要是看中了它可以建立隐藏wifi的功能，但是在使用的时候老是出问题，例如</p>
<blockquote>
</blockquote>
<p>WARN: Your adapter does not fully support AP virtual interface, enabling –no-virt<br>Config dir: &#x2F;tmp&#x2F;create_ap.wlan0.conf.A912iinp<br>PID: 20324<br>command failed: Operation not supported (-95)<br>Access Point’s SSID is hidden!<br>RTNETLINK answers: Operation not possible due to RF-kill</p>
<p>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rfkill list all</span><br><span class="line">0: hci0: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">1: dell-wifi: Wireless LAN</span><br><span class="line">        Soft blocked: <span class="built_in">yes</span></span><br><span class="line">        Hard blocked: no</span><br><span class="line">2: dell-bluetooth: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">3: phy0: Wireless LAN</span><br><span class="line">        Soft blocked: <span class="built_in">yes</span></span><br><span class="line">        Hard blocked: no</span><br></pre></td></tr></table></figure>
<p>注意看1和3的<code>Soft blocked</code>那里都是yes,在终端里输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rfkill unblock wifi</span><br><span class="line">$ sudo rfkill unblock all</span><br></pre></td></tr></table></figure>
<p>然后再看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rfkill list</span><br><span class="line">0: hci0: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">1: dell-wifi: Wireless LAN</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">2: dell-bluetooth: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">3: phy0: Wireless LAN</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br></pre></td></tr></table></figure>
<p>yes那里变成no了，然后就可以再次使用create_ap来建立wifi了。引用子stackoverflow上网友的原话：</p>
<blockquote>
</blockquote>
<p>Soft-blocking<br>The output to sudo rfkill list shows that your network card is “soft-blocked”.<br>This could happen when the wireless card has been signalled to switch-off via the kernel.<br>Try the following steps:<br>run in a terminal:<br>sudo rfkill unblock wifi; sudo rfkill unblock all<br>rerun sudo rfkill list to confirm that the card has been unblocked.<br>reboot<br>rerun sudo rfkill list again to confirm unblocking as been retained.<br>rerun sudo lshw -class network - you should now see that the kernel has recognised (or not) the wireless card.<br>If the wireless kernel module has been recognised (it should not say “unclaimed”), Network Manager should now be able to see wireless networks that are available in your vacinity.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu an operation is already pending</title>
    <url>/2016/02/06/Ubuntu-an-operation-is-already-pending/</url>
    <content><![CDATA[<p>在Ubuntu 14.04 上插硬盘，结果,无法挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An operation is already pending</span><br></pre></td></tr></table></figure>

<p>解决方案，在终端中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.media-handling automount <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后把硬盘拔了重新插上就可以挂载了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Vim安装Markdown插件</title>
    <url>/2015/11/02/Ubuntu-Vim%E5%AE%89%E8%A3%85Markdown%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在Ubuntu下使用vim开发,写博客,由于博客是使用markdown写的,之前是使用sublime Text来写markdown,不过还是想完全用键盘,书写更快,决定以后都使用vim来写markdown了.</p>
<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>首先要安装vim,没有的话终端安装也方便:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>然后安装插件管理器,有几种方式,就以<code>pathogen</code>为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果执行这个命令报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl: (23) Failed writing body (0 != 12140)</span><br></pre></td></tr></table></figure>
<p>这是没有写权限所导致的，可以为三个文件夹赋权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 ~/.vim</span><br><span class="line"><span class="built_in">cd</span> ~/.vim</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 <span class="built_in">autoload</span> bundle </span><br></pre></td></tr></table></figure>
<p>然后在<code>~/.vimrc</code>文件里添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute pathogen#infect()</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 如果刚装的vim,啥东西也没有加过,可能没有<code>.vimrc</code>文件,需要自己新建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.vimrc</span><br></pre></td></tr></table></figure>
<p>然后添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>

<h3 id="安装vim-markdown插件"><a href="#安装vim-markdown插件" class="headerlink" title="安装vim-markdown插件"></a>安装vim-markdown插件</h3><p>现在假设你的<code>pathogen</code>已经安装好了,安装<code>vim-markdown</code>插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/plasticboy/vim-markdown.git</span><br></pre></td></tr></table></figure>
<p>然后重新打开一个<code>*.md</code>文件就可以生效了,注意,打开<code>*.md</code>文件,标题块之间会被折叠,光标跳转到折叠行,按空格就可以展开.</p>
<p>由于是用<code>hexo</code>写博客,还需要对<code>YAML</code>语法,需要在<code>~/.vimrc</code>中添加如下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let g:vim_markdown_frontmatter=1</span><br></pre></td></tr></table></figure>
<p>基本的插件安装就这几个步骤，其实也没有很特别的提示功能，只是在写错的时候可以看出来，还有就是按标题折叠成块比较实用。</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 启动栏应用无法启动解决方案</title>
    <url>/2016/05/29/Ubuntu-%E5%90%AF%E5%8A%A8%E6%A0%8F%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>最近刚装好了Ubuntu16.04，好不容易配置好了开发环境，突然发现IDEA,和PyCharm无法从启动栏和Dash菜单中启动，摸索来一阵之后，查阅资料发现来问题所在,记录一下，也希望给其他人一点参考，简单来说就是，环境变量不对导致无法启动。<br>以IntelliJ IDEA为例，我的IDEA和Pycharm都只能从终端启动，很不方便，即是从终端启动了，我把图标固定在左侧的快速启动栏，仍然启动不了，下面看看解决办法。<br>首先去<code>~/.local/share/applications</code>目录看下有没有你的应用程序启动文件,关键字搜索一下,如果没有就去<code>/usr/share/applications</code>文件夹看看，找到你的程序，双击，如果能够启动则应该没是没有问题的，但是双击不能启动，则即使你把图标固定到快速启动栏，程序仍然启动不了。<br>双击<code>IntelliJ IDEA</code>图标，提示报错信息，找不到JDK,问题就出在这里，但是奇怪的是我明明装了JDK,也设置来环境变量，怎么会找不到呢？于是我用vim查看了一下这个启动项的具体配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /usr/share/applications</span><br><span class="line">$ cat jetbrains-idea.desktop</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=IntelliJ IDEA</span><br><span class="line">Icon=/usr/dev/idea-IU-139.1117.1/bin/idea.png</span><br><span class="line">Exec=&quot;/usr/dev/idea-IU-139.1117.1/bin/idea.sh&quot; %f</span><br><span class="line">Comment=Develop with pleasure!</span><br><span class="line">Categories=Development;IDE;</span><br><span class="line">Terminal=false</span><br><span class="line">StartupWMClass=jetbrains-idea</span><br></pre></td></tr></table></figure>
<p>可以看到启动程序调用的脚本路径<code>/usr/dev/idea-IU-139.1117.1/bin/idea.sh</code>，这个就是我IDEA的解压安装路径，但是奇怪的是我从终端启动也是运行的这个脚本，就可以启动，为什么系统调用就不行呢？而且错误信息提示的是找不到JDK,后来我才明白，原来我安装了zsh,所以设置在<code>~/.zshrc</code>里面的环境变量并不能对bash启动的程序生效，所以找不到JDK。<br>既然明白了问题所在，解决办法也就有了,要么把环境变量设置成系统级别的环境变量，要么直接在对应的启动脚本中加入JDK的路径:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /usr/dev/idea-IU-139.1117.1/bin/idea.sh</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line"># Locate a JDK installation directory which will be used to run the IDE.</span><br><span class="line"># Try (in order): IDEA_JDK, JDK_HOME, JAVA_HOME, &quot;java&quot; in PATH.</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">if [ -n &quot;$IDEA_JDK&quot; -a -x &quot;$IDEA_JDK/bin/java&quot; ]; then</span><br><span class="line">  JDK=&quot;$IDEA_JDK&quot;</span><br><span class="line">elif [ -n &quot;$JDK_HOME&quot; -a -x &quot;$JDK_HOME/bin/java&quot; ]; then</span><br><span class="line">  JDK=&quot;$JDK_HOME&quot;</span><br><span class="line">elif [ -n &quot;$JAVA_HOME&quot; -a -x &quot;$JAVA_HOME/bin/java&quot; ]; then</span><br><span class="line">  JDK=&quot;$JAVA_HOME&quot;</span><br><span class="line">else</span><br><span class="line">  JAVA_BIN_PATH=`which java`</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>分析启动脚本，反正就是找不到JAVA_HOME,JDK的路径了,简单粗暴的直接在检查变量之前定义好,在注释下面，条件判断的前面加上JAVA的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/dev/jdk1.7.0_40</span><br><span class="line">JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br></pre></td></tr></table></figure>
<p>这样再点击图标就可以运行了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>用Vim对比两个文件的不同</title>
    <url>/2015/11/03/Vim-%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>从mysql数据库抽取数据到hadoop时,中间加了一个校验层,发现某天的数据Hive表里的和mysql里的差了一条,查询结果有7万多条,但是就只有一条不一样,最开始的思路是利用sql里的集合做差,即左外连接来过滤出那一条记录,但是由于Hive里是分区数据,查询语句怎么写都不对,后来换了一种思路,将查询结果保存到文件中,然后比较两个文件的不同来判断差了哪一条数据.</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul>
<li>Hive数据导出到文件</li>
</ul>
<p>利用到了管道,将结果输入到文件,具体命令为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -uuser_name /home/dev/hive-0.12.0/bin/hive -database dw_subject -e <span class="string">&quot;select idid,create_time from table_name  where (create_time&gt;=&#x27;2015-10-29 00:00:00&#x27; and create_time&lt;=&#x27;2015-10-29 23:59:59&#x27;) order by idid;&quot;</span> &gt; subject.txt</span><br></pre></td></tr></table></figure>
<p> 注意,最好按照主键来将结果进行排序,因为数据很多,时间也可能有重复的,如果按时间来排序,时间相同的数可能顺序会有差异,7万多数据对比起来还是很麻烦的,所以尽量选不重复的字段排序,反正,最好能够保证排序不存在二义性即可.</p>
<ul>
<li>利用vim比较两个文件</li>
</ul>
<p>假设这两个文件是<code>subject.txt</code>和<code>source.txt</code>,命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim -d source.txt subject.txt</span><br></pre></td></tr></table></figure>
<p> 最终的效果如下图所示:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E7%94%A8Vim%E6%9D%A5%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C01.jpg" alt="Vim对比效果"></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 常用命令总结</title>
    <url>/2015/10/19/Vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>先申明，如果你不是非常需要和服务器以及服务器上的日志打交道，其实vim只会简单的光标移动以及插入，删除，复制，粘贴，保存即可。学习Vim和学习乐器很像，需要很长时间的练习，如果你平时很少用到vim，我建议是不用学的太深入，懂一些简单的即可。如果需要经常和日志打交道，那么，好好学学Vim，这可以很大的提升你的工作效率，当然学习成本很大。</p>
<h3 id="初级命令"><a href="#初级命令" class="headerlink" title="初级命令"></a>初级命令</h3><p>Ubuntu系统都自带了<code>vi</code>，你可以把Vim看成是Vi的升级版，Vim兼容Vi的所有命令，虽然vi<br>也可以用，但是有个不太好的地方，当你想在Vi打开的文件中插入东西时，它并没有提示，也就是不太好分清<code>Normal</code>模式和<code>Insert</code>模式，这个很容易搞混，一般就是多按几下<code>Esc</code>来确保是在<code>Normal</code>模式。所以我还是建议安装一个Vim。</p>
<h4 id="简单认识vim"><a href="#简单认识vim" class="headerlink" title="简单认识vim"></a>简单认识vim</h4><p>当你安装好Vim之后，一定项输入点东西，很多新手也就在这里止步了，很多人都不知道如何在Vim中插入字符，所以Vim给很多人的第一印象是难用，甚至不如记事本好用，其实Vim不是这样的，安装好之后，请按照下面的命令操作：</p>
<ol>
<li>启动Vim后，Vim在<code>Normal</code>模式下</li>
<li>按下<code>i</code>，进入<code>Insert</code>模式，这时Vim左下角会出现<code>-- INSERT --</code>，这个时候你可以像使用记事本那样，输入你想要输入的东西</li>
<li>按<code>Esc</code>，可以从<code>Insert</code>模式返回到<code>Normal</code>模式</li>
</ol>
<p>现在你已经掌握了基本的在Normal和Insert模式的切换了，下面是一些比较常用的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i    <span class="comment"># Insert 模式，按Esc返回Normal模式</span></span><br><span class="line">x    <span class="comment"># 删除当前光标所在的一个字符，你也可以试试delete键，效果是一样的</span></span><br><span class="line">:wq  <span class="comment"># 保存并且退出</span></span><br><span class="line"><span class="built_in">dd</span>   <span class="comment"># 删除光标所在那一行</span></span><br><span class="line">p    <span class="comment"># 粘贴剪贴板</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>:w</code>存盘，后面也可以跟文件名 空格隔开。<code>:q</code>退出</p>
<h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><p>Vim里移动光标有三种方式</p>
<ul>
<li>第一种：当然是用鼠标了，还可以用滚轮就不说了</li>
<li>第二种：<code>←↓↑→</code>，最简单易记的移动光标方式</li>
<li>第三种：<code>hjkl</code>，最常用的使用方式</li>
</ul>
<p>但是，最常用的其实是第三种，想想你为什么要放弃那么多好用的编辑器甚至IDE，其实很重要的一个理由是，用Vim可以做到基本不用鼠标，毕竟程序员需要频繁的在键盘和鼠标之间切换，有时候如果键盘可以完成的事，都是懒得去用鼠标点的，所以日常操作也会记一些经常用到的系统快捷键，所以，这里道理一样，并且使用<code>←↓↑→</code>，手指并不是很方便，所以大家习惯了使用<code>hjkl</code>。确实有点不好记，不过熟了就习惯了，有个技巧就是：<code>j</code>看上去像一个向下的箭头。</p>
<p><strong>建议：</strong>如果你不长用Vim，或者写代码的机会不是那么多，那么你只需要记住上面的几个命令就足够了，这几个命令可以让你能基本使用Vim来编辑文件，做简单的修改。再说个题外话，一般的编辑器，如果你需要拷贝一段文字的时候，一般是<code>Ctrl-c</code>配合<code>Ctrl-v</code>，Ctrl扮演的就是功能键的作用，即当功能键被按下，c便不再是c，变成了一个命令或者快捷键，<code>在Vim的Normal模式下，所有的键都是功能键</code>。</p>
<h3 id="中级命令"><a href="#中级命令" class="headerlink" title="中级命令"></a>中级命令</h3><p>下面在介绍的时候，多半是一些快捷键，如果是<code>Ctrl-key</code>，统一写成<code>&lt;C-key&gt;</code>。并且以<code>:</code>开始的命令需要输入回车，例如退出命令：<code>:q&lt;enter&gt;</code>。<br>为了更高效的使用Vim，一些简单的命令还是不行的，拿还不如使用IDE和其他文本编辑器更加方便，以下所有的命令都是在Normal模式下输入的，如果不确定是不是在Normal下，多敲几下Esc键。</p>
<ul>
<li>各种插入模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a	<span class="comment"># 在光标后插入</span></span><br><span class="line">o	<span class="comment"># 在光标所在行后免插入一个新行</span></span><br><span class="line">O	<span class="comment"># 大写字母o，表示在光标所在行前插入一个新行</span></span><br><span class="line">cw	<span class="comment"># 替换光标所在位置后一直到光标所在单词结尾的字符，就是删除掉</span></span><br></pre></td></tr></table></figure>

<ul>
<li>各种移动光标</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0		<span class="comment"># 数字0，到行头</span></span><br><span class="line">^		<span class="comment"># 到本行第一个不是空白的位置，空白包括空格，tab，换行，回车等</span></span><br><span class="line">$		<span class="comment"># 到本行行尾</span></span><br><span class="line">g_		<span class="comment"># 到本行最后一个不是空白的位置</span></span><br><span class="line">/pattern	<span class="comment"># 搜索pattern的字符串，多个匹配可以按n跳到下一个</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝&#x2F;粘贴</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p		<span class="comment"># 粘贴，在当前位置之后粘贴</span></span><br><span class="line">P		<span class="comment"># 粘贴，在当前位置之前粘贴</span></span><br><span class="line">yy		<span class="comment"># 拷贝当前行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>撤销&#x2F;重做</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u		<span class="comment"># undo 撤销</span></span><br><span class="line">&lt;C-r&gt;		<span class="comment"># redo 重做</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打开&#x2F;保存&#x2F;退出&#x2F;改变文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:e &lt;path/to/file&gt;		<span class="comment"># 打开一个文件，空格隔开</span></span><br><span class="line">:w				<span class="comment"># 存盘</span></span><br><span class="line">:saveas &lt;path/to/file&gt;		<span class="comment"># 另存为&lt;path/to/file&gt; 空格隔开</span></span><br><span class="line">:x				<span class="comment"># 保存并退出</span></span><br><span class="line">ZZ				<span class="comment"># 保存并退出</span></span><br><span class="line">:wq				<span class="comment"># 保存并退出</span></span><br><span class="line">:q!				<span class="comment"># 退出，但不保存</span></span><br><span class="line">:qa!				<span class="comment"># 强行退出所有正在编辑的文件</span></span><br><span class="line">:bn				<span class="comment"># 切换到打开的下一个文件</span></span><br><span class="line">:bp				<span class="comment"># 切换到挡开的上一个文件</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 其实只是切换文件可以用<code>:n</code>，表示到下一个文件。</p>
<h3 id="高效命令"><a href="#高效命令" class="headerlink" title="高效命令"></a>高效命令</h3><p>在处理文本的时候，有时候需要做很多重复的动作，下面来看看<code>Vim</code>如何重复自己</p>
<ul>
<li>重复命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.		<span class="comment"># 小数点，可以重复上一次命令，当然你要记住上次你干了啥</span></span><br><span class="line">N&lt;<span class="built_in">command</span>&gt;	<span class="comment"># 重复某个命令N次，N为数字，命令要是有效的vim命令</span></span><br></pre></td></tr></table></figure>
<p> 看看示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span>			<span class="comment"># 删除一行，并且删除的内容会存放到剪贴板</span></span><br><span class="line">2dd			<span class="comment"># 2dd表示删除从光标开始的两行</span></span><br><span class="line">3p			<span class="comment"># 粘贴文本3次，内容是剪贴板的内容，假设先执行了2dd，再3p，则会粘贴6行新内容</span></span><br><span class="line">100icontent [Esc]	<span class="comment"># 中间有个空格 插入100遍content&lt;space&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 如果在<code>100icontent [Esc]之后在输入小数点</code>.<code>。那么会再插入100遍content&lt;space&gt;，即重复上条命令。如果再输入</code>3.&#96;，会再输入3个content<space></p>
<ul>
<li>更快的移动光标</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NG		<span class="comment"># 到第N行，G必须大写</span></span><br><span class="line">gg		<span class="comment"># 到第一行</span></span><br><span class="line">G		<span class="comment"># 到最后一行</span></span><br><span class="line">w		<span class="comment"># 到下一个单词的开头</span></span><br><span class="line">e		<span class="comment"># 到下一个单词的结尾</span></span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 默认情况，单词是由字母，数字，下划线组成，如果认为是blank字符分隔，则需要使用<code>E</code>和<code>W</code>，如下如所示：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_vim%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%9301.jpg" alt="e,w和E,W区别"></p>
<p> 其实这并不是最强的光标移动，下面来看看最快的光标如何移动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%		<span class="comment"># 匹配括号移动，包括(,&#123;,[,这个对于编程来匹配括号非常好用，记住你需要把光标先移到括号上，然后就可以匹配到与之对应的反括号</span></span><br><span class="line">*		<span class="comment"># 匹配光标当前所在单词，移动到下一个，以blank字符为分隔符</span></span><br><span class="line"><span class="comment">#		# 匹配光标当前所在单词，移动到上一个,以blank字符为分隔符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选中</li>
</ul>
<p>一定要记住光标的移动快捷键，很多命令可以通过光标的移动来实现联动，比如从某个地方拷贝到某个地方，删除从某个位置到另一个位置，语法类似下面</p>
<blockquote>
<p><start position>command<end position></p>
</blockquote>
<p> 例如：<code>0y$</code>命令意味着：</p>
<blockquote>
<p>0	# 先到行头<br>y	# 从光标处开始拷贝<br>$	# 拷贝到本行最后一个字符</p>
</blockquote>
<p> 类似这样的命令还有：<code>ye</code>，从当前位置拷贝到本单词的最后一个字符。<code>y2/foo</code>，拷贝两个foo之间的字符串。不一定按<code>y</code>才会拷贝，下面的命令也会拷贝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d		<span class="comment"># 删除</span></span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^$/de		# 删除空白行</span><br><span class="line">:set encoding	# 查看文件编码</span><br><span class="line">:set list		# 显示不可见字符，一般来看每一行结尾是否有空格</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 大小写转换</title>
    <url>/2015/11/22/Vim-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Vim有个命令还是挺好用的，就是大小写转换，因为我把键盘上的<code>Caps Lock</code>键改成了<code>Esc</code>键，所以有时候如果直接写一个大写字母还好，可以用<code>Shift</code>键，但是如果写一个大写的单词那就比较麻烦了，这个时候大写转换命令就派上大用场了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gu	<span class="comment"># 转小写</span></span><br><span class="line">gU	<span class="comment"># 转大写</span></span><br></pre></td></tr></table></figure>

<p>当然对于<code>Vim</code>这么强大的工具来说，这个命令远远不止这么点作用，这个命令的强大之处在于可以配合光标移动命令达到各种效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">～		# 将光标下的字母改变大小写</span><br><span class="line">3～		# 将光标位置开始的3个字母改变其大小写</span><br><span class="line">g~~		# 改变当前行字母的大小写</span><br><span class="line">U		# 将可视模式下选择的字母全改写成大写字母</span><br><span class="line">u		# 将可视模式下选择的字母全改成小写字母</span><br><span class="line">gUU		# 将当前行的字母改成大写</span><br><span class="line">guu		# 将当前行的字母改成小写</span><br><span class="line">3gUU		# 将从光标开始到下面3行字母改成大写</span><br><span class="line">gUw		# 将那个光标下的单词改成大写</span><br><span class="line">guw		# 将光标下的单词改成小写</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu your firefox profile cannot be loaded</title>
    <url>/2016/04/23/Ubuntu-your-firefox-profile-cannot-be-loaded/</url>
    <content><![CDATA[<p>一时手贱把<code>~/tmp/</code>文件夹删了，结果火狐打不开了,最后在网上找了很久才找到解决方案，记录一下防止下次手贱了。<br>大部分文章只提到，把<code>~/.mozilla</code>文件的权限更改成当前用户和用户组，就可以了：</p>
<ul>
<li>察看.mozilla文件件的权限属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></table></figure>
<p>如果<code>~/.mozilla</code>文件夹的属性是<code>root</code>则改变文件夹的属性为当前用户。命令如下：</p>
<ul>
<li>需改文件夹权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chown -hR zhangsan:zhangsan ~/.mozilla/</span><br></pre></td></tr></table></figure>
<p>如此操作后，其实firefox还是启动不了，因为，还有一个文件夹的属性仍然是root，这个文件夹就是<code>~/.cache/mozilla</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/.cache</span><br><span class="line">$ ls -l </span><br><span class="line">$ sudo chown -hR zhangsan:zhangsan mozilla/</span><br></pre></td></tr></table></figure>
<p>经过如此折腾，双击firefox图标，才能正常启动firefox浏览器。<br>太坑爹了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 常用配置技巧</title>
    <url>/2015/11/05/Vim-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>Vim虽然很好用,但是平时有时候还不够好,需要自己配置一下,比如说,每次粘贴到vim里一大片内容,可能就会被弄乱,常用的vim配置设置都在<code>~/.vimrc</code>里.</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>基本配置就是平时的一些简单的配置,会经常用到的,下面都是我从平时工作中需要用到的配置中慢慢总结出来的,下面讲的如果没有特殊说明,都是默认配置在<code>~/.vimrc</code>文件中.</p>
<h4 id="设置table的宽度"><a href="#设置table的宽度" class="headerlink" title="设置table的宽度"></a>设置table的宽度</h4><p>写shell的时候,经常会在<code>if</code>的下一行给我空出两个制表符,每个制表符都是8个字符宽度,看着很别扭,<code>ts</code>是一个制表符显示宽度,<code>sw</code>是制表符实际占宽度.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set sw=4</span><br></pre></td></tr></table></figure>

<h4 id="设置粘贴不自动缩进"><a href="#设置粘贴不自动缩进" class="headerlink" title="设置粘贴不自动缩进"></a>设置粘贴不自动缩进</h4><p>粘贴之前在vim编辑器里先:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> <span class="built_in">paste</span></span><br></pre></td></tr></table></figure>
<p>然后再<code>insert</code>,把内容粘贴到vim里即可,粘贴完还需要关闭:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nopaste</span><br></pre></td></tr></table></figure>
<p>相信你也觉得好麻烦,其实这个有个开关模式,只要选择打开开关,关闭开关就能达到我们要的效果,所以利用键盘映射到这个开关,在配置文件里加上:<br>前两行是为了提示的,这样你在粘贴的时候就可以区分<code>paste</code>模式和<code>nopaste</code>模式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnoremap &lt;F2&gt; :set invpaste paste?&lt;CR&gt;</span><br><span class="line">imap &lt;F2&gt; &lt;C-O&gt;:set invpaste paste?&lt;CR&gt;</span><br><span class="line">set pastetoggle=&lt;F2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="更改Esc映射"><a href="#更改Esc映射" class="headerlink" title="更改Esc映射"></a>更改Esc映射</h4><p><code>Vim</code>里使用<code>Esc</code>的频率很高,但是一般的键盘设计使得按<code>Esc</code>很不方便,而且在Vim里,<code>Caps Lock</code>就是多余的,为什么这么说?因为有快捷键可以直接将小写转大写,单个的大写就使用<code>Shift</code>即可.<br>在终端里面执行下面命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmodmap -e <span class="string">&#x27;clear Lock&#x27;</span> -e <span class="string">&#x27;keycode 0x42 = Escape&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样你的建就被映射了,但是每次你重启之后,还得重新做映射,而且我们只想这个功能在Vim里是这样的,当我们退出Vim,键盘的按键恢复正常,可以在<code>.vimrc</code>文件里加上下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; 当进入vim的时候将Esc映射成大写键,退出的时候将大写键映射回来</span><br><span class="line">au VimEnter * !xmodmap -e &#x27;clear Lock&#x27; -e &#x27;keycode 0x42 = Escape&#x27;</span><br><span class="line">au VimLeave * !xmodmap -e &#x27;clear Lock&#x27; -e &#x27;keycode 0x42 = Caps_Lock&#x27;</span><br></pre></td></tr></table></figure>
<p>为了使用更加友好,还可以在<code>.vimrc</code>文件里加上下面这句:<br>在insert模式下,按&lt;Ctrl+u&gt;将光标所在单词变大写,记得要重启vim才会生效.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inoremap &lt;C-u&gt; &lt;esc&gt;gUiwea</span><br></pre></td></tr></table></figure>
<p>这个需要安装<code>xorg-xmodmap</code>安装包.</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 替换命令</title>
    <url>/2015/11/10/Vim-%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="替换-substitute"><a href="#替换-substitute" class="headerlink" title="替换[substitute]"></a>替换[substitute]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:[range]s/pattern/string/[c,e,g,i]</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table>
<thead>
<tr>
<th>命令</th>
<th>参数解释</th>
</tr>
</thead>
<tbody><tr>
<td>range</td>
<td>范围,<code>1,7</code>表示第一行至第七行.<br><code>1,$</code>表示第一行至最后一行,即整篇文章,也可以使用<code>%</code>来替代,<code>%</code>代表目前编辑的文章<br><code>#</code>是前一次编辑的文章.</td>
</tr>
<tr>
<td>pattern</td>
<td>将要被替换掉的字符串,也可以用正则来表示</td>
</tr>
<tr>
<td>string</td>
<td>用来替换到文本中的字符串</td>
</tr>
<tr>
<td>c</td>
<td>confirm,每次替换前会询问</td>
</tr>
<tr>
<td>e</td>
<td>不显示error</td>
</tr>
<tr>
<td>g</td>
<td>global,不询问,整行替换</td>
</tr>
<tr>
<td>i</td>
<td>ignore 不分大小写</td>
</tr>
</tbody></table>
<p><strong>注意:</strong><code>g</code>一般都要加上,否则只会替换每一行的第一个符合<code>pattern</code>的字符串.当然后面的四个参数可以一起用,不用逗号隔开,例如<code>cgi</code>表示:每次都询问,整行替换,不分大小写.</p>
<h3 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h3><p>替换就这几种开关,用法千变万化,以下命令都是在Vim里操作的.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令作用解释</th>
</tr>
</thead>
<tbody><tr>
<td>:s&#x2F;test&#x2F;dev&#x2F;</td>
<td>替换当前行第一个test为dev</td>
</tr>
<tr>
<td>:s&#x2F;test&#x2F;dev&#x2F;g</td>
<td>替换当前行所有test为dev</td>
</tr>
<tr>
<td>:n,$s&#x2F;test&#x2F;dev&#x2F;</td>
<td>替换从第n行开始到最后一行,每一行第一个test为dev</td>
</tr>
<tr>
<td>:n,$s&#x2F;test&#x2F;dev&#x2F;g</td>
<td>替换从第n行开始到最后一行,每一行所有test为dev<br><code>n</code>为数字,若<code>n</code>为<code>.</code>或者省略<code>n</code>,表示从当光标所在行开始。</td>
</tr>
<tr>
<td>:%s&#x2F;test&#x2F;dev&#x2F;</td>
<td>等同于<code>:1,$s/test/dev/</code></td>
</tr>
<tr>
<td>:%s&#x2F;test&#x2F;dev&#x2F;g</td>
<td>等同于<code>:1,$s/test/dev/g</code></td>
</tr>
<tr>
<td>:s#test&#x2F;#dev&#x2F;#</td>
<td>替换当前行第一个test为dev<br>可以使用#作为分隔符，此时中间出现的<code>/</code>不会作为分隔符</td>
</tr>
<tr>
<td>:%s+&#x2F;test&#x2F;beta&#x2F;+&#x2F;dev&#x2F;product&#x2F;+</td>
<td>使用<code>+</code>来替换<code>/</code>，将<code>/test/beta/</code>替换成<code>/dev/product/</code></td>
</tr>
<tr>
<td>:%s&#x2F;^M$&#x2F;&#x2F;g</td>
<td>windows先回车是<code>0A0D</code>,Unix下是<code>0A</code>，所以会多一个<code>^M</code><br>替换条件是一个正则表达式,意思是以<code>^M</code>结尾</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 编程常用高效必备插件</title>
    <url>/2015/11/02/Vim-%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E9%AB%98%E6%95%88%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>假设你已经了解基本的vim使用,并且喜欢在vim下写代码,你需要几个非常好用的插件,可以极大的提升你的工作效率.</p>
<h3 id="插件管理利器"><a href="#插件管理利器" class="headerlink" title="插件管理利器"></a>插件管理利器</h3><p>原始的插件管理方法就是下一个插件,拷贝到一个目录下就行了,但是这样有点儿乱,插件管理工具常用的用<code>pathogen</code>和<code>Vundle</code>.就管理插件而言,不需要太过于关注哪个好,都挺好用的,我使用的就是<code>pathogen</code>,其安装方法详见<a href="../Ubuntu-vim%E5%AE%89%E8%A3%85markdown%E6%8F%92%E4%BB%B6">Ubuntu vim安装markdown插件</a>这篇笔记里的介绍.</p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>列举了几个比较常用的插件</p>
<ol>
<li>nerdtree</li>
<li>snipMate</li>
<li>vim-multiple-cursors</li>
</ol>
<p>以下所有安装方法都是使用<code>pathogen</code>插件管理器的安装方法,其他方法自行琢磨.</p>
<h4 id="nerdtree插件"><a href="#nerdtree插件" class="headerlink" title="nerdtree插件"></a>nerdtree插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/scrooloose/nerdtree.git</span><br></pre></td></tr></table></figure>
<p>这个插件可以使用vim来打开文件夹,按回车进入文件夹,展开文件夹下面的所有文件,可以用vim的光标控制命令来移动,选择打开某个文件.</p>
<h4 id="snipMate插件"><a href="#snipMate插件" class="headerlink" title="snipMate插件"></a>snipMate插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tomtom/tlib_vim.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/MarcWeber/vim-addon-mw-utils.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/garbas/vim-snipmate.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/honza/vim-snippets.git</span><br></pre></td></tr></table></figure>
<p>这个工具可以快速,减少重复代码,关于具体的使用,你可以在插件目录<code>bundle/</code>存放插件的<code>snippets</code>目录下找到对应的语言的<code>snippets</code>,并且修改对应的<code>snippets</code>.</p>
<h4 id="vim-multiple-cursors插件"><a href="#vim-multiple-cursors插件" class="headerlink" title="vim-multiple-cursors插件"></a>vim-multiple-cursors插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/terryma/vim-multiple-cursors.git</span><br></pre></td></tr></table></figure>
<p>看名字的意思就是多光标编辑,比如你有个变量,在很多地方被引用了,突然有一天你觉得这个变量名字起的不好,想换一个变量名,这个时候可以使用这个,具体效果如下:<br>测试代码<code>multiple.py</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hell</span>(<span class="params">poorly_named_var</span>)</span><br><span class="line">    poorly_named_var ||= <span class="string">&quot;Nameless&quot;</span></span><br><span class="line">        puts(<span class="string">&quot;Hi, &quot;</span> + poorly_named_var)</span><br><span class="line">	end </span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/Vim%20%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E9%AB%98%E6%95%88%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B601.gif" alt="vim-multiple-cursors插件多光标效果"><br>上图的演示过程就是，具体的操作就是将光标移到变量的第一个字母，然后按<code>&lt;Crrl-n&gt;</code>就是增加一个，按<code>&lt;Ctrl-p&gt;</code>就是减少一个。连按三下都选中，然后按<code>c</code>,然后输入name即是上面的效果。</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 使用总结</title>
    <url>/2018/05/12/awk-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li>单引号双引号输出</li>
</ul>
<p>1.双引号:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print &quot;\&quot;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>使用<code>“”</code>双引号把一个双引号括起来,然后用转义字符<code>\</code>对双引号进行转义,输出双引号.</p>
<p>2.单引号:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print &quot;&#x27;\&#x27;&#x27;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>使用一个双引号<code>“”</code>然后在双引号里面加入两个单引号<code>‘’</code>,接着在两个单引号里面加入一个转义的单引号<code>\&#39;</code>，输出单引号.</p>
<ul>
<li>字符串操作</li>
</ul>
<p>1.取子串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(String, M, [N])</span><br></pre></td></tr></table></figure>

<p>2.分割域访问<br><code>NF</code>代表域个数,<code>$NF</code>最后一个,<code>$(NF-1)</code>倒数第二个<br>字符串,数字比较直接<code>&lt;=</code>;<code>&gt;=</code>;<code>==</code>这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F&#x27;xxx&#x27;用xxx分割</span><br></pre></td></tr></table></figure>

<p>3.分割结果保存到数组<br><code>($())</code>,例如想将<code>ls -l</code>的文件列表分割出来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_list=($(hadoop fs -ls /user/hive/warehouse/xxx.db | grep user | awk -F&#x27; &#x27; &#x27;&#123;print $NF&#125;&#x27;))</span><br></pre></td></tr></table></figure>
<p>这个就是获取hdfs上指定库目录的所有表名,然后就可以for遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for table in $&#123;file_list[@]&#125;;do</span><br><span class="line">  echo $table</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>es jstorm flux java.lang.NoSuchMethodError</title>
    <url>/2017/04/30/es-jstorm-flux-java-lang-NoSuchMethodError/</url>
    <content><![CDATA[<p>最近在研究怎么通过Flux来解析日志，前前后后踩了很多坑,毕竟貌似网上也没人这么干过，写一个通用化的代码，只通过配置文件来定义流计算任务．基本上写好了代码,以后再有新的任务都不用再写java代码,然后打包上传提交任务了．<br>开始集群上的jstorm是2.1.1的,并不支持flux方式的提交任务，所有升级了一下到2.2.1版本,最后跑了一下官方的<code>word-count</code>demo成功了.<br>然后开发好了通用的jar包来解析日志，简单来说就是:</p>
<ul>
<li><p>CommonKafkaSpout<br>给构造函数传入指定topic来从kafka读取日志数据</p>
</li>
<li><p>CommonBolt<br>传入解析规则，基本上就是正则表达式,细节不多说了,解析出<code>&lt;key,value&gt;</code></p>
</li>
<li><p>Write2ESBolt<br>把上游的内容写入到es中，构造函数也需要传入es的配置，基本上就是index,type这些</p>
</li>
</ul>
<p>所有的基本走通了之后,开始测试的时候Topology是用java代码写的,在集群上测试之后没啥问题，然后改用<code>yaml</code>文件来定义jstorm任务,结果提交到集群就有问题了,十分的奇怪,照理说<code>word-count</code>demo跑通了应该没啥问题了，但是涉及到真正的实战需要连接kafka,es就出问题了，报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.sameThreadExecutor</span><br><span class="line">类似的还有</span><br><span class="line">NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor conflits on Elastic Search jar</span><br></pre></td></tr></table></figure>
<p>然后google了很久，发现这个并不是es的问题，是guava的问题,原文在</p>
<blockquote>
</blockquote>
<p><a href="http://stackoverflow.com/questions/20791351/java-lang-nosuchmethoderror-com-google-common-util-concurrent-moreexecutors-sam">http://stackoverflow.com/questions/20791351/java-lang-nosuchmethoderror-com-google-common-util-concurrent-moreexecutors-sam</a></p>
<p>Check your classpath and see what version of guava is being used by your WAR. The error suggests that the version of guava jar being found at runtime does not match the version that was used at compile time.</p>
<p>简单一句话总结就是,jstorm集群上的guava版本和我们写的公共jar包里面的guava版本不一致.然后我去集群上的lib包上看了一下,发现jstorm 2.1.1用的guava是16.01版本的，于是我把集群上所有的机器里面的guava换成了20.0的，然后重启了集群,然后重新提交任务，果然就好使了,从kafka读取日志以及写入es也没问题了，任务终于不报错了.</p>
]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ElasticSearch</tag>
        <tag>Jstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用场景即解决方案</title>
    <url>/2017/02/22/git-%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8D%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>熟悉了怎么使用git,在基本了解了git的原理的基础上，要解决一些办法其实是知道一些方案的，只是有时候我们对git的众多命令记得不是那么熟。其实常用的一些场景也就那么几个，出了问题也一般就那些，记录一下，方便日后查找。</p>
<h3 id="merge错了分支"><a href="#merge错了分支" class="headerlink" title="merge错了分支"></a>merge错了分支</h3><p>有时候我们在自己的分支A上开发了一段时间，然后我们想把B分支merge到我们的分支A上，然后测试完没啥问题就把此次的结果一起merge到master上。但是在操作的时候不小心把master先merge到了分支A,如果再去merge分支B，那按照正常的流程，只能先把第一次的merge冲突解完了然后才能去merge分支B,然后再解冲突。这样就完全乱了，如何撤销某次merge呢,即让各个分支回到merge之前的状态?</p>
<ul>
<li>reset直接重置到merge之前的版本号</li>
</ul>
<p>此方法比较暴力，即抛弃掉merge之前那个版本号之后的所有提交，如果你在merge之后没有做什么其他的操作，可以直接简单一点，舍弃掉后面的所有提交,不会产生新的commit.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branch-A</span><br><span class="line">git reset --hard &lt;merge前的版本号&gt;</span><br></pre></td></tr></table></figure>
<p>**备注:**其实reset的意思就是用把当前分支的指针设置为你制定的那个版本号，以此达到还原或者说撤销目的。</p>
<ul>
<li>git revert 撤销之前的merge操作</li>
</ul>
<p>如果你在merge错了之后并没有立即发现，然后又提交了几次，然后才发现合并错了，这个时候就不能重置舍弃掉merge后面的提交了，可以使用<code>revert</code>只撤销掉merge那次的变更,此次操作会产生一个commit.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert -m &lt;用1或2指定需要保留的主线&gt; &lt;需要撤销的合并的sha版本号&gt;</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong> 分支的编号一般是按时间顺序决定的，parent分支是1，后面的那个分支是2.这个方法比较绕，一般不会用这个。</p>
<ul>
<li>git revert一般做法</li>
</ul>
<p>一般我们的解决办法其实只是处理我们弄错了的分支，因为虽然我们合并错了，但是master,分支B都是好的，没有多余的提交的，我么你只需要把分支A的问题搞定就行了，此操作也会产生一个新的commit:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert &lt;merge操作的版本号&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Git仓库无权限"><a href="#Git仓库无权限" class="headerlink" title="Git仓库无权限"></a>Git仓库无权限</h3><p>这个问题会经常出现，就算是很多用了好几年的程序员，有时候在出现这个问题的时候也不知道怎么解决，一般也就是去网上查一下，然后照着帖子里面弄一下，如果可以了，就再也不管了，如果不行，就接着找，试下一个方法，反正就这么一直试，试到后面总会莫名奇妙的解决了。如果实在不行可能就放大招重装系统或者git了。其实出现这个问题的根本原因就是ssh私钥和公钥的问题，要么是找不到，要么是找到了文件的权限不对.所以在出现这个问题的时候就知道怎么解决了.<br>首先得说明一下下面的两个命令的区别:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo git pull	// 读取的配置文件为/root/.ssh/id_rsa</span><br><span class="line">git pull	// 读取的配置文件为~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>可以试一下有什么区别:</p>
<ul>
<li>ssh -vT <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x6c;&#x61;&#x62;&#x2e;&#x78;&#x78;&#120;&#46;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x6c;&#x61;&#x62;&#x2e;&#x78;&#x78;&#120;&#46;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#x6d;</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug1: identity file /home/anonymous/.ssh/id_rsa type 1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_rsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_dsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_dsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_ecdsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_ecdsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_ed25519 type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /home/anonymous/.ssh/id_ed25519-cert type -1</span><br></pre></td></tr></table></figure>

<ul>
<li>sudo ssh -vT <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x6c;&#97;&#x62;&#x2e;&#120;&#x78;&#120;&#x2e;&#x78;&#120;&#120;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x6c;&#97;&#x62;&#x2e;&#120;&#x78;&#120;&#x2e;&#x78;&#120;&#120;&#x2e;&#99;&#111;&#109;</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_rsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_rsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_dsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_dsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_ecdsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_ecdsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_ed25519 type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /root/.ssh/id_ed25519-cert type -1</span><br><span class="line">debug1: Enabling compatibility mode for protocol 2.0</span><br></pre></td></tr></table></figure>
<p>不同权限加载的文件是不一样的，所以为了知道问题出在哪，首先你得知道在和git仓库同步代码的时候加载的是哪个地方的秘钥文件.<br>知道了加载哪个地方的文件之后，还有一个很重要的问题需要知道,秘钥文件的权限必须是<code>600</code>,很多时候可能关键的问题还是因为秘钥文件的权限不对</p>
<h3 id="切换相关"><a href="#切换相关" class="headerlink" title="切换相关"></a>切换相关</h3><p>切换有很多，主要是分支切换，版本切换以及文件的切换</p>
<ul>
<li>不同分支间文件切换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt; -- &lt;paths&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldb python 错误汇总分析</title>
    <url>/2017/02/07/mysqldb-python-%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>基本上每次在不同的机器上使用<code>MySQLdb-python</code>包都会出莫名奇妙的问题，总结一下，基本上就是<code>fedora,ubuntu,centos</code>这三个系统上的各种问题，其他系统我没有试过，所以以上是使用的前提。</p>
<p>前段时间折腾<code>fedora</code>上安装这个特别麻烦，主要是安装<code>mysql</code>比较麻烦，而且好不容易安装好了，设置密码也非常麻烦，本来就是本机做个简单的测试，太简单的密码还不让过,反正吧，用起来挺麻烦的。后来我就不折腾了，又换回了<code>ubuntu</code>了。<br>问题就出在这里，之前一直是用的<code>virtualenv</code>虚拟<code>python</code>环境做项目开发，<code>python</code>环境一直都是直接放在当前项目目录下的，所以有些项目我都放在公共的单独目录，以前一直用<code>ubuntu</code>，系统没变过，所以重装系统了虚拟环境都没啥问题,项目都可以直接运行。直到这次把系统从<code>fedora</code>切回<code>ubuntu</code>终于出现了问题，具体为:明明安装并且识别了<code>MySQLdb-python</code>，但是运行项目就报错，开始是由于没有安装<code>mysql</code>报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: libmysqlclient.so.18: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>然后安装mysql,装好了之后再运行还是报错,网上</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>pyCharm trying to add breakpoint to file that does not exist</title>
    <url>/2016/02/20/pyCharm-trying-to-add-breakpoint-to-file-that-does-not-exist/</url>
    <content><![CDATA[<p>pyCharm在调试程序的时候出现了这个问题,解决办法就是在<code>Run--&gt; View Breakpoints</code>里面(或者直接按Ctrl+Shift+F8)<br>这里可以看到所有的断点，哪怕是其他工程项目里面的，这就会导致几个问题，当你删掉了某些文件的时候，断点记录还在，所以在运行的时候会报错：</p>
<blockquote>
</blockquote>
<p>pydev debugger: warning: trying to add breakpoint to file that does not exist: &#x2F;home&#x2F;workspace&#x2F;work&#x2F;Python&#x2F;upload_file&#x2F;upload_file&#x2F;views.py (will have no effect)</p>
<p>原因就是我把这个删掉了，但是之前在调试这个文件的时候设置过断点，所以记录还在，把不需要的断点记录勾选掉就可以了。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python 连接hive</title>
    <url>/2017/06/08/python-%E8%BF%9E%E6%8E%A5hive/</url>
    <content><![CDATA[<p>首先不要参考官网的例子,pyhs2的作者已经不再更新了，所以你如果用官网的例子，多半会由于版本问题而搞出各种莫名奇妙的问题，这里推荐一下使用dropbox推出的PyHive,<a href="https://github.com/dropbox/PyHive">PyHive Github地址</a></p>
<p>官网配置貌似不大对，所以可以直接参考我的这个，起码我是本地测试通过的,环境:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04 64bit</span><br><span class="line">JDK: 1.7.40</span><br><span class="line">Hadoop: 2.7.3</span><br><span class="line">Hive: 2.1.0</span><br><span class="line">Python: 2.7.12</span><br></pre></td></tr></table></figure>

<h3 id="开启hiveserver2"><a href="#开启hiveserver2" class="headerlink" title="开启hiveserver2"></a>开启hiveserver2</h3><p>这个地方官方说的不是很好，导致后面按官网配置可能依然导致无法连接hiveserver2，下面说下我的步骤,首先<code>hive-site.xml</code>里面的默认配置都不用改，除非你的端口被占用或者你想指定端口.<br>重点是需要改Hadoop的配置文件<code>$&#123;HADOOP_HOME&#125;/etc/hadoop/core-site.xml</code>文件,我们假设你需要用<code>dev</code>这个用户来访问hiveServer2<code>服务,那么需要在</code>core-site.xml&#96;文件里面加上下面的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.dev.groups&lt;/name&gt;</span><br><span class="line">&lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;hadoop.proxyuser.dev.hosts&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>如果你这里不写这个，那么很可能也连接的时候会报错，提示你没有权限,然后其他的默认就行，不过确保你的<code>hive-site.xml</code>文件里面的配置是下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>然后可以开启hiveServer2服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash /workspace/dev/apache-hive-2.1.0-bin/bin/hiveserver2</span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>当配置好hiveserver之后,执行简单的select可能没有啥问题,但是像有一些稍微复杂的sql可能会失败.</p>
<ul>
<li>hiveserver 执行简单的count报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;LeaseRenewer:anonymous@localhost:9000&quot;</span><br><span class="line">Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;LeaseRenewer:anonymous@localhost:9000&quot;</span><br><span class="line">Exception in thread &quot;HiveServer2-Handler-Pool: Thread-49&quot;</span><br><span class="line">Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;HiveServer2-Handler-Pool: Thread-49&quot;</span><br></pre></td></tr></table></figure>
<p>解决方案:修改hadoop配置文件<code>core-site.xml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.map.memory.mb&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1024&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.child.map.java.opts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;-Xmx900M&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.map.java.opts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;-Xmx900M&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.reduce.memory.mb&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;2048&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.child.reduce.java.opts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;-Xmx1900M&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;-Xmx1900M&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>简单来说就是内存溢出,所以更改下默认的map,reduce阶段的一些内存设置.</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>fedroa 25 开发常用配置及问题</title>
    <url>/2017/02/13/fedroa-25-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>尝鲜使用了一段时间的<code>fedroa</code>,大概使用了一个月吧，之前一直是使用的<code>Ubuntu 16.04</code>,想着和服务器上的<code>CentOS</code>尽量保持一致就装了个<code>Fedroa 25</code>最为日常开发机器，大概用了一个月就放弃了，说句实话，不是很好用,引用一句在<code>stackoverflow</code>上的答案吧，我觉得确实说的很有道理，问题大概是<code>Ubuntu和Fedroa</code>有什么区别，我相信很多同时用过这两个系统的人都可能会问这个问题，那就是作为桌面开发机来说，到底选那个，或者又说这两者都是桌面环境的<code>Linux</code>,哪个更适合作为日常开发使用?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu的使命是使Linux对人更友好，更易于交互</span><br></pre></td></tr></table></figure>
<p>其实你都不可否认，<code>Ubuntu</code>应该是目前为止非常稳定的一个<code>Linux桌面开发环境</code>,这句话在我使用了一个月的<code>Fedroa</code>之后感受尤为深刻。</p>
<p>虽然也能用。碰到了各种问题，花了很多的时间，所以想记下来这些解决的笔记。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>系统Fedroa 25 64bit,以下操作都是在此基础上，其他系统仅做参考。可以先把源设置成阿里的源，那个源比较快。</p>
<h3 id="mysqldb-python"><a href="#mysqldb-python" class="headerlink" title="mysqldb-python"></a>mysqldb-python</h3><p>安装<code>mysqldb</code>报错,错误信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc: error: /usr/lib/rpm/redhat/redhat-hardened-cc1: No such file or directory</span><br><span class="line"> error: command &#x27;gcc&#x27; failed with exit status 1</span><br></pre></td></tr></table></figure>

<p>解决方案在<code>stackoverflow</code>上,链接为:<br><a href="http://stackoverflow.com/questions/34624428/g-error-usr-lib-rpm-redhat-redhat-hardened-cc1-no-that-file-and-directory">http://stackoverflow.com/questions/34624428/g-error-usr-lib-rpm-redhat-redhat-hardened-cc1-no-that-file-and-directory</a></p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>fedora直接安装vim是会失败的，这个实在是太操蛋了解决方案,先更新系统自带<code>vi</code>,然后才能装.<br>好不容易装好了之后发现，vim里面的东西没有办法用鼠标选中复制到剪贴板，解决方案:<br><a href="http://vi.stackexchange.com/questions/84/how-can-i-copy-text-to-the-system-clipboard-from-vim">http://vi.stackexchange.com/questions/84/how-can-i-copy-text-to-the-system-clipboard-from-vim</a></p>
<h3 id="右键菜单打开终端"><a href="#右键菜单打开终端" class="headerlink" title="右键菜单打开终端"></a>右键菜单打开终端</h3><p>之前用<code>Ubuntu</code>一直没觉得这个功能有多么贴心，直到<code>Fedroa</code>中右键菜单没了这个才发现没了这个功能好麻烦，有时候就像在当前目录打开一个终端，还必须打开一个然后一路<code>cd</code>到当前目录，解决方案:<br><a href="https://www.if-not-true-then-false.com/2011/nautilus-open-in-terminal-on-fedora-centos-red-hat-rhel/">right clik open terminnal</a></p>
<h3 id="启动栏快捷键"><a href="#启动栏快捷键" class="headerlink" title="启动栏快捷键"></a>启动栏快捷键</h3><p>有时候需要把常用的一些应用固定在左侧启动栏，但是有些解压的软件好像无法<code>Add favourate</code>,此时可以手动编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.local/share/applications</span><br></pre></td></tr></table></figure>
<p>下面的<code>xxxx.desktop</code>文件，照着写一个就行.<br>然后写完了可以用系统自带命令验证一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desktop-file-install xxx.desktop</span><br></pre></td></tr></table></figure>

<h3 id="sougo中文输入法"><a href="#sougo中文输入法" class="headerlink" title="sougo中文输入法"></a>sougo中文输入法</h3><p>中文社区有源:<a href="https://www.fdzh.org/blog/2015/10/18/fedora-sougoupinyin/">https://www.fdzh.org/blog/2015/10/18/fedora-sougoupinyin/</a></p>
<h3 id="同步盘"><a href="#同步盘" class="headerlink" title="同步盘"></a>同步盘</h3><p>公司把所有外网的网盘封了，内部提供的网盘是<code>ownCloud</code>,安装客户端程序:<br>地址:<a href="https://software.opensuse.org/download/package?project=isv:ownCloud:desktop&package=owncloud-client">https://software.opensuse.org/download/package?project=isv:ownCloud:desktop&package=owncloud-client</a></p>
<h3 id="取消左下角托盘"><a href="#取消左下角托盘" class="headerlink" title="取消左下角托盘"></a>取消左下角托盘</h3><p>TopIcons</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install gnome-tweak-tool</span><br></pre></td></tr></table></figure>
<p>然后照着github上来:<br><a href="https://github.com/phocean/TopIcons-plus">https://github.com/phocean/TopIcons-plus</a></p>
<h3 id="fedroa截屏"><a href="#fedroa截屏" class="headerlink" title="fedroa截屏"></a>fedroa截屏</h3><p>The default behaviour when pressing the PrintScreen key is to automatically place your screenshot in the Pictures folder in your home directory (i.e. “~&#x2F;Pictures”). The click and the flash mean that the screenshot has been taken, so just check the Pictures folder for your screenshot.</p>
<p>Other than just the “Print Screen’ key, which saves your whole Desktop to the Pictures folder, GNOME3 also has the following shortcuts enabled by default for screenshot actions:</p>
<p>PrintScreen – Takes a screenshot of your entire desktop and saves it to the Pictures folder.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alt + PrintScreen -- Saves a screenshot of the focused window to the Pictures Folder</span><br><span class="line">Shift + PrintScreen -- Lets you select an area of the screen, and saves to the Pictures Folder</span><br><span class="line">Ctrl + PrintScreen -- Takes a screenshot of your entire desktop and copies it to the clipboard.</span><br><span class="line">Ctrl + Alt + PrintScreen -- copies a screenshot of the focused window to the clipboard.</span><br><span class="line">Ctrl + Shift + PrintScreen -- Lets you select an area of the screen, and copies it to the clipboard.</span><br><span class="line">Ctrl + Shift + Alt + R -- Records a Screencast) of your entire desktop and saves it to your Videos folder.</span><br></pre></td></tr></table></figure>

<h3 id="fedroa-ssh-server"><a href="#fedroa-ssh-server" class="headerlink" title="fedroa ssh server"></a>fedroa ssh server</h3><p>安装完之后执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start sshd</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>这个最蛋疼,装完了还有一堆配置非常的麻烦。<br><a href="https://www.if-not-true-then-false.com/2010/install-mysql-on-fedora-centos-red-hat-rhel/">https://www.if-not-true-then-false.com/2010/install-mysql-on-fedora-centos-red-hat-rhel/</a><br>如果无法初始化用户的密码，可以在mysql中试试下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set authentication_string=password(&#x27;Root@123&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>**备注:**其实可以多折腾一下，但是说实话吧，这个系统的桌面版真的不好用，装个软件非常不方便，尤其是mysql.</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>slice indices must be integers or None or have an __index__ method</title>
    <url>/2016/02/24/slice-indices-must-be-integers-or-None-or-have-an-index-method/</url>
    <content><![CDATA[<p>写了个脚本读取指定文件的某一行到某一行，然后利用行数据做一些匹配提取，在终端中调用方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python run.py file_name beg_line end_line</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">    beg_line = sys.argv[<span class="number">2</span>]</span><br><span class="line">    end_line = sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> f.readlines()[beg_line:end_line]:</span><br><span class="line">            <span class="built_in">print</span> val.strip()</span><br></pre></td></tr></table></figure>
<p>当我在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python run.py 12 20</span><br></pre></td></tr></table></figure>
<p>时，报错：</p>
<blockquote>
<p>TypeError: slice indices must be integers or None or have an <strong>index</strong> method</p>
</blockquote>
<p>解决办法，python作为一个解释型语言，对类型没有强制检查，我们虽然输入的是两个数字，但是实际上<strong>beg_line</strong>,<strong>end_line</strong>是<code>str</code>类型,所以传入切片的类型不对，就会报上面的错。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>sed 批量替换修改原文件</title>
    <url>/2016/09/18/sed-%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>网上下载某个js库，官网下载的源码一般都带有样例，但是好多html里面引用的js都是使用的cdn网址，类似于这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/d3/3.5.2/d3.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但是好多优秀的JS插件都是国外的，所以很多作者的项目里面样例都是使用的国外的cdn,例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdnjs.com/</span><br></pre></td></tr></table></figure>
<p>但是由于某些特殊的你懂得原因，上面这个网占经常没办法访问，或者访问不了,所以我只能替换成国内的cdn，比如我上面最开始写的那个就是，现在问题来了，我想把<code>example</code>下面的所有<code>html</code>文件里面的这个js都替换掉，即把:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.2/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>替换成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/d3/3.5.2/d3.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其实使用一条Linux命令就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/old_xxx/new_xxx/g&#x27; &lt;file_name&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd examples</span><br><span class="line">sed -i &#x27;s#https://cdn.bootcss.com/d3/3.5.2/d3.min.js#https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.2/d3.min.js#g&#x27; *.html</span><br></pre></td></tr></table></figure>
<p>上面需要稍作解释:</p>
<ul>
<li>-i</li>
</ul>
<p>如果不加<code>-i</code>参数，那么sed会把结果输出到终端，加了之后替换的结果会写回到原文件</p>
<ul>
<li>s#old_xxx#new_xxx#g</li>
</ul>
<p>原替换语法是<code>s/old_xxx/new_xxx/g</code>,但是如果原本的内容里面就有<code>/</code>，要么转义这个字符，或者为了不破外可读性，降低出错概率，直接用<code>#</code>做分隔符更好</p>
<ul>
<li>*.html</li>
</ul>
<p>由于要替换所有的，所以最后面的文件名参数直接就写成<code>*.html</code>，这样就会把所有的<code>html</code>文件里面的内容替换并写回原文件了。</p>
]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib 中文乱码</title>
    <url>/2016/02/25/matplotlib-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>在使用matplotlib画图的时候，出现了以下错误：</p>
<blockquote>
</blockquote>
<p>&#x2F;home&#x2F;q&#x2F;python27&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;matplotlib-1.5.1-py2.7-linux-x86_64.egg&#x2F;matplotlib&#x2F;font_manager.py:1288: UserWarning: findfont: Font family [u’sans-serif’] not found. Falling back to Bitstream Vera Sans<br>  (prop.get_family(), self.defaultFamily[fontext]))</p>
<p>这让我十分费解，应该有这个字体的，于是让其他人登陆跑同样的程序则可以运行，于是我好奇登陆了交互式环境，引入<code>matplotlib</code>包看了一下，结果出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Python 2.7.4 (default, Dec 24 2013, 16:30:42)</span><br><span class="line">[GCC 4.4.6 20110731 (Red Hat 4.4.6-3)] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import matplotlib</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/matplotlib-1.5.1-py2.7-linux-x86_64.egg/matplotlib/__init__.py&quot;</span>, line 111, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import inspect</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/inspect.py&quot;</span>, line 42, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from collections import namedtuple</span><br><span class="line">  File <span class="string">&quot;collections.py&quot;</span>, line 17, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import numpy as np</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/__init__.py&quot;</span>, line 180, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from . import add_newdocs</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/add_newdocs.py&quot;</span>, line 13, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from numpy.lib import add_newdoc</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/lib/__init__.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .type_check import *</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/lib/type_check.py&quot;</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import numpy.core.numeric as _nx</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/core/__init__.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from numpy.testing import Tester</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/site-packages/numpy-1.10.4-py2.7-linux-x86_64.egg/numpy/testing/__init__.py&quot;</span>, line 10, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from unittest import TestCase</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/unittest/__init__.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .result import TestResult</span><br><span class="line">  File <span class="string">&quot;/home/q/python27/lib/python2.7/unittest/result.py&quot;</span>, line 9, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure>
<p>这个时候就很郁闷了，服务器上的<code>matplotlib</code>都是我装的，结果反倒我不能用，但是后来在网上看到了解决方案:原来出现这个问题是由于用户目录下的缓存导致的，需要清空缓存:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -r ~/.cache/</span><br></pre></td></tr></table></figure>
<p>清空缓存之后就可以运行了。</p>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc 400错误</title>
    <url>/2017/04/09/springmvc-400%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>前后端交互数据的时候，经常需要前端把数据提交给后端，前端一般就用ajax提交数据，就像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        url: &quot;pos_url.do&quot;,</span><br><span class="line">        contentType: &quot;application/json&quot;,</span><br><span class="line">        data: JSON.stringify(params),</span><br><span class="line">        success: function (resp) &#123;</span><br><span class="line">	    xxxx;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function (resp) &#123;</span><br><span class="line">            xxxx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>然后后端采用spring的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;post_url&quot;, method = RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String postURL(@RequestBody JsonParam[] params) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是<code>JsonParam</code>这个类的定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JsonParam implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String value;</span><br></pre></td></tr></table></figure>
<p>这样的话是可以从后端接受参数的，但是后来觉得这个<code>JsonParam</code>定义的不是很好，所以就把<code>name</code>改成了<code>key</code>,结果就报错了<code>400 bad request</code>,不知道为啥，连请求都报错了，更别说参数的接收和解析了，网上查资料，找到一个答案提示了我:</p>
<blockquote>
</blockquote>
<p>Verify the following things:<br>Whether the name of JSON matches the User class’s field name.<br>Also check whether JSON value is supported by the corresponding field name datatype in User class.<br>Do try it, I have faced the same issue numerous times.</p>
<p>然后我才明白，之前我自定义的Json类的两个属性就是<code>name,value</code>，然后改成<code>key,value</code>就报错了,所以错误的根源应该就是前端传过来的数据是<code>name=xxx,value=xxx</code>的数据格式,然后后端想按<code>key=xxx,value=xxx</code>这样来接收解析，然后就报<code>400 bad request</code>这个错误了,如果直接使用request来接收应该就没有这个问题了，但是参数和参数的值就得自己解析了.</p>
<p>具体的详细策略可以看spring源码,大概就是需要实现一些转化器来实现<code>http--&gt;bean</code>之间的互转</p>
]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu scrapy openssl/opensslv.h</title>
    <url>/2017/04/30/ubuntu-scrapy-openssl-opensslv-h/</url>
    <content><![CDATA[<p>搞一下爬虫,装了一下scrapy报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build/temp.linux-x86_64-2.7/_openssl.c:434:30: fatal error: openssl/opensslv.h: No such file or di</span><br><span class="line">rectory</span><br><span class="line">  compilation terminated.</span><br><span class="line">  error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1</span><br><span class="line">  </span><br><span class="line">  ----------------------------------------</span><br><span class="line">  Failed building wheel for cryptography</span><br><span class="line">  Running setup.py clean for cryptography</span><br></pre></td></tr></table></figure>
<p>具体报错就是上面那个:</p>
<blockquote>
</blockquote>
<p>fatal error: openssl&#x2F;opensslv.h</p>
<p>解决方法很简单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛测试域名回收迁移博客图床到腾讯云</title>
    <url>/2018/10/13/%E4%B8%83%E7%89%9B%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/</url>
    <content><![CDATA[<h1 id="七牛图床"><a href="#七牛图床" class="headerlink" title="七牛图床"></a>七牛图床</h1><p>最近发现博客里面用的七牛的免费图床全部过期了，之前也收到了七牛发的测试域名回收通知，当时以为域名过期了，再申请续一下就行，结果发现是直接都回收，啥都没有了，心中真是一万头草泥马。<br>之前工作比较忙也就忘了，最近登录博客一看，图片全部GG了, 博客搭建最近发现博客里面用的七牛的免费图床全部过期了，所以周末在家花时间就折腾了下迁移方案,记录一下.</p>
<h1 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h1><p>其实最初写博客的初衷也只是为了记录写自己日常工作中学到的一些东西，方便日后查阅。另外一个其实也有赠人玫瑰的想法,记录下工作中碰到的一些棘手的问题，方便同行交流。所以其实访问量不大，对图片的需求也不大，但是有时候博客里有必须得放一两张图。<br>所以最初在网上调研的时候，基本是看有哪些免费好用的图用的图床,当时看七牛的评价挺好的，一个月有10G的免费流量，一般人根本用不到那么多，而且方案也比较成熟，各种工具啥的都有，就用七牛了。所以现在不让用了，就调研了下其他的方案,网上有推荐其他免费图床的，反正我是真不敢用了。还有一些推荐阿里OSS的，不过据说收费比较复杂，用之前先好好研究下收费公式，因为我只有腾讯的vps,所以就只关注了腾讯的方案，腾讯和阿里OSS对应的服务叫COS,并且收费方式也很良心，大家可以去这里看下:<a href="https://buy.cloud.tencent.com/price/cos/calculator">定价对象存储 COS</a><br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E7%89%9B%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%9101.png" alt="COS计费规则截图"><br>所以看这个图，基本上你可以不用花钱，流量肯定够你用了.</p>
<h1 id="图片备份"><a href="#图片备份" class="headerlink" title="图片备份"></a>图片备份</h1><p>这里有个很坑的地方就是，如果你的测试域名过期，你上传到七牛云的文件你是没办法直接访问的,你会发现点击预览和下载都是没有反,你会发现点击预览和下载都是没有反应的，这是因为你上传生成的域名链接已经被回收了，是无法通过网页URL来访问的,只能通过其他接口来操作,主要有下面几个步骤:</p>
<h2 id="新建存储空间"><a href="#新建存储空间" class="headerlink" title="新建存储空间"></a>新建存储空间</h2><p>之前那个存储空间里面上传的文件已经没有办法访问了，但是可以创建一个新的存储空间，通过其他接口把文件都转移到新的存储空间，这样就可以访问那些失效的文件了，比如可以建一个新的存储空间叫<code>backup</code></p>
<h2 id="下载开发工具"><a href="#下载开发工具" class="headerlink" title="下载开发工具"></a>下载开发工具</h2><p><a href="https://developer.qiniu.com/kodo/tools/1302/qshell">命令行工具(qshell)</a>,这个工具提供了很多接口，下载下来解压就能直接用，根据的操作系统选择对应的就行，详细的可以看下载界面的链接,如果只用一次，也不用去设置什么环境变量了，直接开始搞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 我的是mac,所以用的是下面这个，具体的取决于你的系统</span><br><span class="line">sudo chmod +x qshell-darwin-x64</span><br><span class="line">ln -s qshell-darwin-x64 qshell</span><br><span class="line"># AK/SK 需要去 个人中心-&gt;密钥管理 看下你自己的</span><br><span class="line">./qshell account &lt;AK&gt; &lt;SK&gt;</span><br><span class="line"># 把过期存储空间所有文件列表保存到文件</span><br><span class="line">./qshell listbucket &lt;old存储空间&gt; list.txt</span><br><span class="line"># 切割出文件名</span><br><span class="line">cat list.txt | awk -F &#x27;\t&#x27; &#x27;&#123;print $1&#125;&#x27; &gt; list_final.txt</span><br><span class="line"># 把过期的文件列表搬迁到新的存储空间,我这里会出现让输入一个确认字符串，照着输入就行</span><br><span class="line">./qshell batchcopy &lt;old存储空间&gt; backup list_final.txt</span><br></pre></td></tr></table></figure>
<p>  然后就可以在网页上的新的存储空间看到之前那些无法查看的文件了.</p>
<h2 id="批量下载到本地"><a href="#批量下载到本地" class="headerlink" title="批量下载到本地"></a>批量下载到本地</h2><p>qshell提供了qdownload可以批量下载文件，不过官网给出的api文档特别标注了，这个接口默认是要收费的:<strong>配置【该功能默认需要计费，如果希望享受10G的免费流量，请自行设置cdn_domain参数，如不设置，需支付源站流量费用，无法减免！！！】</strong>,先看下用法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qshell qdownload [&lt;ThreadCount&gt;] &lt;LocalDownloadConfig&gt;</span><br></pre></td></tr></table></figure>
<p>  第一个下载线程数参数是个可选参数，可以不用管,主要是需要写个配置文件，并且记住，得配置下<code>cdn_domain</code>这个参数，新建一个配置文件<code>batch_download.conf</code>:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;dest_dir&quot;   :   &quot;/xxx/xxx/Downloads/qiniu&quot;,</span><br><span class="line">    &quot;bucket&quot;     :   &quot;backup&quot;,</span><br><span class="line">    &quot;prefix&quot;     :   &quot;&quot;,</span><br><span class="line">    &quot;suffixes&quot;   :   &quot;&quot;,</span><br><span class="line">    &quot;cdn_domain&quot; :   &quot;http://pgiolcvny.bkt.clouddn.com&quot;,</span><br><span class="line">    &quot;referer&quot;    :   &quot;&quot;,</span><br><span class="line">    &quot;log_file&quot;   :   &quot;download.log&quot;,</span><br><span class="line">    &quot;log_level&quot;  :   &quot;info&quot;,</span><br><span class="line">    &quot;log_rotate&quot; :   1,</span><br><span class="line">    &quot;log_stdout&quot; :   false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>备注:</strong><code>cdn_domain</code>这个就是你的<code>backup</code>这个存储空间的对外访问域名,每个参数的具体含义及使用事项在这里可以看到<a href="https://github.com/qiniu/qshell/blob/master/docs/qdownload.md">qdownload参数解释</a>,配置好之后就可以执行:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qshell qdownload batch_download.conf</span><br></pre></td></tr></table></figure><br>  终端中就可以看到日志，然后在<code>dest_dir</code>中就可以看到你要下载的文件了。</p>
<h2 id="上传到腾讯COS"><a href="#上传到腾讯COS" class="headerlink" title="上传到腾讯COS"></a>上传到腾讯COS</h2><p>我们把所有的文件下载下来之后，然后还需要把文件上传到COS，这样图片才可以作为资源被外部访问,如果你之前没有使用过对象存储服务，还需要先创建一个存储桶，记住权限要设置成对外可读(不然别人也访问不了),然后把这些文件上传到这个存储桶里边，这个在网页上就可以直接操作，可以批量把刚才下载的都上传了。</p>
<h2 id="批量替换"><a href="#批量替换" class="headerlink" title="批量替换"></a>批量替换</h2><p>然后就只剩一步了，我们现在可以通过腾讯的COS来作为我们的图床服务，所以如果你写的新的博客，可以直接用新的地址，但是你之前写的那些博客，都是七牛的域名，所以需要把博客的原始文件里面的图片链接全部替换成腾讯COS的域名，老的域名可以看你的博客文件，我的是:<code>http://7xn9y9.com1.z0.glb.clouddn.com</code>,然后新的域名可以直接在腾讯云控制台，点开一张你上传过的图片查看,我的是:<code>https://blog-1254094716.cos.ap-chengdu.myqcloud.com</code>.具体的文件名因为都是一样的编码方式，所以只用替换域名就行，这里可以用<code>sed</code>命令来批量操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd source/_post</span><br><span class="line"></span><br><span class="line"># Linux用户</span><br><span class="line">sed -i &#x27;s#(http://7xn9y9.com1.z0.glb.clouddn.com#(https://blog-1254094716.cos.ap-chengdu.myqcloud.com#g&#x27; *.md</span><br><span class="line"></span><br><span class="line"># Mac用户</span><br><span class="line">sed -i -e &#x27;s#(http://7xn9y9.com1.z0.glb.clouddn.com#(https://blog-1254094716.cos.ap-chengdu.myqcloud.com#g&#x27; *.md</span><br><span class="line">rm *.md-e</span><br></pre></td></tr></table></figure>
<p>**NOTE:**之所以替换的链接带上<code>(</code>是为了防止误伤,比如这边文章里就有七牛的域名链接地址,但是图片链接在MarkDown写法里都是放在括号里的,所以记得这么替换就行。</p>
<p>然后你可以去访问下你的博客，找一篇有图的，应该是可以访问的。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行建github仓库</title>
    <url>/2016/02/20/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BB%BAgithub%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>经常使用github的人应该不陌生，大多数人使用都是先在github的网站上建一个仓库，然后拷贝ssh或者http的地址，然后使用<code>git clone</code>命令来初始化项目，这样比较麻烦，其实可以直接通过命令行的方式来在github上建立一个仓库，然后直接把本地项目推送到github上的。</p>
<h3 id="命令行建立仓库"><a href="#命令行建立仓库" class="headerlink" title="命令行建立仓库"></a>命令行建立仓库</h3><ol>
<li>认证用户发一个POST就可以新建，于是使用curl构造POST，没有的自己安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;username&#x27;</span> https://api.github.com/user/repos -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;RepoName&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>然后把刚才建的仓库的地址加到git配置里<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:username/RepoName.git</span><br></pre></td></tr></table></figure></li>
<li>推送到github<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
</ol>
<p>**注意:**username换成你在github上的注册名,RepoName就是你打算在github上建立的仓库名，注意不要替换user</p>
<p>通过这几步就可以在命令行里完成所有的操作。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>关联算法之-Apriori</title>
    <url>/2015/12/01/%E5%85%B3%E8%81%94%E7%AE%97%E6%B3%95%E4%B9%8B-Apriori/</url>
    <content><![CDATA[<p>简单介绍一下什么是Apriori算法： Apriori算法是一种挖掘关联规则的频繁项集算法，其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。 Apriori（先验的，推测的）算法应用广泛，可用于消费市场价格分析，猜测顾客的消费习惯；网络安全领域中的入侵检测技术；可用在用于高校管理中，根据挖掘规则可以有效地辅助学校管理部门有针对性的开展贫困助学工作；也可用在移动通信领域中，指导运营商的业务运营和辅助业务提供商的决策制定。</p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>关联规则做数据挖掘一般的步骤可以分为两大类：</p>
<ol>
<li>依据支持度找出所有频繁项集(频度)</li>
<li>依据置信度产生关联规则</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>上面提到了两个概念：支持度和置信度。其实数据挖掘里面的概念很多，这里简单介绍几个最基本的术语，后面的变量和集合都会用到。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li><p>资料库(transaction database):存储着二维结构的记录集，定义为<code>D</code><br>**备注:**这个可以理解为数据库里面的交易记录，每一条交易为一条记录，所有这些需要挖掘的数据构成了一个记录集。</p>
</li>
<li><p>所有项集(items):所有项目的集合，定义为I.<br>**备注:**这个可以理解为，把资料库里的每一条记录拆分成最小单位，最后构成的一个集合</p>
</li>
<li><p>记录(transaction):在资料库的一笔记录。定义为T,T∈D</p>
</li>
<li><p>项集(itemset):同时出现项的集合。定义为：k-itemset(k项集)<br>**备注:**同时出现项的集合意思是所有项集里面的单个项或者多个项组合成的一条记录<br><strong>解释:</strong><code>[[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]]</code>就是资料库<code>D</code>，里面有4条记录，所有项集<code>I</code>为<code>[[1],[2],[3],[4],[5]]</code>,有5项；<code>[1,3,4]</code>为其中一条记录<code>T</code>;<code>[2,5]</code>称为2项集，<code>[2,3,5]</code>称为3项集。</p>
</li>
<li><p>支持度(support):定义为<br>$supp(X)&#x3D;\frac{occur(X)}{count(D)}&#x3D;P(X)$.<br>**备注:**支持度可以简单理解为投票，选举这种，在总人数(资料库),有多少人是选择支持你的，即X出现的次数(频度),即X出现的概率</p>
</li>
<li><p>置信度(confidence&#x2F;strength):定义为<br>$conf(X-&gt;Y)&#x3D;\frac{supp(X∪Y)}{supp(X)}$<br>即下面的意思$P(Y|X)&#x3D;\frac{P(XY)}{P(X)}$<br>**备注:**这个公式可以这么理解，买了<code>X</code>的人有多少人会同时会买<code>Y</code>，这就是<code>X</code>对<code>Y</code>的推荐度，概率论中的解释就是<code>P(Y|X)=P(XY)/P(X)</code>。看一个例子：<br> 例子：[支持度:3%,置信度:40%]<br> 支持度3%：意味着3%顾客同时购买牛奶和面包<br> 置信度40%：意味着购买牛奶的顾客40%也购买面包</p>
</li>
<li><p>候选集(Candidate itemset):通过合并得出的项集,有<code>k</code>个元素的候选集记为<code>C[k]</code>.</p>
</li>
<li><p>频繁集(Frequent itemset):支持度&gt;&#x3D;特定的最小支持度(Minimum Support&#x2F;minsup)的项集,表示为<code>L[k]</code>.<br>**注意:**频繁集的子集一定是频繁集,这个也好理解,假设子集都不满足最小支持度,那么与他组合的概率必然是只会比这个概率更小,参见概率论里面的联合概率.</p>
</li>
<li><p>提升比率(提升度Lift):<br>$lift(X-&gt;Y)&#x3D;lift(Y-&gt;X)<br>&#x3D;\frac{conf(X-&gt;Y)}{supp(Y)}&#x3D;\frac{conf(Y-&gt;X)}{supp(X)}<br>&#x3D;\frac{P(XY)}{P(X)P(Y)}$<br>经过关联规则分析后,针对某些人推销(根据某规则)比盲目推销(一般来说是整个数据)的比例,这个比率越高越好,我们称这个为强规则,这个可以理解为:假设买了X的人多半会买Y,那么我们就对买了X的人推销Y.</p>
</li>
</ol>
<h3 id="Apriori原理"><a href="#Apriori原理" class="headerlink" title="Apriori原理"></a>Apriori原理</h3><h4 id="Apriori例子"><a href="#Apriori例子" class="headerlink" title="Apriori例子"></a>Apriori例子</h4><p>先来个简单的例子,最初这个例子来源于零售商,我们假设有4个商品,编号为<code>0,1,2,3</code>,那么能够被一起购买的商品组合为:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E8%81%94%E7%AE%97%E6%B3%95%E4%B9%8B-Apriori01.png" alt="集合{0,1,2,3}中所有可能项集的组合"><br>我们的目标是找到经常一起购买的商品,这里就可以使用集合的支持度来衡量一个组合出现的频率.即某个组合出现的概率占总交易量的比例就是其支持度.这个理解起来很简单,但是计算起来计算量可不小,这里才4种物品,我们需要计算$2^n-1$种情况,正常应用场景绝不可能才4种商品,这个时候就要提到<code>Apriori</code>原理,可以大大减少频繁项集的数目<br><strong>Apriori</strong>原理:如果某个项集是频繁项集,那么它所有的子集也是频繁的.举个例子就是如果<code>&#123;0,1&#125;</code>是频繁的,那么<code>&#123;0&#125;,&#123;1&#125;</code>也一定是频繁的,上面介绍过了,这里就不再细说了.正着看没什么用,但是反过来,即一个项集(例如{0},{1})是非频繁项集,则他的超集({0,1})也是非频繁的:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E8%81%94%E7%AE%97%E6%B3%95%E4%B9%8B-Apriori02.png" alt="图中给出了所有可能的项集,其中蓝色表示非频繁项集,由于{0,1}非频繁,因此,它们的超集也是非频繁的,他们的支持度可以直接忽略,俗称减枝"></p>
<h4 id="使用Apriori返回目录"><a href="#使用Apriori返回目录" class="headerlink" title="使用Apriori返回目录"></a>使用Apriori返回目录</h4><p>关联分析的两个目标:发现频繁项集和发现关联规则.首先要找到频繁项集,然后根据频繁项集找到关联规则.<br>Apriori寻找频繁项集的一般步骤是:</p>
<ol>
<li>首先生成所有单个物品的项集列表</li>
<li>扫描交易记录查看哪些项集满足最小支持度要求,去掉那些不满足的项集</li>
<li>对剩下的项集进行组合生成包含两个元素的项集</li>
<li>重复2~3,直到所有项集都被去掉</li>
</ol>
<p>下面看看Python代码实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个用于测试的简单的数据集</span></span><br><span class="line"><span class="string">    如果需要从其他地方加载产生数据,只需要重写这个方法即可</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createC1</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建初始候选项集(Candidate)的列表，即所有候选项集只包含一个元素，</span></span><br><span class="line"><span class="string">    C1是大小为1的所有候选项集的集合</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> [item] <span class="keyword">not</span> <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item])</span><br><span class="line">    C1.sort()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">frozenset</span>, C1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanD</span>(<span class="params">D, Ck, minSupport</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算Ck中的项集在数据集合D(记录或者transactions)中的支持度,</span></span><br><span class="line"><span class="string">    返回满足最小支持度的项集的集合，和所有项集支持度信息的字典。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ssCnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="comment"># 对于每一条transaction</span></span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="comment"># 对于每一个候选项集can，检查是否是transaction的一部分</span></span><br><span class="line">            <span class="comment"># 即该候选can是否得到transaction的支持</span></span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ssCnt.has_key(can):</span><br><span class="line">                    ssCnt[can] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ssCnt[can] += <span class="number">1</span></span><br><span class="line">    numItems = <span class="built_in">float</span>(<span class="built_in">len</span>(D))</span><br><span class="line">    retList = []</span><br><span class="line">    supportData = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">        <span class="comment"># 每个项集的支持度</span></span><br><span class="line">        support = ssCnt[key] / numItems</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将满足最小支持度的项集，加入retList</span></span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>, key)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 汇总支持度数据</span></span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList, supportData</span><br></pre></td></tr></table></figure>
<p>上面代码中 “frozenset”，是为了冻结集合，使集合由“可变”变为 “不可变”，这样，这些集合就可以作为字典的键值.测试一下上面的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 导入数据集</span></span><br><span class="line">    myDat = loadDataSet()</span><br><span class="line">    <span class="comment"># 构建第一个候选项集列表C1</span></span><br><span class="line">    C1 = createC1(myDat)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建集合表示的数据集 D</span></span><br><span class="line">    D = <span class="built_in">map</span>(<span class="built_in">set</span>, myDat)</span><br><span class="line">    <span class="comment"># 选择出支持度不小于0.5 的项集作为频繁项集</span></span><br><span class="line">    L, suppData = scanD(D, C1, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">u&quot;频繁项集L：&quot;</span>, L</span><br><span class="line">    <span class="built_in">print</span> <span class="string">u&quot;所有候选项集的支持度信息：&quot;</span>, suppData</span><br></pre></td></tr></table></figure>
<p>看看运行出来的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">频繁项集L： [frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]</span><br><span class="line">所有候选项集的支持度信息： &#123;frozenset([4]): 0.25, frozenset([5]): 0.75, frozenset([2]): 0.75, frozenset([3]): 0.75, frozenset([1]): 0.5&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，只有支持度不小于<code>0.5</code>的项集被选中到<code>L</code>中作为频繁项集，根据不同的需求，我们可以设定最小支持度的值，从而得到我们想要的频繁项集.<br>上面我们找出了只含有一个元素的频繁项集,下面需要整合一下代码,一次选择</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自下而上设计开发一个大数据准实时同步系统</title>
    <url>/2018/05/22/%E5%A6%82%E4%BD%95%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%87%86%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>最近项目基本上进入尾声了，也有时间来整理下最近做的这个项目.因为主要就一个人在做,所以周期比较长,整个系统涉及到的开源数据框架比较多,所以感觉还是有不少价值的,当然这个里面也有很多的坑,只有做过才能体会到,后面我会慢慢展开.</p>
<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>主要是两个公司合并了,哪两家就不说了,反正是行业Top1,Top2.后来打算成立新公司,所以数据需要整合.其实在一开始合并之后,数据就有陆陆续续的整合,不过这种整合方式效率比较低,整个链路很长,涉及到很多部门,圈绕的比较大.具体的流程大概说下:</p>
<ol>
<li>首先数据在我们的数据仓库ETL跑完之后,会有一个下游作业把数据拷贝到一个公共hadoop队列里面(Hadoop权限这块比较差,由于支付的数据要求较高,在防火墙内,不可能共享Hive数据仓库所在目录的数据,所以只能采取这种方式共享数据);</li>
<li>然后由专门和对方公司数据部门对接的人来把我们拷贝到指定队列的数据从hadoop上下载下来,上传公有云服务器(其实就是FTP服务器);</li>
<li>然后对方公司的数据组有专门的人从公有云把数据下载到他们的Hadoop客户机上,然后把数据上传到他们的Hadoop集群,然后数据才能达到基本能用的状态.</li>
</ol>
<p>**PS:**由于Hive本身作为离线数据仓库,数据延迟为T+1,然后数据再到他们那，延迟就变成了T+2,并且整个过程涉及到的部门比较多.数据不出问题还好,一旦出了问题,得找到每个环节的负责人,然后定位问题出现的环节,总之是很麻烦.</p>
<p>所以上面的老大也觉得这种方式使用数据非常的麻烦,成本太大,关键是数据的时效性也不满足要求,所以就想做实时数据流同步,整合两边的数据仓库.当然数据仓库只是实时数据流的一个用途之一,也会有其他数据使用场景,比如实时计算之类的.</p>
<h1 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h1><p>一般而言,一个完整的数据体系结构都比较复杂,我这里就大概说下整体架构:</p>
<p><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E5%A6%82%E4%BD%95%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%87%86%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F001.png" alt="数据体系结构图"><br>如果觉得图片太小看不清可以在新标签中打开查看大图.我会从下而上简单说下这个架构里面都有些什么东西:</p>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>数据系统的第一步,数据采集.这部分数据主要分为两大类,DB数据以及业务日志</p>
<h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p>第一类就是比较主要的,业务数据库数据采集,目前基本上都是用的mysql数据库,所以采集方案比较大众化都是采用阿里的<a href="https://github.com/alibaba/canal">Canal</a>,当然一般可能不能直接拿来用，需要你根据公司的技术架构做一些二次开发,因为一般公司内部会对MySQL做一些架构来给业务提供高可用的特性.数据采集之后会封装成自定义的<code>Kafka Message</code>,为了方便区分,topic命名方式可以有一个统一规则,例如binlog_{db实例架构类型}_{db实例名},这样能比较方便知道某个db实例的binlog数据特性以及排查问题.这里需要注意的就是往Kafka上写数据的时候,Kafka的分区策略要注意下，一个参考建议就是可以采用(Schema,Table)作为PartitionKey.这样可以保证同一个表的数据是顺序存放在同一个分区的,这样后续的一些程序处理可以保证数据的顺序性.<br>**NOTE:**封装的KafkaMessage可以根据业务来,如果想简单起见,可以把Canal的RowChange消息整个封装进去.</p>
<h3 id="Tomcat-Log"><a href="#Tomcat-Log" class="headerlink" title="Tomcat Log"></a>Tomcat Log</h3><p>这部分数据原则上来说,并没有Database数据重要,因为我们建的大部分数据表,模型都是基于业务的ER关系表来的.但是日志数据可以做很多其他的事情,数据挖掘里面也有很大的用途,还有的主要就是业务辅助用,后面会讲一些使用场景.业务日志采集采取的方案比较多,有采用入侵式埋点的,但是现在的普遍做法应该还是非入侵式采集,因为日志采集事实上对业务而言是一个非必须的功能,但是线上业务首先要保证性能和可靠性不受其他无关影响.<br>采集业务日志一般采用的就是flume tail功能,对指定日志目录下面的文件执行类似Linux:<code>tail -f</code>命令不断滚动采集新产生的日志.这个里面也有很多的坑,目前最新的flume好像支持直接采集一个目录,这样就不用自己写tail插件去采集日志了.这部分日志采集之后也是放在Kafka集群,同样的也需要自己封装成定义的KafaMessage.建议是需要保留日志的文件名以及机器名,所以分区策略是用这两个key就可以了.<br>**NOTE:**一般大一点儿的公司,线上的业务系统都会有appId这种东西,所以建议如果有这个信息也封装到KafkaMessage消息里面.</p>
<h2 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h2><p>数据存储之后,就是数据的计算了,Kafka毕竟只能存一段时间,过期就会删除,所以这些消息会落地到其他的存储系统,不同类型的数据有不同的落地场景，相同的数据也可能有不同的落地场景,下面一个一个说下这些应用及落地场景:</p>
<h3 id="Binlog-Hive"><a href="#Binlog-Hive" class="headerlink" title="Binlog-&gt;Hive"></a>Binlog-&gt;Hive</h3><p>Database的binlog数据采集到Kafka之后,最大的一个用途就是作为数据仓库的ods层源数据.由于离线数据仓库一般延迟要求不高，基本上默认就是T+1,所以我们不用事实计算这部分数据,反而是吞吐量是个很重要的指标.所以这里可以考虑的就是Spark Streaming这个框架,微批处理,可以在延迟和吞吐量之间做一个很好的平衡.<br>当然如果你没有Spark集群,也可以用Flume消费Kafka消息写到本地(据说直接写HDFS性能不是很好，没有测试过),然后隔一段时间put到hdfs上.关于写的策略,因为每天的binlog是增量数据,所以你需要一个字段作为binlog的分区依据,可以在将Canal消息封装KafkaMessage的时候加上一个binlog的执行时间.<br>**关键点:**这个过程其实坑还是挺多的,Binlog一般并发比较大,你要保证数据可以准确去重,不会取到错误的数据.</p>
<h3 id="Binlog-ElasticSearch"><a href="#Binlog-ElasticSearch" class="headerlink" title="Binlog-&gt;ElasticSearch"></a>Binlog-&gt;ElasticSearch</h3><p>这个需求和Hive那个很像，但是又有一些区别.Hive不支持单行记录更新(据说貌似新版本的支持了,没去详细了解过),ElasticSearch简单来说就是作为Database里面的表的一个镜像.因为MySQL的单表数据量在超过5000w的时候性能会变得非常差,所以业务上为了性能考虑,都会对表按月或者其他规则做分表.所以一般像运营,开发,测试在查询数据的时候非常的不方便.而ElasticSearch本身就是作为索引系统而存在的,非常适合有大量的查询场景.<br>这个因为并不是同步到离线数据仓库里面,所以对数据的延迟要求会高一些,这个时候Spark Streaming就不太合适,那么可不可以使用Jstorm这种流式处理框架呢?答案是不行,原因也很简单,JStorm这种流处理框架是<code>at least once</code>语义,也就是能保证数据至少被处理一次(当然好像后面的版本是准备实现还是已经实现了<code>exactly only once</code>,反正我们自己用的并没有内置支持),并且还有一个很重要的原因就是:JStorm无法保证数据的顺序,一个拓扑里面的每个bolt会有多个task,数据如果是按随机分发的话,不同的task处理速度是没办法预估的,这就可能导致先产生的binlog变更记录有可能后写入到ElasticSearch,就容易出现数据不一致的问题.所以这种情况下异步流处理框架是没有办法处理这种问题的,所以在技术选型上我们可以选像<code>Spark Streaming</code>这种顺序批处理(但是也有条件限制,就是每次只能有一个batch在执行,队列设置成FIFO).<br>这里简单说下我们的技术方案:首先从Kafka消费Binlog,清洗出每个表的<code>Primary Key</code>,封装成自定义的Kafka Message写回到Kafka,然后再从Kafka去消费这种消息,拿到<code>Primary Key</code>,然后查询对应的Database,这样每次都是拿到的最新的记录,然后更新ElasticSearch,这样就不用担心数据变更记录顺序不一致的问题,因为每次拿到的都是最新的.至于历史数据问题也比较简单,直接把当前表里面的记录清洗出Key写到Kafka,后面作业不用改,自然就会消费到这些消息,整体架构如下:</p>
<p><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E5%A6%82%E4%BD%95%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%87%86%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F002.png" alt="Binlog-ElasticSearch"></p>
<p>**优化点:**其实这个项目后期还是有一些优化点的,目前为了简单起见是采取的中转了一次,并且反查Database的方案,这样可以不用考虑数据的顺序,正确性问题,因为反查拿到的数据永远是当前时间点的正确数据.但是也会有一个问题,就是服务部署的机器无法做到动态扩容,需要有指定Database的连接权限,公司的Database都是采用的ip白名单方式,需要提前申请权限.其实如果Kafka保证Binlog的数据正确性,那么下游完全不用再反查Database，直接按变更记录查询就行了,唯一需要担心的就是数据初始化和已有数据同步作业同时跑的一个顺序问题.</p>
<h3 id="Tomcat-Log-Redis-Hbase-ElasticSearch-Hadoop"><a href="#Tomcat-Log-Redis-Hbase-ElasticSearch-Hadoop" class="headerlink" title="Tomcat Log-&gt;Redis&#x2F;Hbase&#x2F;ElasticSearch&#x2F;Hadoop"></a>Tomcat Log-&gt;Redis&#x2F;Hbase&#x2F;ElasticSearch&#x2F;Hadoop</h3><p>这一步相信会有很多的应用场景,基本就涵盖了几乎所有的日志使用场景了,分别大致说一下几个场景吧.</p>
<h4 id="Trace系统"><a href="#Trace系统" class="headerlink" title="Trace系统"></a>Trace系统</h4><p>这个应该算是最终要,最有意义的一个东西:分布式式追踪系统.基本上一个稍微大一点儿的公司都会有自己的Trace系统,一方面是大公司的系统比较复杂,一件事情往往需要很多个系统互相配合才能完成;另外一个就是现在微服务比较火,都在提倡系统解藕,所以调用链会比较长.业界有名的就是Google 的Dapper,具体的实现有阿里的鹰眼(不开源),Twitter的Zipkin.当然这不是我们这里的主要内容,我们只关心如何应用,也就是在有traceId的情况下,这些日志能有哪些应用场景.有大概这么几个场景:</p>
<ol>
<li>服务异常排查: 这个就是用到的traceId,我们把这些日志通过流计算作业提取traceId,把日志按照qrtaceId存放,当某个服务出问题了,可以通过查询服务的调用链,分析具体的出问题在哪个环节.</li>
<li>用户行为&#x2F;订单流程分析: 这个的原理其实和上面的差不多,只不过现在不是看traceId,而是看userId&#x2F;orderNo.这个应用场景也很大,主要是发现异常数据,定位排查细节,一般我们会选取某个有问题的用户,查到他某个时间段的所有行为日志.上面这两个就比较适合存放在HBase中,至于为什么,了解HBase的特性的人应该就明白了.</li>
<li>运营分析: 一般对于有些系统,运营会关注系统的异常数据,在系统出现问题的时候,有时候运营需要查询到异常数据,然后批量做人工处理.我们也通过流计算提取所有的日志中的<code>Execption Log</code>,按应用名,系统,机器名,异常类型存放到ElasticSearch中.之所以放在ES中主要是因为可以安装ES-SQL插件,运营可以写SQL查询统计这些信息.当然也会有定时作业去汇总这些信息发邮件,按照系统给相关负责人发邮件.</li>
</ol>
<h4 id="Hive数据仓库"><a href="#Hive数据仓库" class="headerlink" title="Hive数据仓库"></a>Hive数据仓库</h4><p>虽然数据仓库主要是业务的DB数据,但是日志里面也含有非常多的信息,而且DB受限于业务和性能,不会把所有的东西都存在DB里面,但是日志就自由多了,可以输出很多有用的信息,比如记录用户的位置&#x2F;搜索&#x2F;页面浏览记录,再比如修改密码&#x2F;登录这些,往往DB里面只会记录成功的那条记录,中间很多失败的信息是只存在于日志里面的.所以这部分数据也会通过Streaming作业这个ETL过程并入到Hive数据仓库里面.PM也主要是分析用户行为日志来改进用户体验.</p>
<h4 id="统一查询"><a href="#统一查询" class="headerlink" title="统一查询"></a>统一查询</h4><p>这个说起来其实也不算一个单独的功能,上面的这几个其实说到底也是提供了统一查询的功能.这里要说的是一个统一入口问题,正常的开发线上排查问题,查看日志都是直接到对应的机器上查看的.但是当我们有实时日志采集系统之后,完全可以做到屏蔽机器这层概念,即通过我们的系统直接实时tail服务器上的日志,虽然会有延迟,但是在秒级别的话是可以忽略的.</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      <categories>
        <category>数据架构</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>大数据</tag>
        <tag>Kafka</tag>
        <tag>Spark</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器安装pip工具</title>
    <url>/2016/01/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85pip%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>系统版本:CentOS release 6.4 (Final)<br>Python版本:2.6.6</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li><p>先下载安装setuptools</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py</span><br><span class="line">sudo python ez_setup.py --insecure</span><br></pre></td></tr></table></figure></li>
<li><p>然后下载安装pip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-7.1.2.tar.gz</span><br><span class="line">sudo tar -xvf pip-7.1.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pip-7.1.2</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip使用方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install module_name</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><p>有时候用pip安装,会提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SystemError: Cannot compile &#x27;Python.h&#x27;. Perhaps you need to install python-dev|python-devel</span><br></pre></td></tr></table></figure>
<p>这时候不能像Ubuntu上安装<code>python-dev</code>,在CentOS上,名字变了,像如下安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install python-devel</span><br></pre></td></tr></table></figure>
<p>**备注:**如果是Ubuntu安装报错<code>mysql_config</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    libs = mysql_config(&quot;libs_r&quot;)</span><br><span class="line">  File &quot;/tmp/pip-build-a7IbwK/MySQL-python/setup_posix.py&quot;, line 25, in mysql_config</span><br><span class="line">    raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,))</span><br><span class="line">EnvironmentError: mysql_config not found</span><br></pre></td></tr></table></figure>
<p>解决方案为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<p>还需要升级python2.6.6至2.7.x<br>查看python2.7安装位置，假设在<code>/usr/bin/q-python2.7</code>,建立软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加-b 参数是为了覆盖之前的软链接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -sb /usr/bin/q-python2.7 /usr/bin/python</span><br></pre></td></tr></table></figure>
<p>这会导致yum无法使用，修复办法,编辑<code>/usr/bin/yum</code><br>将头部的python改为python2.6</p>
<p>有时候由于国内某些你懂的原因，安装包经常连不上，需要设置pip的国内镜像CentOS修改<code>~/.pip/pip.conf</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
<p>对应的如果是Windows,则需要在对应用户目录下修改，例如<code>C:\Users\zhangsan\pip\pip.ini</code>，内容如上。</p>
<p>指定url安装包可以这样, 以<code>Flask</code>为例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i http://mirrors.aliyun.com/pypi/simple/ Flask</span><br></pre></td></tr></table></figure>

<p>项目依赖打包以及环境快速恢复:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖导出</span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"># 安装文件中所有依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlalchemy db.create_all 无法创建部分model</title>
    <url>/2016/09/01/sqlalchemy-db-create-all-%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E9%83%A8%E5%88%86model/</url>
    <content><![CDATA[<p>今天在做Flask模块的实体类ORM声明时，发现会报错,花了一上午查了好多资料才解决，记录一下解决方案，查资料的时候貌似碰到这个问题的人还挺多的.<br>报错信息为:</p>
<blockquote>
</blockquote>
<p>InvalidRequestError: When initializing mapper Mapper|Parent|parent, expression ‘childs’ failed to locate a name (“name ‘Child’ is not defined”). If this is a class name, consider adding this relationship() to the Parent class after both dependent classes have been defined.</p>
<p>什么意思呢？就是在在<code>Parent</code>与<code>Child</code>一对多的映射时，映射找不到这个类，这两个类属于不同的注册模块，当然也就不在一个文件中了，结构如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  web </span><br><span class="line">├── parent</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── templates</span><br><span class="line">│   └── views.py</span><br><span class="line">└── child</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── models.py</span><br><span class="line">    ├── templates</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure>
<p>部分关键代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = &#x27;parent&#x27;</span><br><span class="line">    __bind_key__ = &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    childs = db.relationship(&#x27;Child&#x27;, lazy=&#x27;dynamic&#x27;)</span><br><span class="line"></span><br><span class="line">class Child(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = &#x27;child&#x27;</span><br><span class="line">    __bind_key__ = &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    parent_id = db.Column(db.Integer, db.ForeignKey(&#x27;parent.id&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个很简单的一对多映射，其他的类都可以调用<code>db.create_all()</code>创建，但是我调用这个命令确并不会创建<code>Child</code>表,实在想不明白这个类特殊在哪，于是网上查阅说可以强制导入model的定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from web.child.models import *</span><br><span class="line">db.create_all()</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>
<p>然后去mysql里面看，确实可以创建表了，于是启动项目，结果登陆系统还是报一样的错，仍然是映射关系出问题，于是把谷歌翻了个变，终于找到了一个解决方法.<br>通常来说,<code>db.create_all()</code>无法创建所有表会有以下几个原因:</p>
<blockquote>
</blockquote>
<ol>
<li>model未继承<code>db.Model</code></li>
<li>views中未引入该表的model</li>
<li>create_all()与models定义不在一个文件</li>
</ol>
<p>对于一个多模块的系统来说，第3个原因不太可能，因为几乎不可能把models定义和<code>create_all()</code>放到一个文件里面。但是其他模块都没啥问题，所以问题不会出在这。<br>第一个显然不是，我的所有实体类都是继承了<code>db.Model</code>,所以当我把问题定位在2时，仔细一想好像真是这样，因为我虽然新增了一个模块，但是只是先把模块的<code>models</code>定义好了，<code>views.py</code>里面其实啥也没写，自然没有引用到新定义的<code>models</code>。<br>于是在<code>views.py</code>文件里面加了一句<code>web/child/views.py</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from web.child.models import *</span><br></pre></td></tr></table></figure>
<p>然后执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.drop_all()</span><br><span class="line">db.create_all()</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>
<p>然后登陆系统，果然没有出现映射问题了。</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>SQLALChemy</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类型全字段序列化转JSON</title>
    <url>/2019/06/23/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%85%A8%E5%AD%97%E6%AE%B5%E5%BA%8F%E5%88%97%E5%8C%96%E8%BD%ACJSON/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在构思做一个通用化的字典工具,其中有一个功能就是自动扫描枚举类，将枚举类序列化成一张表，对比更新到数据库中。但是在实际中使用发现，如果不做任何限制，直接用<code>fastjson</code>的<code>JSON.toJSONString(obj)</code> 方法，得到的只是枚举的名字，并没有得到一个全字段的json串。即<code>SUCCESS(0, &quot;成功&quot;)</code>得到的将是<code>SUCCESS</code>这个字符串</p>
<p>fastjson版本:1.2.56</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>重写覆盖枚举类的toString() 方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum EnumTest &#123;</span><br><span class="line">    SUCCESS(0, &quot;成功&quot;),</span><br><span class="line">    FAIL(-1, &quot;失败&quot;);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&#123;\n&quot; +</span><br><span class="line">                &quot;  \&quot;code\&quot;: &quot; + getCode() + &quot;,\n&quot; +</span><br><span class="line">                &quot;  \&quot;msg\&quot;: &quot; + getMsg() + &quot;\n&quot; +</span><br><span class="line">                &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，如果直接用<code>EnumTest.SUCCESS.toString()</code>就可以得到想要的结果，但是如果用<code>JSON.toJSONString(EnumTest.SUCCESS)</code>得到的仍然是<code>SUCCESS</code>。这个比较直白简单，但是不支持<code>fastjson</code>的方法,就是手动控制了枚举的<code>toString</code>输出内容，但是也有一个不好的问题就是，新增字段或者修改字段，还得改<code>toString</code>方法，万一忘了改，那可能会发生一些莫名其妙的Bug,而且还不易察觉,所以不推荐。<br>**NOTE:**注解是用了<code>lombok</code>包里面的一些方法</p>
<ol start="2">
<li>自定义SerializeConfig</li>
</ol>
<p>其实仔细看<code>JSON.toJSONString()</code>方法，有一些其他的重载方法提供了一些其他的参数，其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String toJSONString(Object object, SerializeConfig config, SerializerFeature... features) &#123;</span><br><span class="line">        return toJSONString(object, config, (SerializeFilter) null, features);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个里面有一个自定义序列化的配置参<br>使用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SerializeConfig config = new SerializeConfig();</span><br><span class="line">config.configEnumAsJavaBean(EnumTest.class);</span><br><span class="line">System.out.println(JSON.toJSONString(EnumTest.SUCCESS, config));</span><br></pre></td></tr></table></figure>
<p>我们对比下几个的输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;1:&quot; + EnumTest.SUCCESS.toString());</span><br><span class="line">System.out.println(&quot;2:&quot; + JSON.toJSONString(EnumTest.SUCCESS));</span><br><span class="line"></span><br><span class="line">SerializeConfig config = new SerializeConfig();</span><br><span class="line">config.configEnumAsJavaBean(EnumTest.class);</span><br><span class="line">System.out.println(&quot;3:&quot; + JSON.toJSONString(EnumTest.SUCCESS, config));</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:&#123;</span><br><span class="line">  &quot;code&quot;: 0,</span><br><span class="line">  &quot;msg&quot;: 成功</span><br><span class="line">&#125;</span><br><span class="line">2:&quot;SUCCESS&quot;</span><br><span class="line">3:&#123;&quot;code&quot;:0,&quot;msg&quot;:&quot;成功&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以比较灵活自由的达到我们想要的序列化效果，而没有破坏掉其他的一些引用到枚举类的地方，因为如果直接重载了枚举本身的<code>toString()</code>方法，会产生一些不可预知的错误。</p>
<h4 id="枚举嵌套"><a href="#枚举嵌套" class="headerlink" title="枚举嵌套"></a>枚举嵌套</h4><p>对于简单的枚举，这种应该没有啥问题，如果枚举出现了嵌套呢?我们写个例子测试一下,再申明一个<code>EnumTest2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 枚举定义</span><br><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum EnumTest2 &#123;</span><br><span class="line">    SUCCESS(0, &quot;成功&quot;, EnumTest.SUCCESS),</span><br><span class="line">    FAIL(-1, &quot;失败&quot;, EnumTest.FAIL);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String msg;</span><br><span class="line">    private EnumTest enumTest;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义序列化配置</span><br><span class="line">SerializeConfig config = new SerializeConfig();</span><br><span class="line">config.configEnumAsJavaBean(EnumTest2.class);</span><br><span class="line">System.out.println(JSON.toJSONString(EnumTest2.SUCCESS, config));</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">&#123;&quot;code&quot;:0,&quot;enumTest&quot;:&quot;SUCCESS&quot;,&quot;msg&quot;:&quot;成功&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>EnumTest2</code>本身序列化没问题，但是他的<code>enumTest</code>属性没有按照我们想要的方式来，需要改一些:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这个地方改一下</span><br><span class="line">config.configEnumAsJavaBean(EnumTest.class, EnumTest2.class);</span><br><span class="line">// 输出结果</span><br><span class="line">&#123;&quot;code&quot;:0,&quot;enumTest&quot;:&#123;&quot;code&quot;:0,&quot;msg&quot;:&quot;成功&quot;&#125;,&quot;msg&quot;:&quot;成功&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举转字典"><a href="#枚举转字典" class="headerlink" title="枚举转字典"></a>枚举转字典</h4><p>其实上面的基本是为了搞清楚枚举的序列化问题，主要目的其实还是为了我们的字典如何同步。因为并不是所有的枚举都需要入库，所以我们需要实现一个注解，当有这个注解的枚举，那么我们会把他同步到字典中。当然还有一个问题就是上面探讨的，如果一个枚举他嵌套了其他的枚举，我们还需要把他所引用的枚举都配置到自定义序列化的配置里，所以实现如下:</p>
<h5 id="同步注解"><a href="#同步注解" class="headerlink" title="同步注解"></a>同步注解</h5>]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线上Jstorm调优及问题排查</title>
    <url>/2018/08/11/%E7%BA%BF%E4%B8%8AJstorm%E8%B0%83%E4%BC%98%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h3><p>之前有一段时间<code>beta jstorm</code>集群打日志老是把磁盘都占满了,一开始懒得管,每次都是把<code>dump</code>堆栈文件直接删掉了.但是只是缓解了问题,后面磁盘在一段时间之后还是会别打满,后来有空排查了下问题,简单记录一下.<br>首先关于如何排查线上<code>Jstorm</code>作业问题这个,其实<code>Jstorm UI</code>也提供了线上的界面,可以查看作业执行日志以及<code>dump</code>堆内存,但是想看实时日志的话还是得到对应机器上查看,另外有些时候还得查看<code>Worker</code>日志才能比较好定位问题,这里用一个线上的实际问题来看下一般怎么排查问题.</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问题是这样的,<code>Jstorm</code>集群的机器最近经常磁盘报警,线上查看发现是<code>Worker</code>生成了很多<code>*.hprof</code>文件.这里简单说下,<code>Jstorm</code>集群的一个具体的<code>Worker</code>进程在发生<code>OOM</code>的时候会生成dump文件,也就是<code>*.hprof</code>文件,具体参数就是我们常说的<code>-XX:+HeapDumpOnOutOfMemoryError</code>.所以如果程序写的有问题某些参数设置的不对,或者数据量太大导致<code>OOM</code>的话,会不停的<code>dump</code>内存生成文件,直到磁盘被耗光.</p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>首先既然是磁盘被耗光了,那先看下磁盘上哪个<code>Worker</code>日志文件占用的磁盘空间最多,定位到具体的<code>Worker</code>之后,我们可以看下jvm运行信息:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E7%BA%BF%E4%B8%8AJstorm%E8%B0%83%E4%BC%98%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5001.jpg" alt="Jstorm Worker Jvm运行统计"><br>可以看到<code>Perm</code>区已经<code>100%</code>了，其他几个区使用率很低,<code>FullGC</code>一直在增加,这个时候基本上就可以判断是<code>Perm</code>区的问题了，我们再确认下<code>Worker</code>的启动参数,直接<code>ps -axu | grep 32502</code>即可:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E7%BA%BF%E4%B8%8AJstorm%E8%B0%83%E4%BC%98%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5002.jpg" alt="Work启参数"><br>注意下红色标出来的部分<code>-XX:PermSize=33554432 -XX:MaxPermSize=33554432</code>,算一下基本就是<code>32M</code>这么大.方法区一般存的就是类的信息,这说明加载了太多的<code>Class</code>,可以用<code>jmap -histo:live 32502</code>看下，会发现确实有好多<code>xxxClass</code>的实例,说明确实是．最后我还看了对应的代码文件，发现也的确是用到了很多的的包，并且还是写在<code>static</code>代码块做初始化的．所以最后我改了下启动参数,具体为修改<code>storm.yaml</code>文件:</p>
<blockquote>
</blockquote>
<p>nimbus.childopts: “ -Xms1g -Xmx1g -Xmn500m -XX:PermSize&#x3D;50m -XX:SurvivorRatio&#x3D;4 -XX:MaxTenuringThreshold&#x3D;15 -XX:+UseConcMarkSweepGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:CMSFullGCsBeforeCompaction&#x3D;5 -XX:+HeapDumpOnOutOfMemoryError -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -XX:GCLogFileSize&#x3D;100M -XX:+UseCMSCompactAtFullCollection -XX:CMSMaxAbortablePrecleanTime&#x3D;5000 “<br>**PS:**当然不是说你改了就可以生效了,你需要先把对应的<code>Worker</code>进程干掉,我一般是直接<code>kill &lt;pid&gt;</code>,因为只要不是强制杀掉,Jstorm会在其他节点重启这个<code>Worker</code>,所以不会丢数据啥的,就直接杀掉了,然后是重启<code>Supervisor</code>进程,然后那些新提交的启动的<code>Worker</code>就会用新的参数启动,所有的就这么简单了,完事儿收工睡觉.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实在使用了这么久的<code>Jstorm</code>后，也想总结一下个人对<code>Jstorm</code>的看法,或者说大一点,对实时计算框架的一点看法,因为我本人也没有用过原生的<code>Storm</code>,所以这两者的框架优缺点我就不展开了.<br>首先说下<code>Jstorm</code>,也是目前我们采用的流处理框架,目前业务日志实时处理都是用的<code>Jstorm</code>,处理之后的日志会存到<code>ES/Hbase/Redis</code>这几个地方,上层会有应用去实时使用这些数据.因为日志是不可变更数据,所以<code>Jstorm</code>的异步+compent(并发度) 可以很好的提高吞度量而不用去考虑数据的处理顺序而去而外考虑同步态.并且日志数据的要求会低一些,就是允许丢失部分数据,所以在写ES的时候,也是bulk+异步的方式写,也不至于存储过程卡住.<br>然后要说的是<code>Spark Streaming</code>,这个也是流处理框架,不过之前更多的是被称作<code>Micro Batch</code>框架,现在好像也支持真正意义上的流式处理了,细节就不多说了,没有实际用过.<code>Spark Streaming</code>在部门使用场景主要是为了处理<code>db binlog</code>数据.前面也说了<code>Jstorm</code>是异步的,意思就是不同的<code>bolt</code>之间异步,同一<code>bolt</code>不同<code>task</code>之间也是异步,但是有一些数据处理场景需要考虑到处理顺序以及同步,如果都是异步处理,那么数据的最终顺序可能会和读取的顺序不一致,所以这个时候就需要采用<code>Async+Sync</code>结合的方式处理.对应<code>Spark Streaming</code>来说就是<code>batch</code>与<code>batch</code>之前同步,<code>batch</code>内部<code>job</code>之间,<code>task</code>之间异步.<br>这样的好处也比较明显,<code>batch</code>之间类似于有一层屏障来控制顺序,但是<code>batch</code>内部的<code>task</code>并发处理数据，吞吐量也不会受同步影响太高.缺点也比较哦明显,需要等待前面的<code>batch</code>完成,所以<code>latency</code>必定比不上真正的流式处理框架<code>Jstorm</code>.<br>最后要说的一个是<code>Flink</code>,最初开始了解这个东西是在2016年,所以<code>Flink</code>诞生的时间最晚,因此在设计上也更加的先进(如果不是那也就没有必要重复设计).这个东西目前部门内部没有用,但是公司是主推新的作业尽量用<code>Flink</code>来开发.后面也打算把计算全部迁移到<code>Flink</code>,不过工程量可能有些大.就我调研和使用场景来说.这个东西确实要比<code>Jstorm</code>好,说几个我个人的感觉:</p>
<ol>
<li>Flink支持Scala开发,目前Jstorm还是用Java开发,做过数据开发的人就应该知道,Scala在数据处理方面确实要比Java写起来开发效率高很多,Java其优势还是在Web后端这块.</li>
<li>调试.这个开发过你就知道了,可能当初<code>Jstorm</code>的设计人员并没有考虑到这个问题,虽然<code>Jstorm</code>也可以在本地调试,但是需要你写不一样的代码;而<code>Flink</code>以及<code>Spark Streaming</code>这两者代码基本不需要怎么改就可以在本地调试,开发上更人性化.</li>
<li>设计理念,毕竟是后出来的,肯定设计的初衷也是为了解决当前框架无法解决,或者说无法优雅解决的问题.所以会吸收精华部分,摒弃糟粕,设计理念也会更加先进.尤其是一些关键点:吞吐,延迟,反压这些问题.</li>
</ol>
<p>另外还有个人建议不使用<code>Jstorm</code>的理由,从去年发布<code>Jstorm 2.2/2.4</code>之后,差不多有一年都没有更新了,社区活跃度不高,<code>Issue</code>基本上没人管了.不过有些东西比较有价值的,<code>flue-core</code>,这个东西其实是<code>Storm</code>的一个插件,当让也可以在<code>Jstorm</code>里面用,简单来说就是可以写一个<code>yaml</code>配置文件去定义一个作业,这样就不用再编译提交<code>jar</code>包来启动作业了．那么我们可以定义或者提前编写一些通用的公共<code>bolt</code>组件,做一个平台来开发<code>Jstorm</code>作业,可以做到页面化开发而不用手写<code>Java</code>代码.</p>
<p>最后说一下自己在使用这些大数据的开源组件的一些见解,其实用过很多组件之后会发现,他们之间会有一些共同的设计理念,举个<code>flume</code>的例子:<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/%E7%BA%BF%E4%B8%8AJstorm%E8%B0%83%E4%BC%98%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5003.png" alt="flume架构"><br>这里有三个比较重要的组件:<code>source,channel,sink</code>.我不知道是不是<code>flume</code>首创的这个,但是从组件的开源时间上来看应该是.很巧的是<code>flink</code>里面也是这么个结构,所以确实可以说这个结构真的是一个优秀的设计思想.尤其是<code>channel</code>这个思想,其实很多的开源组件在设计的时候并没有引入这种设计,比如<code>Canal</code>,所以只能自己去实现具体的数据存储功能,其实这个是不利于推广的,不能开箱即用.正因为<code>Channel</code>的存在,所以<code>source/sink</code>可以实现复用及自由组合,比较灵活,扩展性很强,但是需要有一个<code>Channel</code>支撑,<code>Kafka</code>就是这么个存在,所以<code>Kafka</code>的那几个哥们后来出来创业了,围绕<code>Kafka</code>创建了<a href="https://www.confluent.io/">Confluent</a>,这个里面围绕<code>Kafka</code>创建了各种不同的<code>source/sink</code>,基本涵盖了所有的数据源以及存储源,这种通过一个<code>Channel</code>来缓冲以及解藕不同的逻辑单元,在数据处理领域来说应该是一种非常值得借鉴的思想.在建设基础数据体系或者一个系统的时候,可以多考虑这种结构.</p>
]]></content>
      <categories>
        <category>数据架构</category>
      </categories>
      <tags>
        <tag>Jstorm</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>终极 Shell——zsh</title>
    <url>/2015/10/05/%E7%BB%88%E6%9E%81-Shell%E2%80%94%E2%80%94zsh/</url>
    <content><![CDATA[<p>目前常用的<code>Linux</code>系统和<code>OS X</code>系统的默认<code>Shell</code>都是<code>bash</code>，但是真正强大的<code>Shell</code> 是深藏不露的<code>zsh</code>， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，<a href="https://github.com/robbyrussell/oh-my-zsh">Github网址</a> 。</p>
<p>好，下面我们以Ubuntu 14.04为例看看如何安装、配置和使用 zsh。</p>
<h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h3><p>首先确保你安装了<code>git, zsh</code>,如果没有安装，按下面的命令来安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y git</span><br><span class="line">sudo apt-get install -y zsh</span><br></pre></td></tr></table></figure>
<p>装好了<code>zsh</code>还不够,还需要设置一下系统默认的shell环境:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure>
<p>然后重启，或者注销系统重新登陆。<br>然后就可以安装<code>oh-my-zsh</code>了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:robbyrussell/oh-my-zsh.git</span><br><span class="line"><span class="built_in">cp</span> ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> 有个地方要特别注意，之前的<code>Java</code>开发等环境变量都配置在了<code>.bashrc</code>文件里，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/dev/jdk1.7.0_40</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> M2_HOME=/usr/dev/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;M2_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> M2_HOME=/usr/dev/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;M2_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure>
<p>当我安装好<code>oh my zsh</code>之后，这些环境变量都失效了，研究一番才明白，我已经把默认的shell换成<code>.zshrc</code>了。所以需要把所有的环境变量重新配置到<code>zshrc</code>里，把你需要的这些内容拷贝到<code>.zshrc</code>里即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>zsh</code>的配置主要集中在用户当前目录的<code>.zshrc</code>里，用<code>vim</code>或你喜欢的其他编辑器打开<code>.zshrc</code></p>
<h4 id="配置快捷命令"><a href="#配置快捷命令" class="headerlink" title="配置快捷命令"></a>配置快捷命令</h4><p>可以在此处定义自己的环境变量和别名，当然，<code>oh my zsh</code>在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p>
<p>接下来进行别名的设置，我自己的部分配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">&#x27;clear&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -a&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">&#x27;vim&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> javac=<span class="string">&quot;javac -J-Dfile.encoding=utf8&quot;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&quot;grep --color=auto&quot;</span></span><br><span class="line"><span class="built_in">alias</span> -s html=mate   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开</span></span><br><span class="line"><span class="built_in">alias</span> -s rb=mate     <span class="comment"># 在命令行直接输入 ruby 文件，会在 TextMate 中打开</span></span><br><span class="line"><span class="built_in">alias</span> -s py=vi       <span class="comment"># 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> -s js=vi</span><br><span class="line"><span class="built_in">alias</span> -s c=vi</span><br><span class="line"><span class="built_in">alias</span> -s java=vi</span><br><span class="line"><span class="built_in">alias</span> -s txt=vi</span><br><span class="line"><span class="built_in">alias</span> -s gz=<span class="string">&#x27;tar -xzvf&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s tgz=<span class="string">&#x27;tar -xzvf&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s zip=<span class="string">&#x27;unzip&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s bz2=<span class="string">&#x27;tar -xjvf&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong> <code>zsh</code>的牛逼之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias -s html=mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取  </span><br><span class="line">hello.html </span><br><span class="line">alias -s gz=&#x27;tar -xzvf&#x27;，表示自动解压后缀为gz的压缩包。</span><br></pre></td></tr></table></figure>
<p>总之，只有想不到，木有做不到。</p>
<h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩<code>zsh</code>的主题。在<code>.zshrc</code>里找到<code>ZSH_THEME</code>，就可以设置主题了，默认主题是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=”robbyrussell”</span><br></pre></td></tr></table></figure>

<p><code>oh my zsh</code>提供了数十种主题，相关文件在<code>~/.oh-my-zsh/themes</code>目录下，你可以随意选择。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p><code>oh my zsh</code>项目提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git textmate ruby autojump osx mvn gradle)</span><br></pre></td></tr></table></figure>

<p>下面简单介绍几个：</p>
<ul>
<li>git</li>
</ul>
<p>当你处于一个<code>git</code>受控的目录下时，&#96;Shell 会明确显示 「git」和 branch，如下图所示：<br><img src="https://blog-1254094716.cos.ap-chengdu.myqcloud.com/note_%E7%BB%88%E6%9E%81%20Shell%E2%80%94%E2%80%94zsh01.png" alt="zsh-git 插件效果"></p>
<p>另外对<code>git</code>很多命令进行了简化，例如<code>gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’</code>等等，熟练使用可以大大减少<code>git</code>的命令长度，命令内容可以参考<code>~/.oh-my-zshplugins/git/git.plugin.zsh</code></p>
<ul>
<li>textmate</li>
</ul>
<p>mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。</p>
<ul>
<li>osx</li>
</ul>
<p>tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</p>
<ul>
<li>autojump</li>
</ul>
<p>zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。</p>
<p>首先安装autojump，如果你用 Mac，可以使用 brew 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure>

<p>如果是 Linux，去下载 autojump 的最新版本，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压缩后进入目录，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>最后把以下代码加入.zshrc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure>

<p>至此，安装、配置、插件三位一体，终极<code>Shell</code>全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！</p>
<h3 id="使用-zsh"><a href="#使用-zsh" class="headerlink" title="使用 zsh"></a>使用 zsh</h3><p>1、兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。</p>
<p>2、强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</p>
<p>3、智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</p>
<p>4、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n&#x2F;p&#x2F;f&#x2F;b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</p>
<p>5、智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</p>
<p>6、目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</p>
<p>7、在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</p>
<p>8、通配符搜索：ls -l **&#x2F;*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本语言时间处理函数总结</title>
    <url>/2016/04/23/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>平时做数据分析统计跑程序脚本需呀经常用到各种时间的转化和传入，日期的格式化，日期的相减，字符串时间互转。每次都是现查，比较浪费时间，这里把平时常用到的总结一下，因为涉及到好几个脚本语言的时间函数，我也记不住，干脆整理出一个查表更方便。主要涉及到Shell,Python,MySQL,Hive这几个脚本</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell感觉是最生涩的，最恶心的就是空格不能多也不能少，也没个IDE命令提示啥的，用的也最少，所以老容易忘</p>
<ul>
<li>常用的几种用法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ date	以默认格式显示当前日期(Fri Nov 18 10:38:07 CST 2011)</span><br><span class="line">$ date +%Y%m%d             以yyyymmdd格式输出(20160423)</span><br><span class="line">$ date +&quot;%Y%m%d %A&quot;		以&quot;yyyymmdd 星期&quot;格式输出(20160423 Friday)  </span><br><span class="line">$ date -d &quot;1 day&quot; +%Y%m%d	显示一天后的日期(20160424)</span><br><span class="line">$ date -d &quot;3 day ago&quot; +%Y-%m-%d	以指定格式显示3天前的日期(2016-04-26)</span><br><span class="line">$ date -d &quot;1 month&quot; +%Y-%m-%d	以指定格式显示一个月后的日期</span><br><span class="line">$ date -d &quot;1 month&quot; +%s	以指定格式显示一个月后的日期的秒数，%S为当前的秒数(0～59)</span><br><span class="line">$ date -d &quot;1970-01-01 CST 1 second&quot; +%s	显示从1970-01-01 CST起1秒后的秒数</span><br></pre></td></tr></table></figure>
<ul>
<li>用<code>-d</code>这个参数可以产生各种时间组合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ date -d &quot;-2 day 20160423&quot; +%Y%m%d</span><br><span class="line">20160421</span><br><span class="line">$ date -d &quot;+7 day 20160423&quot; +%Y%m%d</span><br><span class="line">20160430</span><br></pre></td></tr></table></figure>
<ul>
<li>日期循环</li>
</ul>
<p>这个场景还是很常用的，一般脚本都是默认跑当天或者前一天的数据，如果要一次重跑每一天的数据，可能就需要用到Shell日期循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin_date=&#x27;20160401&#x27;</span><br><span class="line">end_date=&#x27;20160423&#x27;</span><br><span class="line"></span><br><span class="line">while [ &quot;$begin_date&quot; != &quot;$end_date&quot; ]</span><br><span class="line">do</span><br><span class="line">	echo $begin_date</span><br><span class="line">	begin_date=`date -d &quot;1 day $begin_date&quot; +%Y%m%d`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>**注意:**一定要用<code>&quot;&quot;</code>把条件扩起来，<code>!=</code>史比较字符串的。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python里用的比较多的就是两个包<code>datetime</code>,<code>time</code></p>
<ul>
<li>datetime</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)	<span class="comment"># 2016-04-23</span></span><br><span class="line"><span class="built_in">str</span>(datetime.datetime.now())[:<span class="number">10</span>]	<span class="comment"># 2016-04-23</span></span><br><span class="line">(datetime.datetime.now() + datetime.timedelta(days=-<span class="number">1</span>)).strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)	<span class="comment"># 2016-04-22</span></span><br><span class="line">datetime.datetime.strptime(<span class="string">&#x27;2016-04-23&#x27;</span>, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)	<span class="comment"># 将字符串格式为datetime对象</span></span><br><span class="line">(d1 - d2 ).days	<span class="comment"># d1,d2 为datetime对象，计算连个日期之间相差多少天</span></span><br><span class="line">(d1 - d2 ).seconds	<span class="comment"># d1,d2 为datetime对象，计算连个日期之间相差多少秒</span></span><br><span class="line">datetime.weekday()	<span class="comment"># 返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推；</span></span><br><span class="line">datatime.isoweekday()	<span class="comment"># 返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推；</span></span><br><span class="line">datetime.fromtimestamp(timestamp)	<span class="comment"># 根据给定的时间戮，返回一个datetime对象；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>time<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;) # 格式化输出当前时间</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>主要是一些时间转换函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select unix_timestamp(&#x27;2016-01-01 10:10:10&#x27;);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| unix_timestamp(&#x27;2016-01-01 10:10:10&#x27;) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                            1451614210 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select from_unixtime(unix_timestamp());</span><br><span class="line">+---------------------------------+</span><br><span class="line">| from_unixtime(unix_timestamp()) |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| 2016-06-18 13:07:53             |</span><br><span class="line">+---------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to_date(&#x27;2016-04-23&#x27;)	# 2016-04-23</span><br><span class="line">to_date(&#x27;2016-04-23 12:21:10&#x27;)	# 2016-04-23</span><br><span class="line">datediff(end_time, start_time)	# 返回日期相隔天数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Hive</tag>
        <tag>Shell</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>流式计算引擎之-Spark Streaming灌水篇</title>
    <url>/2020/05/18/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E4%B9%8B-Spark-Streaming%E7%81%8C%E6%B0%B4%E7%AF%87/</url>
    <content><![CDATA[<h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>一直想写一篇关于<code>Spark Streaming</code>的文章，但是实在是事情太多，当然主要还是我比较懒，身边的同事已经明示我博客好久都不更新来催更了，技术都快荒废了，所以先水一篇。这篇文章虽然是叫灌水篇，但实际上都是我在实际项目中学习和总结到的一些切身经验，如果你真的想在生产环境去用Spark Streaming实现一些简单的实时计算或者实时监控，看板之类的，有一些问题是你一开始就得考虑到的，并且得有非常可靠的解决方案。</p>
<p>算起来差不多有快两年没用过<code>Spark Streaming</code>了，毕竟现在的公司也是主推<code>Flink</code>了，从趋势来看，的确是<code>Flink</code>的势头更猛一些，虽说<code>Spark Streaming</code>后来引入<code>Structed Streaming</code>，据说性能提升不少,这个我也没用过，暂时就不做深入讨论了。</p>
<p>其实这个系列计划后面还有一篇<code>JStorm</code>，一篇<code>Flink</code>，之所以把<code>Spark Streaming</code>放在第一篇来讲主要是有两个原因：首先是这个框架算是在实际做项目中钻研过一段时间，对其使用中的坑也算踩了不少，最后也算圆满完成了项目；其次是之前在招人的时候面试过很多人，简历上写了做过的一些<code>Spark Streaming</code>项目，在考察他们项目的时候，问的深了慢慢就懵了，从来没有碰到过一个人有认真思考过那些问题，当然这里面有很多人的简历大概率是培训机构的一些模板(数仓分层 + Spark Streaming + 用户画像，基本是这个结构，技术选型一模一样,另外也吐槽下那些培训机构，你告诉别人用户画像放在<code>HBase</code>这没啥问题，问题是你总得好好讲下<code>rowkey</code>这个吧，连怎么设计，为什么要这么设计也不讲讲，一问就完蛋)，本身也没真正做过<code>Spark Streaming</code>的项目，对框架的一些设计理念和底层的东西更加没有了解过。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>所以这篇文章主要会说一下一些实际项目中比较关注的问题，这些问题大概率也是面试官比较喜欢问的，做实时计算的确也绕不开那几个问题,好久没用了，想到什么写什么，截图是肯定没有了,但是如果你看到这篇文章，又或者在找解决方案，我想没有图应该也看得懂,下面就讲几个比较重要的问题。</p>
<h4 id="Spark-Streaming会丢数据吗"><a href="#Spark-Streaming会丢数据吗" class="headerlink" title="Spark Streaming会丢数据吗"></a>Spark Streaming会丢数据吗</h4><p>相信每个做实时计算的人都会碰到这个问题，或者说被别人追问过这个问题:为什么我从xxx能查到数据，从你实时处理之后就查不到了?又或者是这段时间的指标看着好像有问题，线上实时计算程序没漏掉数据吧？如果你非常自信的告诉别人，不可能丢的，这个<code>Spark Streaming</code>官网说了，xxx和xxx机制可以保证即使程序挂了，也能恢复，数据不会丢的。但是实际情况会比较复杂，很可能会被立马打脸，或者说运气好，丢了一两条也没人看的出来，但是其实有一些项目是连一条数据都不能丢的。</p>
<p>这里先说下结论，其实<code>Spark Streaming</code>是会丢数据的，要想保证数据100%不丢失，你需要根据实际情况，也就是输入输出的存储系统来做很多的处理，否则，丢数据的情况会有很多种，丢不丢数取决于你的集群和系统的稳定性。</p>
<p>所以每次碰到简历上写着<code>Spark Streaming</code>项目的人，我的第一个问题就是：你这个程序会丢数据吗？他们一开始都会很确定的告诉我不会，并且会开始讲自己是通过<code>Direct</code>的方式去消费<code>Kafka</code>的数据，手动维护<code>offset</code>的，只有当数据处理成功了才会提交offset,所以即使程序挂了，重启之后还是会从之前的offset开始消费，数据不会丢。当然有时候也会顺带问下他们<code>Receiver</code>模式和<code>Direct</code>的区别和为什么选后者，算是比较基本的问题，但是有的培训机构居然连这个也没讲明白。很多人都认为是不能手动维护<code>offset</code>，所以有丢数的风险,其实主要原因并不是这个，这里就不展开讲了。</p>
<p>但是我们面临的实际问题是，手动维护<code>offset</code>,确保每次处理成功了才提交<code>offset</code>就真的不会丢数据吗？从表面上来看，这个想法确实没什么问题，但是如果你对<code>Spark Sgreaming</code>了解的够深，就会发现这个想法是错的。其实要想知道会不会丢数，就得稍微了解一下底层的东西，或者说多看看监控和SparkUI界面的信息，了解一下<code>Application</code>,<code>Job</code>,<code>Task</code>,<code>Batch</code>这些概念，如果你把这几个东西搞清楚了，我相信你应该可以大致判断出来你写的程序是否有丢数据的风险以及在什么情况下会丢数据。</p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>正式讲问题之前，先得看几个基本概念</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Application</td>
<td>应用程序，也就是你每次提交一个Spark Streaming任务的时候，运行在集群上的一个计算任务</td>
</tr>
<tr>
<td>Batch</td>
<td><code>Spark Streaming</code>核心理念就是<code>micro batch</code>也就是算子和程序并不是时时刻刻都在计算和处理数据的，而是每隔一段时间成成一个批次</td>
</tr>
<tr>
<td>Job</td>
<td>一个计算任务可能会包含多个Job,大部分应该就是一个</td>
</tr>
<tr>
<td>Task</td>
<td>任务最终执行计算最小单位，对于<code>source</code>是<code>kafka</code>的情况，总的数量一般和需要消费的分区数相等，最大同时执行<code>task</code>个数可以通过一些参数来设置</td>
</tr>
</tbody></table>
<p>所以其实是每次开始调度执行一个Batch，会生成job，然后job会分stage,最细粒度就是到task执行具体的逻辑。因为我写<code>Spark Streaming</code>程序中也没见过有两个job的，所以暂且以只有一个job的程序为例，讨论下什么场景下会丢数据以及深层次的原因，下面主要介绍下<code>Task</code>和<code>Batch</code>：</p>
<ol>
<li>Task<br>作为最终消费和处理数据的执行单元，也就是你程序里面真正处理数据的算子和最终的<code>action</code>操作，对于手动维护<code>offset</code>来说，一般就是在所有数据处理完，就调用Kafka的api来<code>commit offset</code>，这样就确保了如果程序出现异常情况挂掉，<code>offset</code>不会更新，当程序再次重启，会从zk上读取消费的信息，从上一次最后提交的<code>offset</code>后开始消费数据。这也就是大家普遍认为不会丢数的依据;</li>
<li>Batch<br>一般会在程序中设置批次的间隔，也就是多长时间生成一个批次，这个取决于实际场景，假设是5min一个批次，所以每隔5分钟程序会自动生成新的批次，然后根据资源情况和上一个批次的执行情况来决定是否开始调度此批次。需要说明下，大部分情况，也就是默认情况下，同时执行的批次只能是一个，也就是如果数据太多导致上一个批次没有执行完，后面生成的批次就会被pending住。并且默认的调度算法是FIFO，所以基本上就是按数据的消费顺序来处理数据;</li>
<li>异常<br>可以看到其实整个<code>Spark Streaming</code>程序从表格上来看，从上到下是一个任务的逐渐细化过程，所以问题来了，计算任务失败是如何定义的,<code>Task</code>失败了<code>Job</code>会失败吗？<code>Batch</code>会失败吗？<code>Application</code>会失败吗？</li>
</ol>
<ul>
<li>Task会有默认的重试次数，好像是4次，可能不同的平台会额外设置，这个参数是可以设置的。Task执行失败了会自动重试，如果超过了最大重试次数还是执行失败，那这个Task所在的Job就失败了,所以当前批次的状态就是<code>Failed</code>；</li>
<li>Job失败了就失败了，因为Task已经重试过了仍然失败，最终这个<code>Batch</code>失败了, 但是<code>Application</code>并不会失败，一般而言，Task重试了很多次，会耗费很多时间，所以会有pending状态的Batch，这个时候其实会直接调用下一个pending的批次继续执行。</li>
</ul>
<h5 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h5><p>所以到这里你就应该明白了为什么说，即使你使用直连方式消费kafka，手动维护offset,仍然会丢数据。这里还需要再额外讲一下，每个批次在生成之前，就会计算出这个批次当前需要消费的数据范围，也就是[offset1,offset2]这种，对应到kafka的每个分区，哪怕你上一个batch还没执行完，下一个批次他会算出他此时需要消费的数据。至于怎么算的，有时间后面展开说，总之不是每次开始执行才去zk里面读取最新offset开始消费，这里记住就行了，因为和丢数有关。</p>
<p>上面讲到了每个批次要处理的数据其实是根据以往任务执行的情况来估算出来的，假设第一个批次在执行过程中由于在不停的重试，时间超过了一个批次，后面又生成了几个批次，并且由于同时最多只能有一个batch在执行，其他的都在pending状态。这个时候当Task的失败重试次数超过了设置的最大失败重试次数，即最终还是失败了，于是第一个批次就挂了。并且由于程序设置的是执行成功之后才会commit offset,导致偏移量也没有提交，到此为止还算正常毕竟虽然失败了，但是offset也没有更新，如果重启的话，还是会从上一次成功的地方接着消费。</p>
<p>但事实是紧接着由于第一个批次失败了，资源空闲出来了，后面pending的第一个批次就开始调度了，然后呢比较顺利，马上就执行成功了，这个时候程序触发了<code>commit offset</code>,将最新的消费情况更新到了zk。依次类推，后面的批次按照之前算好的消息范围继续消费，成功后<code>commit offset</code>。于是在执行成功了几个批次之后，突然发现，第一个批次失败了，offset被第二个和后面的批次更新覆盖了，然而实际上消息并没有被消费处理，因为第二个批次处理的消息是提前算好的，这就是数据丢失的真实场景。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>要怎么做才可以保证数据不丢失呢？其实通过上面的分析，会导致丢数据的根本原因其实是因为Batch失败了，但是Application并没有失败，后续执行的Batch成功了把offset给覆盖了。所以解决问题的方法其实有两种:</p>
<ol>
<li>不让Batch失败，这样就不会存在前面的批次失败了，后面的批次成功了这种情况。但是实际情况下总会存在程序出异常的情况，所以可以在程序出问题的时候将程序hang住，比如将Task的最大失败重试次数设置成int最大值。不过这样也有问题，一是如果就是程序的确就有问题，重试也不会成功，白白重试浪费资源；另外就是如果程序计算很快，那么重试也会有试完的时候，然后开始调度下一个<code>Batch</code>，所以并不推荐这种方式；</li>
<li><code>Batch</code>失败了让<code>Application</code>也失败，根本原因其实是<code>Batch</code>失败了<code>Application</code>没有失败，继续调度后续<code>Batch</code>导致<code>offset</code>被覆盖。这里需要借助因为第二个批次处理的消息是提前算好的，</li>
</ol>
<p>这里需要借助下<code>StreamingListener</code>这个类，你需要继承这个接口，来监听Job的执行状态，从而来控制当Job失败了，程序直接重启，不要直接调度下一个<code>Batch</code>。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Batch</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> failedCnt: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> successCnt: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasedataSparkBatchListener</span>(<span class="params">ssc: <span class="type">StreamingContext</span></span>) <span class="keyword">extends</span> <span class="title">StreamingListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> batch = <span class="keyword">new</span> <span class="type">Batch</span>()</span><br><span class="line">  <span class="comment">/** Called when a batch of jobs has been submitted for processing. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onBatchSubmitted</span></span>(batchSubmitted: <span class="type">StreamingListenerBatchSubmitted</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Called when processing of a batch of jobs has started.  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onBatchStarted</span></span>(batchStarted: <span class="type">StreamingListenerBatchStarted</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Called when processing of a batch of jobs has completed. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onBatchCompleted</span></span>(batchCompleted: <span class="type">StreamingListenerBatchCompleted</span>) &#123; </span><br><span class="line">   <span class="keyword">val</span> batchInfo = batchCompleted.batchInfo</span><br><span class="line">    <span class="keyword">val</span> outputOperations = batchInfo.outputOperationInfos</span><br><span class="line">    <span class="keyword">val</span> numFailedOutputOp = outputOperations.values.count(_.failureReason.nonEmpty)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (numFailedOutputOp != <span class="number">0</span>) &#123;</span><br><span class="line">      batch.failedCnt += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      batch.failedCnt += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有很多方法，这里其实只需要实现<code>onBatchCompleted</code>方法获取失败的Batch数量就行,然后主程序需要注册下这个<code>listener</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val listener = new BasedataSparkBatchListener(ssc)</span><br><span class="line">ssc.addStreamingListener(listener)</span><br></pre></td></tr></table></figure>
<p>然后在提交offset的地方需要做一个判断，如果是<code>listener.batch.failedCnt &gt; 0</code>，执行<code>ssc.stop()</code>将程序杀掉，如果<code>listener.batch.failedCnt = 0</code>,则执行<code>commit offset</code>操作。</p>
<h4 id="限速和背压设置"><a href="#限速和背压设置" class="headerlink" title="限速和背压设置"></a>限速和背压设置</h4><h4 id="Exactly-once真的必要吗"><a href="#Exactly-once真的必要吗" class="headerlink" title="Exactly once真的必要吗"></a>Exactly once真的必要吗</h4><h4 id="Speculative机制有什么问题"><a href="#Speculative机制有什么问题" class="headerlink" title="Speculative机制有什么问题"></a>Speculative机制有什么问题</h4>]]></content>
      <categories>
        <category>数据架构</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Spark</tag>
        <tag>流计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+next主题开启搜索功能</title>
    <url>/2023/10/09/Hexo-next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>最近重新把博客捡起来了，由于好久都没更新，导致在新的机器上各种跑不起来，于是索性把依赖都更新成最新的了。另外好久不用，hexo跟next主题更新了不少新功能，也顺便都加上了，加了几个插件，感觉还不错，尤其是搜索插件，很多年以前用Hexo些博客最头疼的就是没有检索功能，只能依靠标签跟归档文件夹去找。在添加搜索插件的时候，一开始并不生效，后面解决了，在此记录录一下开启搜索功能的过程。</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>本次是以<a href="https://theme-next.js.org/">NexT</a>主题为例，所以确保你也是使用的这个主题，其他的请自行Google搜索，由于配置用的是最新的，所以也贴一下版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blog git:(master) ✗ hexo -v</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 6.3.0</span><br><span class="line">hexo-cli: 4.3.1</span><br><span class="line">os: darwin 22.5.0 13.4</span><br></pre></td></tr></table></figure>
<p>NexT版本是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;name&quot;: &quot;hexo-theme-next&quot;,</span><br><span class="line">&quot;version&quot;: &quot;8.18.1&quot;,</span><br></pre></td></tr></table></figure>

<h3 id="安装搜索插件"><a href="#安装搜索插件" class="headerlink" title="安装搜索插件"></a>安装搜索插件</h3><p>在博客根目录执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>然后重新生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>都操作完之后，可以在<code>public</code>目录下看到多了一个文件<code>search.xml</code>，到这里我以为已经可以了，但是启动本地服务之后，反复试了几次还是不行，导航栏没有任何变化，根本没有搜索入口。<br>然后去看了下官方文档，发现好像要自己写代码，官方文档解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How to use this plugin in my Hexo blog?</span><br><span class="line">You have two choices:</span><br><span class="line"></span><br><span class="line">you don&#x27;t want to write search engine by yourself. There are many themes that take use this plugin for local searching that works out of box.</span><br><span class="line"></span><br><span class="line">you are familiar with JavaScript and would like to write your own search engine. You can implement one by yourself according to the template code search.js. There is no documentation at present, but you can find its usage in the source code of the theme NexT. Generally there are 3 steps:</span><br><span class="line"></span><br><span class="line">write a search view. This is the place for displaying a search form and search results;</span><br><span class="line">load the search.js script via CDN, for example:</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">A LocalSearch class is provided in the search.js which tells the browser how to grab search data and filter out contents what we&#x27;re searching;</span><br><span class="line"></span><br><span class="line">write a search script, make use of the previous LocalSearch class.</span><br></pre></td></tr></table></figure>
<p>乍一看好像得自己写JS代码才能行，准备放弃了，后来仔细看了下第一段，好多主题都是用的这个插件来实现本地搜索的，于是我搜了下NexT的本地配置文件<code>_config.yml</code>，发现了这么一段配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>原来NexT的本地搜索用的就是<code>hexo-generator-searchdb</code>插件，只是开关默认是关闭的，于是将<code>enable</code>属性改成<code>true</code>，再次重新启动服务，本地已经出现搜索入口了，如图所示：<br><img src="https://blog-1254088983.cos.ap-guangzhou.myqcloud.com/Hexo%2Bnext%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD001.png" alt="本地搜索功能截图"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
